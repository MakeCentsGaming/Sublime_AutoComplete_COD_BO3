{
	"scope": "source.gsc",

	"completions":
[	
	"\"script_noteworthy\"",
	"\"targetname\"",
	"break;",
	"continue;",
	"level",
	"return;",
	"script_noteworthy",
	"targetname",
	"thread ",
	"undefined",
	"function ",
	"HINT_NOICON",
	{ "trigger": "namespace\t#namespace", "contents": "#namespace ${1};"},
	// { "trigger": "namespace\tnamespace", "contents": "namespace ${1};"},
	{ "trigger": "using\t#using", "contents": "#using ${1:scripts}${2:\\zm}${3:\\ };"},
	// { "trigger": "using\tusing", "contents": "using  ${1:scripts}/${2};"},
	{ "trigger": "add_to_score\tplayer add to score", "contents": "zm_score::add_to_player_score(${1:cost})"},
	{ "trigger": "flag clear\t", "contents": "flag::clear(${1:flag});" },
	{ "trigger": "flag get\t", "contents": "flag::get(${1:flag});" },
	{ "trigger": "flag init\t", "contents": "flag::init(${1:flag});" },
	{ "trigger": "flag set\t", "contents": "flag::set(${1:flag});" },
	{ "trigger": "flag wait_till\t", "contents": "flag::wait_till(${1:flag});" },
	{ "trigger": "for\tfor loop", "contents": "for( ${2}=0;${2}<${1}.size;${2}++ ){\n\t${1}[${2}] thread ${3}();\n}" },
	{ "trigger": "for\tplayers loop", "contents": "for( i=0;i<players.size;i++ ){\n\tplayers[i] thread ${3}();\n}" },
	{ "trigger": "GetEnt\tscript_noteworthy","contents": "GetEnt(${1:<name>},${2:\"script_noteworthy\"})"},
	{ "trigger": "GetEnt\ttargetname","contents": "GetEnt(${1:<name>},${2:\"targetname\"})"},
	{ "trigger": "GetEntArray\tscript_noteworthy","contents": "GetEntArray(${1:[name]},${2:\"script_noteworthy\"})"},
	{ "trigger": "GetEntArray\ttargetname","contents": "GetEntArray(${1:[name]},${2:\"targetname\"})"},
	{ "trigger": "struct::get\ttargetname", "contents": "struct::get(${1:kvp_value}, ${2:\"targetname\"})"},
	{ "trigger": "struct::get\tscript_noteworthy;", "contents": "struct::get(${1:kvp_value}, ${2:\"script_noteworthy\"})"},
	{ "trigger": "GetWeapon\tweapon object","contents": "GetWeapon(${1:<name>})"},
	{ "trigger": "MakeCents\tInstructions", "contents": "/*\n#####################\nby: M.A.K.E C E N T S\n#####################\nAdd to main in mapname.gsc\n${1:namespace}::init(  );\n\nAdd to top of mapname.gsc\n#using scripts\\zm\\ ${2:script name};\n\nAdd to zone file\nscriptparsetree,scripts/zm/ ${2:script name}.gsc\n\n###############################################################################\n*/\n\n#namespace ${1:namespace};\nfunction init()\n{\n\t${3}\n}"},
	{ "trigger": "MakeCents\tInstructions w/autoexec", "contents": "/*\n#####################\nby: M.A.K.E C E N T S\n#####################\nAdd to top of mapname.gsc\n#using scripts\\zm\\ ${1:script name};\n\nAdd to zone file\nscriptparsetree,scripts/zm/ ${1:script name}.gsc\n\n###############################################################################\n*/\n\n#namespace ${1:namespace};\nfunction autoexec init()\n{\n\t${3}\n}"},
	{ "trigger": "minus_to_score\tplayer minus score", "contents": "zm_score::minus_to_player_score(${1:cost})"},
	{ "trigger": "players", "contents": "players = GetPlayers()" },
	{ "trigger": "players\twith for loop", "contents": "players = GetPlayers();\nfor( i=0;i<players.size;i++ ){\n\t ${3:players[i]} ${4:thread };\n}" },
	{ "trigger": "precache\txanim", "contents": "#precache( \"${1:xanim}\", \"${2:yourAnimFileName}\");"},
	{ "trigger": "using\tanim tree", "contents": "#using_animtree(\"${1:yourATRfile}\");"},
	{ "trigger": "insert\tshared", "contents": "#insert scripts\\shared\\shared.gsh;" },
	{ "trigger": "using\tcombine sound", "contents": "#using scripts\\mp\\mp_combine_sound;" },
	{ "trigger": "while\tconditional loop", "contents": "while( ${1} ){\n\t${2}\n}" },
	{ "trigger": "while\tinfinite loop", "contents": "while( 1 ){\n\t${1}\n}" },
	{ "trigger": "class\t – declares a class, its associated variables and functionality.", "contents": "class ${1}"},
	{ "trigger": "function\t – declares a function.", "contents": "function ${1}()\n{\n\t${2}\n}"},
	{ "trigger": "function private\t – declares a private function.", "contents": "function private ${1}()\n{\n\t${2}\n}"},
	{ "trigger": "var\t – valid within a class declaration. Declares a class variable accessible by all class functions.", "contents": "var ${1}"},
	{ "trigger": "return\t - returns a value from a function. Any function that does not explicity return a value is assumed to return undefined.", "contents": "return;"},
	{ "trigger": "wait\t – causes the current execution context to go into a sleeping state immediately for the specified time. The next pending thread of execution will begin immediately.", "contents": "wait(${1});"},
	{ "trigger": "thread\t – creates a function call that has a separate thread of execution. This call can optionally pause its state of execution prior to returning. In that case the caller is immediately resumed at the point following the threaded call.", "contents": "thread ${1}"},
	{ "trigger": "undefined\t – a special value that indicates no value is present. An array can contain undefined values without collapsing the array automatically.", "contents": "undefined;"},
	{ "trigger": "self\t – a special value that represents the variable used in a method type call.", "contents": "self ${1}"},
	{ "trigger": "world\t – a persistent global variable (struct) whose contents survive from level to level. Note that there are restrictions on the data types that may be placed into the world object. Lifespan is the duration of the game execution.", "contents": "world ${1}"},
	{ "trigger": "level\t – a global variable (struct) for general use during the execution of a level. Lifespan in the duration of a level.", "contents": "level ${1}"},
	{ "trigger": "game\t – a global variable (array) for general use during the execution of a level. Lifespan is the duration of a match. If – if conditional clause construct.", "contents": "game ${1}"},
	{ "trigger": "else\t – if condition clause construct.", "contents": "else\n{\n\t${1}\n}"},
	{ "trigger": "do\t – do while loop construct", "contents": "do ${1}"},
	{ "trigger": "while\t – do while loop construct or while loop construct.", "contents": "while(${1})"},
	{ "trigger": "for\t – for loop construct.", "contents": "for(${1};${2};${3})"},
	{ "trigger": "foreach\t – foreach loop construct.", "contents": "foreach(${1} in ${2})"},
	{ "trigger": "in\t – foreach loop construct.", "contents": "in "},
	{ "trigger": "new\t – create a new instance of a class object.", "contents": "new ${1}"},
	{ "trigger": "waittill\t – wait for a specific notify to occur.", "contents": "waittill(${1});"},
	{ "trigger": "waittillmatch\t – wait for multiple specific notifies.", "contents": "waittillmatch(${1},${2});"},
	{ "trigger": "waittillframeend\t – move the current thread of execution to the end of the pending list.", "contents": "waittillframeend();"},
	{ "trigger": "switch\t – switch state construct.", "contents": "switch(${1:switch}){\n\tcase ${2:case}:\n\t\t\n\tdefault:\n\t\tbreak;\n}"},
	{ "trigger": "case\t – switch state construct.", "contents": "case ${1:case}:\n\t\t"},
	{ "trigger": "default\t – switch state construct.", "contents": "default:\n\t\t"},
	{ "trigger": "break\t – break the current execution and resume at the tail of the current block.", "contents": "break;"},
	{ "trigger": "continue\t – jump to the conditional clause in a loop.", "contents": "continue;"},
	{ "trigger": "false\t – Boolean false.", "contents": "false"},
	{ "trigger": "true\t – Boolean true.", "contents": "true"},
	{ "trigger": "notify\t – send a notify signal that can get intercepted by all pending threads at a waittill.", "contents": "notify(${1});"},
	{ "trigger": "endon\t – terminate the current thread of execution immediately on receipt of the specified signal.", "contents": "endon(${1});"},
	{ "trigger": "assert\t – Only tested when devblocks are enabled. Break execution if the supplied condition evaluates as false.", "contents": "assert(${1});"},
	{ "trigger": "assertmsg\t – same as assert, but provide an output string to print if the supplied condition evaluates as false.", "contents": "assertmsg(${1});"},
	{ "trigger": "constructor\t – specifies the constructor function for a class. Does not support parameters at this time.", "contents": "constructor ${1}"},
	{ "trigger": "destructor\t – specifies the destructor function for a class. Called automatically when final reference to a class object is released.", "contents": "destructor ${1}"},
	{ "trigger": "autoexec\t – option for a function. Function is executed automatically prior to the level entry point getting called.", "contents": "autoexec ${1}"},
	{ "trigger": "private\t – removes a function from the export table. No external calls are allowed.", "contents": "private ${1}"},
	{ "trigger": "const\t – declare a variable as fixed and unchanging. Helps the compiler produce more optimal code by allowing some compile time optimizations to occur.", "contents": "const ${1}"},
	{ "trigger": "isdefined\t – returns true if the variable contains a value other than undefined.", "contents": "isdefined(${1})"},
	{ "trigger": ".size\t – evaluates the expression as the number of elements in an array object.", "contents": "size"},
	{ "trigger": "thread_all\tthread_all(ents, function)", "contents": "array::thread_all(${1:entities}, &${2:func});"},
	{ "trigger": "SetCursorHint\tHINT_NOICON","contents": "SetCursorHint(\"HINT_NOICON\");"},
	{ "trigger": "SetHintString\tPress Use to activate","contents": "SetHintString(\"${1:Press} [{+activate}] ${2:to activate}\");"},
	]
}