{
	"scope": "source.gsc",
	"completions":
[	
		"#using scripts\\mp\\gametypes\\ctf;",
	"#using scripts\\mp\\gametypes\\dm;",
	"#using scripts\\mp\\gametypes\\dom;",
	"#using scripts\\mp\\gametypes\\fr;",
	"#using scripts\\mp\\gametypes\\koth;",
	"#using scripts\\mp\\gametypes\\sd;",
	"#using scripts\\mp\\gametypes\\tdm;",
	"#using scripts\\mp\\gametypes\\_ball_utils;",
	"#using scripts\\mp\\gametypes\\_battlechatter;",
	"#using scripts\\mp\\gametypes\\_clientids;",
	"#using scripts\\mp\\gametypes\\_deathicons;",
	"#using scripts\\mp\\gametypes\\_dogtags;",
	"#using scripts\\mp\\gametypes\\_friendicons;",
	"#using scripts\\mp\\gametypes\\_globallogic;",
	"#using scripts\\mp\\gametypes\\_globallogic_actor;",
	"#using scripts\\mp\\gametypes\\_globallogic_audio;",
	"#using scripts\\mp\\gametypes\\_globallogic_defaults;",
	"#using scripts\\mp\\gametypes\\_globallogic_player;",
	"#using scripts\\mp\\gametypes\\_globallogic_score;",
	"#using scripts\\mp\\gametypes\\_globallogic_spawn;",
	"#using scripts\\mp\\gametypes\\_globallogic_ui;",
	"#using scripts\\mp\\gametypes\\_globallogic_utils;",
	"#using scripts\\mp\\gametypes\\_globallogic_vehicle;",
	"#using scripts\\mp\\gametypes\\_healthoverlay;",
	"#using scripts\\mp\\gametypes\\_hostmigration;",
	"#using scripts\\mp\\gametypes\\_hud_message;",
	"#using scripts\\mp\\gametypes\\_killcam;",
	"#using scripts\\mp\\gametypes\\_loadout;",
	"#using scripts\\mp\\gametypes\\_menus;",
	"#using scripts\\mp\\gametypes\\_perplayer;",
	"#using scripts\\mp\\gametypes\\_serversettings;",
	"#using scripts\\mp\\gametypes\\_shellshock;",
	"#using scripts\\mp\\gametypes\\_spawning;",
	"#using scripts\\mp\\gametypes\\_spawnlogic;",
	"#using scripts\\mp\\gametypes\\_spectating;",
	"#using scripts\\mp\\gametypes\\_tweakables;",
	"#using scripts\\mp\\gametypes\\_wager;",
	"#using scripts\\mp\\gametypes\\_weaponobjects;",
	"#using scripts\\mp\\gametypes\\_weapons;",
	"#using scripts\\mp\\gametypes\\_weapon_utils;",
	"#using scripts\\mp\\vehicles\\_quadtank;",
	"#using scripts\\mp\\vehicles\\_siegebot;",
	"#using scripts\\mp\\vehicles\\_siegebot_theia;",
	"#using scripts\\mp\\bots\\_bot;",
	"#using scripts\\mp\\bots\\_bot_ball;",
	"#using scripts\\mp\\bots\\_bot_clean;",
	"#using scripts\\mp\\bots\\_bot_combat;",
	"#using scripts\\mp\\bots\\_bot_ctf;",
	"#using scripts\\mp\\bots\\_bot_dom;",
	"#using scripts\\mp\\bots\\_bot_koth;",
	"#using scripts\\mp\\bots\\_bot_loadout;",
	"#using scripts\\mp\\bots\\_bot_sd;",
	"#using scripts\\mp\\killstreaks\\_airsupport;",
	"#using scripts\\mp\\killstreaks\\_ai_tank;",
	"#using scripts\\mp\\killstreaks\\_combat_robot;",
	"#using scripts\\mp\\killstreaks\\_counteruav;",
	"#using scripts\\mp\\killstreaks\\_dart;",
	"#using scripts\\mp\\killstreaks\\_dogs;",
	"#using scripts\\mp\\killstreaks\\_drone_strike;",
	"#using scripts\\mp\\killstreaks\\_emp;",
	"#using scripts\\mp\\killstreaks\\_flak_drone;",
	"#using scripts\\mp\\killstreaks\\_helicopter;",
	"#using scripts\\mp\\killstreaks\\_helicopter_guard;",
	"#using scripts\\mp\\killstreaks\\_helicopter_gunner;",
	"#using scripts\\mp\\killstreaks\\_killstreakrules;",
	"#using scripts\\mp\\killstreaks\\_killstreaks;",
	"#using scripts\\mp\\killstreaks\\_killstreak_bundles;",
	"#using scripts\\mp\\killstreaks\\_killstreak_detect;",
	"#using scripts\\mp\\killstreaks\\_killstreak_hacking;",
	"#using scripts\\mp\\killstreaks\\_killstreak_weapons;",
	"#using scripts\\mp\\killstreaks\\_microwave_turret;",
	"#using scripts\\mp\\killstreaks\\_missile_drone;",
	"#using scripts\\mp\\killstreaks\\_missile_swarm;",
	"#using scripts\\mp\\killstreaks\\_placeables;",
	"#using scripts\\mp\\killstreaks\\_planemortar;",
	"#using scripts\\mp\\killstreaks\\_qrdrone;",
	"#using scripts\\mp\\killstreaks\\_raps;",
	"#using scripts\\mp\\killstreaks\\_rcbomb;",
	"#using scripts\\mp\\killstreaks\\_remotemissile;",
	"#using scripts\\mp\\killstreaks\\_remotemortar;",
	"#using scripts\\mp\\killstreaks\\_remote_weapons;",
	"#using scripts\\mp\\killstreaks\\_satellite;",
	"#using scripts\\mp\\killstreaks\\_sentinel;",
	"#using scripts\\mp\\killstreaks\\_straferun;",
	"#using scripts\\mp\\killstreaks\\_supplydrop;",
	"#using scripts\\mp\\killstreaks\\_turret;",
	"#using scripts\\mp\\killstreaks\\_uav;",
	"#using scripts\\mp\\mp_combine;",
	"#using scripts\\mp\\mp_freerun;",
	"#using scripts\\mp\\_arena;",
	"#using scripts\\mp\\_armblade;",
	"#using scripts\\mp\\_armor;",
	"#using scripts\\mp\\_art;",
	"#using scripts\\mp\\_behavior_tracker;",
	"#using scripts\\mp\\_blackjack_challenges;",
	"#using scripts\\mp\\_callbacks;",
	"#using scripts\\mp\\_challenges;",
	"#using scripts\\mp\\_contracts;",
	"#using scripts\\mp\\_destructible;",
	"#using scripts\\mp\\_elevator;",
	"#using scripts\\mp\\_events;",
	"#using scripts\\mp\\_explosive_bolt;",
	"#using scripts\\mp\\_gameadvertisement;",
	"#using scripts\\mp\\_gamerep;",
	"#using scripts\\mp\\_incendiary;",
	"#using scripts\\mp\\_laststand;",
	"#using scripts\\mp\\_load;",
	"#using scripts\\mp\\_mgturret;",
	"#using scripts\\mp\\_nuketown_mannequin;",
	"#using scripts\\mp\\_perks;",
	"#using scripts\\mp\\_pickup_items;",
	"#using scripts\\mp\\_scoreevents;",
	"#using scripts\\mp\\_teamops;",
	"#using scripts\\mp\\_teargrenades;",
	"#using scripts\\mp\\_threat_detector;",
	"#using scripts\\mp\\_util;",
	"#using scripts\\mp\\_vehicle;",
	"#using scripts\\mp\\teams\\_teams;",
	"#using scripts\\mp\\teams\\_teamset_allies;",
	"#using scripts\\mp\\teams\\_teamset_axis;",
	"#using scripts\\mp\\teams\\_teamset_multiteam;",
	{ "trigger": "on_bot_connect\t#using scripts\\mp\\bots\\_bot_ctf;", "contents": "bot_ctf::on_bot_connect()"},
	{ "trigger": "bot_idle\t#using scripts\\mp\\bots\\_bot_ctf;", "contents": "bot_ctf::bot_idle()"},
	{ "trigger": "registerDvars\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::registerDvars()"},
	{ "trigger": "blank\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::blank(${1:arg1}, ${2:arg2}, ${3:arg3}, ${4:arg4}, ${5:arg5}, ${6:arg6}, ${7:arg7}, ${8:arg8}, ${9:arg9}, ${10:arg10})"},
	{ "trigger": "setup_callbacks\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::setup_callbacks()"},
	{ "trigger": "precache_mp_friend_leaderboards\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::precache_mp_friend_leaderboards()"},
	{ "trigger": "precache_mp_anticheat_leaderboards\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::precache_mp_anticheat_leaderboards()"},
	{ "trigger": "precache_mp_public_leaderboards\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::precache_mp_public_leaderboards()"},
	{ "trigger": "precache_mp_custom_leaderboards\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::precache_mp_custom_leaderboards()"},
	{ "trigger": "precache_mp_leaderboards\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::precache_mp_leaderboards()"},
	{ "trigger": "setvisiblescoreboardcolumns\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::setvisiblescoreboardcolumns(${1:col1}, ${2:col2}, ${3:col3}, ${4:col4}, ${5:col5})"},
	{ "trigger": "compareTeamByGameStat\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::compareTeamByGameStat(${1:gameStat}, ${2:teamA}, ${3:teamB}, ${4:previous_winner_score})"},
	{ "trigger": "determineTeamWinnerByGameStat\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::determineTeamWinnerByGameStat(${1:gameStat})"},
	{ "trigger": "compareTeamByTeamScore\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::compareTeamByTeamScore(${1:teamA}, ${2:teamB}, ${3:previous_winner_score})"},
	{ "trigger": "determineTeamWinnerByTeamScore\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::determineTeamWinnerByTeamScore()"},
	{ "trigger": "forceEnd\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::forceEnd(${1:hostsucks})"},
	{ "trigger": "killserverPc\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::killserverPc()"},
	{ "trigger": "atLeastTwoTeams\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::atLeastTwoTeams()"},
	{ "trigger": "checkIfTeamForfeits\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::checkIfTeamForfeits(${1:team})"},
	{ "trigger": "checkForForfeit\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::checkForForfeit()"},
	{ "trigger": "doSpawnQueueUpdates\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::doSpawnQueueUpdates()"},
	{ "trigger": "isTeamAllDead\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::isTeamAllDead(${1:team})"},
	{ "trigger": "areAllTeamsDead\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::areAllTeamsDead()"},
	{ "trigger": "getLastTeamAlive\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::getLastTeamAlive()"},
	{ "trigger": "doDeadEventUpdates\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::doDeadEventUpdates()"},
	{ "trigger": "isOnlyOneLeftAliveOnTeam\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::isOnlyOneLeftAliveOnTeam(${1:team})"},
	{ "trigger": "doOneLeftEventUpdates\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::doOneLeftEventUpdates()"},
	{ "trigger": "updateGameEvents\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::updateGameEvents()"},
	{ "trigger": "mpintro_visionset_ramp_hold_func\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::mpintro_visionset_ramp_hold_func()"},
	{ "trigger": "mpintro_visionset_activate_func\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::mpintro_visionset_activate_func()"},
	{ "trigger": "mpintro_visionset_deactivate_func\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::mpintro_visionset_deactivate_func()"},
	{ "trigger": "matchStartTimer\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::matchStartTimer()"},
	{ "trigger": "notifyEndOfGameplay\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::notifyEndOfGameplay()"},
	{ "trigger": "matchStartTimerSkip\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::matchStartTimerSkip()"},
	{ "trigger": "sndSetMatchSnapshot\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::sndSetMatchSnapshot(${1:num})"},
	{ "trigger": "notifyTeamWaveSpawn\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::notifyTeamWaveSpawn(${1:team}, ${2:time})"},
	{ "trigger": "waveSpawnTimer\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::waveSpawnTimer()"},
	{ "trigger": "hostIdledOut\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::hostIdledOut()"},
	{ "trigger": "IncrementMatchCompletionStat\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::IncrementMatchCompletionStat(${1:gameMode}, ${2:playedOrHosted}, ${3:stat})"},
	{ "trigger": "SetMatchCompletionStat\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::SetMatchCompletionStat(${1:gameMode}, ${2:playedOrHosted}, ${3:stat})"},
	{ "trigger": "getTeamScoreRatio\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::getTeamScoreRatio()"},
	{ "trigger": "getHighestScore\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::getHighestScore()"},
	{ "trigger": "getNextHighestScore\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::getNextHighestScore(${1:score})"},
	{ "trigger": "RecordPlayStyleInformation\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::RecordPlayStyleInformation()"},
	{ "trigger": "getPlayerByName\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::getPlayerByName(${1:name})"},
	{ "trigger": "sendAfterActionReport\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::sendAfterActionReport()"},
	{ "trigger": "UpdateAndFinalizeMatchRecord\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::UpdateAndFinalizeMatchRecord()"},
	{ "trigger": "gameHistoryPlayerKicked\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::gameHistoryPlayerKicked()"},
	{ "trigger": "gameHistoryPlayerQuit\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::gameHistoryPlayerQuit()"},
	{ "trigger": "displayRoundEnd\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::displayRoundEnd(${1:winner}, ${2:endReasonText})"},
	{ "trigger": "displayRoundSwitch\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::displayRoundSwitch(${1:winner}, ${2:endReasonText})"},
	{ "trigger": "displayGameEnd\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::displayGameEnd(${1:winner}, ${2:endReasonText})"},
	{ "trigger": "recordEndGameComScoreEvent\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::recordEndGameComScoreEvent(${1:result})"},
	{ "trigger": "getEndReasonText\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::getEndReasonText()"},
	{ "trigger": "resetOutcomeForAllPlayers\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::resetOutcomeForAllPlayers()"},
	{ "trigger": "hideOutcomeUIForAllPlayers\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::hideOutcomeUIForAllPlayers()"},
	{ "trigger": "startNextRound\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::startNextRound(${1:winner}, ${2:endReasonText})"},
	{ "trigger": "setTopPlayerStats\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::setTopPlayerStats()"},
	{ "trigger": "setTopTeamStats\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::setTopTeamStats(${1:team})"},
	{ "trigger": "figureOutWinningTeam\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::figureOutWinningTeam(${1:winner})"},
	{ "trigger": "getRoundLength\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::getRoundLength()"},
	{ "trigger": "awardLootXP\t#using scripts\\mp\\gametypes\\_globallogic; self == player", "contents": "globallogic::awardLootXP()"},
	{ "trigger": "WaitAndUploadStats\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::WaitAndUploadStats(${1:player}, ${2:waitTime})"},
	{ "trigger": "registerOtherLootXPAwards\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::registerOtherLootXPAwards(${1:func})"},
	{ "trigger": "awardOtherLootXP\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::awardOtherLootXP()"},
	{ "trigger": "endGame\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::endGame(${1:winner}, ${2:endReasonText})"},
	{ "trigger": "awardLootXPToPlayers\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::awardLootXPToPlayers(${1:delay}, ${2:players})"},
	{ "trigger": "exit_level\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::exit_level()"},
	{ "trigger": "update_top_scorers\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::update_top_scorers(${1:winner})"},
	{ "trigger": "checkForGestures\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::checkForGestures(${1:topPlayerIndex})"},
	{ "trigger": "setGestureClientField\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::setGestureClientField(${1:fieldName}, ${2:gestureType})"},
	{ "trigger": "doEndGameSequence\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::doEndGameSequence()"},
	{ "trigger": "getTotalTimePlayed\t#using scripts\\mp\\gametypes\\_globallogic; self == player", "contents": "globallogic::getTotalTimePlayed(${1:maxLength})"},
	{ "trigger": "getRoundTimePlayed\t#using scripts\\mp\\gametypes\\_globallogic; self == player", "contents": "globallogic::getRoundTimePlayed(${1:roundLength})"},
	{ "trigger": "bbPlayerMatchEnd\t#using scripts\\mp\\gametypes\\_globallogic; self == player", "contents": "globallogic::bbPlayerMatchEnd(${1:gameLength}, ${2:endReasonString}, ${3:gameOver})"},
	{ "trigger": "roundEndWait\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::roundEndWait(${1:defaultDelay}, ${2:matchBonus})"},
	{ "trigger": "roundEndDOF\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::roundEndDOF(${1:time})"},
	{ "trigger": "checkTimeLimit\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::checkTimeLimit()"},
	{ "trigger": "checkScoreLimit\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::checkScoreLimit()"},
	{ "trigger": "checkSuddenDeathScoreLimit\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::checkSuddenDeathScoreLimit(${1:team})"},
	{ "trigger": "checkRoundScoreLimit\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::checkRoundScoreLimit()"},
	{ "trigger": "updateGameTypeDvars\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::updateGameTypeDvars()"},
	{ "trigger": "removeDisconnectedPlayerFromPlacement\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::removeDisconnectedPlayerFromPlacement()"},
	{ "trigger": "updatePlacement\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::updatePlacement()"},
	{ "trigger": "updateTeamPlacement\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::updateTeamPlacement()"},
	{ "trigger": "getPlacementForPlayer\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::getPlacementForPlayer(${1:player})"},
	{ "trigger": "isTopScoringPlayer\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::isTopScoringPlayer(${1:player})"},
	{ "trigger": "sortDeadPlayers\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::sortDeadPlayers(${1:team})"},
	{ "trigger": "totalAliveCount\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::totalAliveCount()"},
	{ "trigger": "totalPlayerLives\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::totalPlayerLives()"},
	{ "trigger": "resetTeamVariables\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::resetTeamVariables(${1:team})"},
	{ "trigger": "updateTeamStatus\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::updateTeamStatus()"},
	{ "trigger": "updateAliveTimes\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::updateAliveTimes(${1:team})"},
	{ "trigger": "updateAllAliveTimes\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::updateAllAliveTimes()"},
	{ "trigger": "checkTeamScoreLimitSoon\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::checkTeamScoreLimitSoon(${1:team})"},
	{ "trigger": "checkPlayerScoreLimitSoon\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::checkPlayerScoreLimitSoon()"},
	{ "trigger": "timeLimitClock\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::timeLimitClock()"},
	{ "trigger": "timeLimitClock_Intermission\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::timeLimitClock_Intermission(${1:waitTime})"},
	{ "trigger": "recordBreadcrumbData\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::recordBreadcrumbData()"},
	{ "trigger": "startGame\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::startGame()"},
	{ "trigger": "isPrematchRequirementConditionMet\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::isPrematchRequirementConditionMet(${1:activeTeamCount})"},
	{ "trigger": "waitForPlayers\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::waitForPlayers()"},
	{ "trigger": "prematchWaitingForPlayers\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::prematchWaitingForPlayers()"},
	{ "trigger": "prematchPeriod\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::prematchPeriod()"},
	{ "trigger": "gracePeriod\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::gracePeriod()"},
	{ "trigger": "watchMatchEndingSoon\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::watchMatchEndingSoon()"},
	{ "trigger": "assertTeamVariables\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::assertTeamVariables()"},
	{ "trigger": "anyTeamHasWaveDelay\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::anyTeamHasWaveDelay()"},
	{ "trigger": "Callback_StartGameType\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::Callback_StartGameType()"},
	{ "trigger": "registerFriendlyFireDelay\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::registerFriendlyFireDelay(${1:dvarString}, ${2:defaultValue}, ${3:minValue}, ${4:maxValue})"},
	{ "trigger": "checkRoundSwitch\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::checkRoundSwitch()"},
	{ "trigger": "listenForGameEnd\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::listenForGameEnd()"},
	{ "trigger": "getKillStreaks\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::getKillStreaks(${1:player})"},
	{ "trigger": "updateRankedMatch\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::updateRankedMatch(${1:winner})"},
	{ "trigger": "annihilatorGunPlayerKillEffect\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::annihilatorGunPlayerKillEffect(${1:attacker}, ${2:weapon})"},
	{ "trigger": "annihilatorGunActorKillEffect\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::annihilatorGunActorKillEffect(${1:attacker}, ${2:weapon})"},
	{ "trigger": "pineappleGunPlayerKillEffect\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::pineappleGunPlayerKillEffect(${1:attacker})"},
	{ "trigger": "BowPlayerKillEffect\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::BowPlayerKillEffect()"},
	{ "trigger": "pineappleGunActorKillEffect\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::pineappleGunActorKillEffect()"},
	{ "trigger": "shake_and_rumble\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::shake_and_rumble(${1:n_delay}, ${2:shake_size}, ${3:shake_time}, ${4:rumble_num})"},
	{ "trigger": "DoWeaponSpecificKillEffects\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::DoWeaponSpecificKillEffects(${1:eInflictor}, ${2:attacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime})"},
	{ "trigger": "DoWeaponSpecificCorpseEffects\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::DoWeaponSpecificCorpseEffects(${1:body}, ${2:eInflictor}, ${3:attacker}, ${4:iDamage}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vDir}, ${8:sHitLoc}, ${9:psOffsetTime})"},
	{ "trigger": "BurnCorpse\t#using scripts\\mp\\gametypes\\_globallogic;", "contents": "globallogic::BurnCorpse()"},
	{ "trigger": "scoreEventTableLookupInt\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::scoreEventTableLookupInt(${1:index}, ${2:scoreEventColumn})"},
	{ "trigger": "scoreEventTableLookup\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::scoreEventTableLookup(${1:index}, ${2:scoreEventColumn})"},
	{ "trigger": "registerScoreEventCallback\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::registerScoreEventCallback(${1:callback}, ${2:func})"},
	{ "trigger": "scoreEventPlayerKill\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::scoreEventPlayerKill(${1:data}, ${2:time})"},
	{ "trigger": "get_equipped_hero_ability\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::get_equipped_hero_ability(${1:ability_name})"},
	{ "trigger": "heroWeaponKill\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::heroWeaponKill(${1:attacker}, ${2:victim}, ${3:weapon})"},
	{ "trigger": "killedHeroWeaponEnemy\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::killedHeroWeaponEnemy(${1:attacker}, ${2:victim}, ${3:weapon}, ${4:victim_weapon}, ${5:victim_gadget_power}, ${6:victimGadgetWasActiveLastDamage})"},
	{ "trigger": "specificWeaponKill\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::specificWeaponKill(${1:attacker}, ${2:victim}, ${3:weapon}, ${4:killstreak}, ${5:inflictor})"},
	{ "trigger": "multiKill\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::multiKill(${1:killCount}, ${2:weapon})"},
	{ "trigger": "multiHeroAbilityKill\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::multiHeroAbilityKill(${1:killCount}, ${2:weapon})"},
	{ "trigger": "is_weapon_valid\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::is_weapon_valid(${1:meansOfDeath}, ${2:weapon}, ${3:weaponClass}, ${4:killstreak})"},
	{ "trigger": "updateSingleFragMultiKill\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::updateSingleFragMultiKill(${1:victim}, ${2:weapon}, ${3:weaponClass}, ${4:killstreak})"},
	{ "trigger": "updatemultikills\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::updatemultikills(${1:weapon}, ${2:weaponClass}, ${3:killstreak}, ${4:victim})"},
	{ "trigger": "resetRecentKillVariables\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::resetRecentKillVariables()"},
	{ "trigger": "waitTillTimeoutOrDeath\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::waitTillTimeoutOrDeath(${1:timeout})"},
	{ "trigger": "updateoneshotmultikills\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::updateoneshotmultikills(${1:victim}, ${2:weapon}, ${3:firstTimeDamaged})"},
	{ "trigger": "get_distance_for_weapon\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::get_distance_for_weapon(${1:weapon}, ${2:weaponClass})"},
	{ "trigger": "onGameEnd\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::onGameEnd(${1:data})"},
	{ "trigger": "specialistMedalAchievement\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::specialistMedalAchievement()"},
	{ "trigger": "specialistStatAbilityUsage\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::specialistStatAbilityUsage(${1:usageSingleGame}, ${2:multiTrackPerLife})"},
	{ "trigger": "multikillMedalAchievement\t#using scripts\\mp\\_scoreevents;", "contents": "scoreevents::multikillMedalAchievement()"},
	{ "trigger": "finalizeCrateCategory\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::finalizeCrateCategory(${1:category})"},
	{ "trigger": "advancedFinalizeCrateCategory\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::advancedFinalizeCrateCategory(${1:category})"},
	{ "trigger": "setCategoryTypeWeight\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::setCategoryTypeWeight(${1:category}, ${2:type}, ${3:weight})"},
	{ "trigger": "registerCrateType\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::registerCrateType(${1:category}, ${2:type}, ${3:name}, ${4:weight}, ${5:hint}, ${6:hint_gambler}, ${7:giveFunction}, ${8:landFunctionOverride})"},
	{ "trigger": "getRandomCrateType\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::getRandomCrateType(${1:category}, ${2:gambler_crate_name})"},
	{ "trigger": "giveCrateItem\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::giveCrateItem(${1:crate})"},
	{ "trigger": "giveCrateKillstreakWaiter\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::giveCrateKillstreakWaiter(${1:event}, ${2:removeCrate}, ${3:extraEndon})"},
	{ "trigger": "giveCrateKillstreak\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::giveCrateKillstreak(${1:killstreak})"},
	{ "trigger": "giveSpecializedCrateWeapon\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::giveSpecializedCrateWeapon(${1:weapon})"},
	{ "trigger": "giveCrateWeapon\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::giveCrateWeapon(${1:weapon_name})"},
	{ "trigger": "useSupplyDropMarker\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::useSupplyDropMarker(${1:package_contents_id}, ${2:context})"},
	{ "trigger": "isSupplyDropGrenadeAllowed\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::isSupplyDropGrenadeAllowed(${1:killstreak})"},
	{ "trigger": "AddDropLocation\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::AddDropLocation(${1:killstreak_id}, ${2:location})"},
	{ "trigger": "DelDropLocation\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::DelDropLocation(${1:killstreak_id})"},
	{ "trigger": "IsLocationGood\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::IsLocationGood(${1:location}, ${2:context})"},
	{ "trigger": "useKillstreakSupplyDrop\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::useKillstreakSupplyDrop(${1:killstreak})"},
	{ "trigger": "use_killstreak_death_machine\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::use_killstreak_death_machine(${1:killstreak})"},
	{ "trigger": "use_killstreak_grim_reaper\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::use_killstreak_grim_reaper(${1:killstreak})"},
	{ "trigger": "use_killstreak_tv_guided_missile\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::use_killstreak_tv_guided_missile(${1:killstreak})"},
	{ "trigger": "use_killstreak_mp40\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::use_killstreak_mp40(${1:killstreak})"},
	{ "trigger": "cleanUpWatcherOnDeath\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::cleanUpWatcherOnDeath(${1:team}, ${2:killstreak_id})"},
	{ "trigger": "cleanup\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::cleanup(${1:context}, ${2:player})"},
	{ "trigger": "MarkerUpdateThread\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::MarkerUpdateThread(${1:context})"},
	{ "trigger": "supplyDropWatcher\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::supplyDropWatcher(${1:package_contents_id}, ${2:trigger_event}, ${3:supplyDropWeapon}, ${4:context})"},
	{ "trigger": "checkForEmp\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::checkForEmp()"},
	{ "trigger": "supplyDropGrenadeTimeout\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::supplyDropGrenadeTimeout(${1:team}, ${2:killstreak_id}, ${3:weapon})"},
	{ "trigger": "checkWeaponChange\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::checkWeaponChange(${1:team}, ${2:killstreak_id})"},
	{ "trigger": "supplyDropGrenadePullWatcher\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::supplyDropGrenadePullWatcher(${1:killstreak_id})"},
	{ "trigger": "watchForGrenadePutDown\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::watchForGrenadePutDown()"},
	{ "trigger": "playerChangeWeaponWaiter\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::playerChangeWeaponWaiter()"},
	{ "trigger": "getIconForCrate\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::getIconForCrate()"},
	{ "trigger": "crateActivate\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::crateActivate(${1:hacker})"},
	{ "trigger": "setRicochetProtectionEndTime\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::setRicochetProtectionEndTime(${1:killstreak}, ${2:killstreak_id}, ${3:owner})"},
	{ "trigger": "crateDeactivate\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::crateDeactivate()"},
	{ "trigger": "ownerTeamChangeWatcher\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::ownerTeamChangeWatcher()"},
	{ "trigger": "dropAllToGround\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::dropAllToGround(${1:origin}, ${2:radius}, ${3:stickyObjectRadius})"},
	{ "trigger": "dropEverythingTouchingCrate\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::dropEverythingTouchingCrate(${1:origin})"},
	{ "trigger": "dropAllToGroundAfterCrateDelete\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::dropAllToGroundAfterCrateDelete(${1:crate}, ${2:crate_origin})"},
	{ "trigger": "dropCratesToGround\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::dropCratesToGround(${1:origin}, ${2:radius})"},
	{ "trigger": "dropCrateToGround\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::dropCrateToGround()"},
	{ "trigger": "ConfigureTeamPost\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::ConfigureTeamPost(${1:owner})"},
	{ "trigger": "crateSpawn\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::crateSpawn(${1:killstreak}, ${2:killstreakId}, ${3:owner}, ${4:team}, ${5:drop_origin}, ${6:drop_angle})"},
	{ "trigger": "crateDelete\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::crateDelete(${1:drop_all_to_ground})"},
	{ "trigger": "stationaryCrateOverride\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::stationaryCrateOverride()"},
	{ "trigger": "timeoutCrateWaiter\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::timeoutCrateWaiter()"},
	{ "trigger": "cratePhysics\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::cratePhysics()"},
	{ "trigger": "get_height\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::get_height(${1:e_ignore})"},
	{ "trigger": "crateControlledDrop\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::crateControlledDrop(${1:killstreak}, ${2:v_target_location})"},
	{ "trigger": "play_impact_sound\t#using scripts\\mp\\killstreaks\\_supplydrop; self == crate", "contents": "supplydrop::play_impact_sound()"},
	{ "trigger": "update_crate_velocity\t#using scripts\\mp\\killstreaks\\_supplydrop; self == crate", "contents": "supplydrop::update_crate_velocity()"},
	{ "trigger": "crateRedoPhysics\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::crateRedoPhysics()"},
	{ "trigger": "do_supply_drop_detonation\t#using scripts\\mp\\killstreaks\\_supplydrop; self == weapon_instance", "contents": "supplydrop::do_supply_drop_detonation(${1:weapon}, ${2:owner})"},
	{ "trigger": "doSupplyDrop\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::doSupplyDrop(${1:weapon_instance}, ${2:weapon}, ${3:owner}, ${4:killstreak_id}, ${5:package_contents_id}, ${6:context})"},
	{ "trigger": "watchExplode\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::watchExplode(${1:weapon}, ${2:owner}, ${3:killstreak_id}, ${4:package_contents_id})"},
	{ "trigger": "crateTimeOutThreader\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::crateTimeOutThreader()"},
	{ "trigger": "crateTimeOut\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::crateTimeOut(${1:time})"},
	{ "trigger": "deleteOnOwnerleave\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::deleteOnOwnerleave()"},
	{ "trigger": "WaitAndDelete\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::WaitAndDelete(${1:time})"},
	{ "trigger": "dropCrate\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::dropCrate(${1:origin}, ${2:angle}, ${3:killstreak}, ${4:owner}, ${5:team}, ${6:killcamEnt}, ${7:killstreak_id}, ${8:package_contents_id}, ${9:crate_}, ${10:context})"},
	{ "trigger": "unlinkOnRotation\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::unlinkOnRotation(${1:crate})"},
	{ "trigger": "default_land_function\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::default_land_function(${1:crate}, ${2:category}, ${3:owner}, ${4:team})"},
	{ "trigger": "spawn_explosive_crate\t#using scripts\\mp\\killstreaks\\_supplydrop; self == crate", "contents": "supplydrop::spawn_explosive_crate(${1:origin}, ${2:angle}, ${3:killstreak}, ${4:owner}, ${5:team}, ${6:hacker}, ${7:playerHasEngineerPerk})"},
	{ "trigger": "watch_explosive_crate\t#using scripts\\mp\\killstreaks\\_supplydrop; self == crate", "contents": "supplydrop::watch_explosive_crate()"},
	{ "trigger": "loop_sound\t#using scripts\\mp\\killstreaks\\_supplydrop; self == crate", "contents": "supplydrop::loop_sound(${1:alias}, ${2:interval})"},
	{ "trigger": "WatchForCrateKill\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::WatchForCrateKill(${1:start_kill_watch_z_threshold})"},
	{ "trigger": "crateKill\t#using scripts\\mp\\killstreaks\\_supplydrop; self == crate", "contents": "supplydrop::crateKill()"},
	{ "trigger": "crateDropToGroundKill\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::crateDropToGroundKill()"},
	{ "trigger": "crateDropToGroundTrace\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::crateDropToGroundTrace(${1:start})"},
	{ "trigger": "is_touching_crate\t#using scripts\\mp\\killstreaks\\_supplydrop; self == crate", "contents": "supplydrop::is_touching_crate()"},
	{ "trigger": "is_clone_touching_crate\t#using scripts\\mp\\killstreaks\\_supplydrop; self == crate", "contents": "supplydrop::is_clone_touching_crate()"},
	{ "trigger": "is_equipment_touching_crate\t#using scripts\\mp\\killstreaks\\_supplydrop; self == crate, player is passed to access their equipment", "contents": "supplydrop::is_equipment_touching_crate(${1:player})"},
	{ "trigger": "spawnUseEnt\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::spawnUseEnt()"},
	{ "trigger": "useEntOwnerDeathWaiter\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::useEntOwnerDeathWaiter(${1:owner})"},
	{ "trigger": "crateUseThink\t#using scripts\\mp\\killstreaks\\_supplydrop; self == crate", "contents": "supplydrop::crateUseThink()"},
	{ "trigger": "crateUseThinkOwner\t#using scripts\\mp\\killstreaks\\_supplydrop; self == crate", "contents": "supplydrop::crateUseThinkOwner()"},
	{ "trigger": "useHoldThink\t#using scripts\\mp\\killstreaks\\_supplydrop; self == a script origin (useEnt) or the crate", "contents": "supplydrop::useHoldThink(${1:player}, ${2:useTime})"},
	{ "trigger": "continueHoldThinkLoop\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::continueHoldThinkLoop(${1:player})"},
	{ "trigger": "useHoldThinkLoop\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::useHoldThinkLoop(${1:player})"},
	{ "trigger": "crateGamblerThink\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::crateGamblerThink()"},
	{ "trigger": "crateReactivate\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::crateReactivate()"},
	{ "trigger": "personalUseBar\t#using scripts\\mp\\killstreaks\\_supplydrop; self == player, object == a script origin (useEnt) or the crate", "contents": "supplydrop::personalUseBar(${1:object})"},
	{ "trigger": "spawn_helicopter\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::spawn_helicopter(${1:owner}, ${2:team}, ${3:origin}, ${4:angles}, ${5:model}, ${6:targetname}, ${7:killstreak_id}, ${8:context})"},
	{ "trigger": "getDropHeight\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::getDropHeight(${1:origin})"},
	{ "trigger": "getDropDirection\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::getDropDirection()"},
	{ "trigger": "getNextDropDirection\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::getNextDropDirection(${1:drop_direction}, ${2:degrees})"},
	{ "trigger": "getHeliStart\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::getHeliStart(${1:drop_origin}, ${2:drop_direction})"},
	{ "trigger": "getHeliEnd\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::getHeliEnd(${1:drop_origin}, ${2:drop_direction})"},
	{ "trigger": "addOffsetOntoPoint\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::addOffsetOntoPoint(${1:point}, ${2:direction}, ${3:offset})"},
	{ "trigger": "supplyDropHeliStartPath_v2_setup\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::supplyDropHeliStartPath_v2_setup(${1:goal}, ${2:goal_offset})"},
	{ "trigger": "supplyDropHeliStartPath_v2_part2_local\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::supplyDropHeliStartPath_v2_part2_local(${1:goal}, ${2:goalPath}, ${3:goal_local_offset})"},
	{ "trigger": "supplyDropHeliStartPath_v2_part2\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::supplyDropHeliStartPath_v2_part2(${1:goal}, ${2:goalPath}, ${3:goal_world_offset})"},
	{ "trigger": "supplyDropHeliStartPath\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::supplyDropHeliStartPath(${1:goal}, ${2:goal_offset})"},
	{ "trigger": "supplyDropHeliEndPath_v2\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::supplyDropHeliEndPath_v2(${1:start})"},
	{ "trigger": "supplyDropHeliEndPath\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::supplyDropHeliEndPath(${1:origin}, ${2:drop_direction})"},
	{ "trigger": "incCrateKillstreakUsageStat\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::incCrateKillstreakUsageStat(${1:weapon}, ${2:killstreak_id})"},
	{ "trigger": "MarkerCleanupThread\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::MarkerCleanupThread(${1:context})"},
	{ "trigger": "GetChopperDropPoint\t#using scripts\\mp\\killstreaks\\_supplydrop; self = chopper", "contents": "supplydrop::GetChopperDropPoint(${1:context})"},
	{ "trigger": "heliDeliverCrate\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::heliDeliverCrate(${1:origin}, ${2:weapon}, ${3:owner}, ${4:team}, ${5:killstreak_id}, ${6:package_contents_id}, ${7:context})"},
	{ "trigger": "SAMTurretWatcher\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::SAMTurretWatcher(${1:destination})"},
	{ "trigger": "speedRegulator\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::speedRegulator(${1:goal})"},
	{ "trigger": "heliDropCrate\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::heliDropCrate(${1:killstreak}, ${2:originalOwner}, ${3:offset}, ${4:killCamEnt}, ${5:killstreak_id}, ${6:package_contents_id}, ${7:context})"},
	{ "trigger": "heliDestroyed\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::heliDestroyed()"},
	{ "trigger": "lbExplode\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::lbExplode()"},
	{ "trigger": "lbSpin\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::lbSpin(${1:speed})"},
	{ "trigger": "refCountDecChopper\t#using scripts\\mp\\killstreaks\\_supplydrop;", "contents": "supplydrop::refCountDecChopper(${1:team}, ${2:killstreak_id})"},
	{ "trigger": "killstreakTargetSet\t#using scripts\\mp\\killstreaks\\_killstreak_detect;", "contents": "killstreak_detect::killstreakTargetSet(${1:killstreakEntity}, ${2:offset})"},
	{ "trigger": "killstreakTargetClear\t#using scripts\\mp\\killstreaks\\_killstreak_detect;", "contents": "killstreak_detect::killstreakTargetClear(${1:killstreakEntity})"},
	{ "trigger": "link_traversals\t#using scripts\\mp\\mp_combine;", "contents": "mp_combine::link_traversals(${1:str_value}, ${2:str_key}, ${3:b_enable})"},
	{ "trigger": "precache\t#using scripts\\mp\\mp_combine;", "contents": "mp_combine::precache()"},
	{ "trigger": "add_raps_omit_locations\t#using scripts\\mp\\mp_combine;", "contents": "mp_combine::add_raps_omit_locations(${1:&omit_locations})"},
	{ "trigger": "add_raps_drop_locations\t#using scripts\\mp\\mp_combine;", "contents": "mp_combine::add_raps_drop_locations(${1:&drop_candidate_array})"},
	{ "trigger": "spawnKillTrigger\t#using scripts\\mp\\mp_combine;", "contents": "mp_combine::spawnKillTrigger()"},
	{ "trigger": "watchKillTrigger\t#using scripts\\mp\\mp_combine;", "contents": "mp_combine::watchKillTrigger()"},
	{ "trigger": "InitRCBomb\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::InitRCBomb()"},
	{ "trigger": "waitRemoteControl\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::waitRemoteControl()"},
	{ "trigger": "toggleLightsOnAfterTime\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::toggleLightsOnAfterTime(${1:time})"},
	{ "trigger": "HackedPreFunction\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::HackedPreFunction(${1:hacker})"},
	{ "trigger": "HackedPostFunction\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::HackedPostFunction(${1:hacker})"},
	{ "trigger": "ConfigureTeamPost\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::ConfigureTeamPost(${1:owner}, ${2:isHacked})"},
	{ "trigger": "ActivateRCBomb\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::ActivateRCBomb(${1:hardpointType})"},
	{ "trigger": "rcbomb_hacked_health_update\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::rcbomb_hacked_health_update(${1:hacker})"},
	{ "trigger": "StartRemoteControl\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::StartRemoteControl(${1:rcbomb})"},
	{ "trigger": "EndRemoteControl\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::EndRemoteControl(${1:rcbomb}, ${2:exitRequestedByOwner})"},
	{ "trigger": "WatchDetonation\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::WatchDetonation()"},
	{ "trigger": "WatchWater\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::WatchWater()"},
	{ "trigger": "WatchOwnerGameEvents\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::WatchOwnerGameEvents()"},
	{ "trigger": "WatchTimeout\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::WatchTimeout()"},
	{ "trigger": "rc_shutdown\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::rc_shutdown()"},
	{ "trigger": "WatchShutdown\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::WatchShutdown()"},
	{ "trigger": "WatchHurtTriggers\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::WatchHurtTriggers()"},
	{ "trigger": "OnDamage\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::OnDamage(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:vDamageOrigin}, ${11:psOffsetTime}, ${12:damageFromUnderneath}, ${13:modelIndex}, ${14:partName}, ${15:vSurfaceNormal})"},
	{ "trigger": "OnDeath\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::OnDeath(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime})"},
	{ "trigger": "WatchGameEnded\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::WatchGameEnded()"},
	{ "trigger": "HideAfterWait\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::HideAfterWait(${1:waitTime})"},
	{ "trigger": "Explode\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::Explode(${1:attacker}, ${2:weapon})"},
	{ "trigger": "RCCarAllowFriendlyFireDamage\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::RCCarAllowFriendlyFireDamage(${1:eInflictor}, ${2:eAttacker}, ${3:sMeansOfDeath}, ${4:weapon})"},
	{ "trigger": "GetPlacementStartHeight\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::GetPlacementStartHeight()"},
	{ "trigger": "CalculateSpawnOrigin\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::CalculateSpawnOrigin(${1:origin}, ${2:angles})"},
	{ "trigger": "TestWheelLocations\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::TestWheelLocations(${1:origin}, ${2:angles}, ${3:heightoffset})"},
	{ "trigger": "TestSpawnOrigin\t#using scripts\\mp\\killstreaks\\_rcbomb;", "contents": "rcbomb::TestSpawnOrigin(${1:origin}, ${2:angles})"},
	{ "trigger": "error\t#using scripts\\mp\\_util;", "contents": "util::error(${1:msg})"},
	{ "trigger": "warning\t#using scripts\\mp\\_util;", "contents": "util::warning(${1:msg})"},
	{ "trigger": "within_fov\t#using scripts\\mp\\_util;", "contents": "util::within_fov(${1:start_origin}, ${2:start_angles}, ${3:end_origin}, ${4:fov})"},
	{ "trigger": "get_player_height\t#using scripts\\mp\\_util;", "contents": "util::get_player_height()"},
	{ "trigger": "IsBulletImpactMOD\t#using scripts\\mp\\_util;", "contents": "util::IsBulletImpactMOD(${1:sMeansOfDeath})"},
	{ "trigger": "waitRespawnButton\t#using scripts\\mp\\_util;", "contents": "util::waitRespawnButton()"},
	{ "trigger": "setLowerMessage\t#using scripts\\mp\\_util;", "contents": "util::setLowerMessage(${1:text}, ${2:time}, ${3:combineMessageAndTimer})"},
	{ "trigger": "setLowerMessageValue\t#using scripts\\mp\\_util;", "contents": "util::setLowerMessageValue(${1:text}, ${2:value}, ${3:combineMessage})"},
	{ "trigger": "clearLowerMessage\t#using scripts\\mp\\_util;", "contents": "util::clearLowerMessage(${1:fadetime})"},
	{ "trigger": "printOnTeam\t#using scripts\\mp\\_util;", "contents": "util::printOnTeam(${1:text}, ${2:team})"},
	{ "trigger": "printBoldOnTeam\t#using scripts\\mp\\_util;", "contents": "util::printBoldOnTeam(${1:text}, ${2:team})"},
	{ "trigger": "printBoldOnTeamArg\t#using scripts\\mp\\_util;", "contents": "util::printBoldOnTeamArg(${1:text}, ${2:team}, ${3:arg})"},
	{ "trigger": "printOnTeamArg\t#using scripts\\mp\\_util;", "contents": "util::printOnTeamArg(${1:text}, ${2:team}, ${3:arg})"},
	{ "trigger": "printOnPlayers\t#using scripts\\mp\\_util;", "contents": "util::printOnPlayers(${1:text}, ${2:team})"},
	{ "trigger": "printAndSoundOnEveryone\t#using scripts\\mp\\_util;", "contents": "util::printAndSoundOnEveryone(${1:team}, ${2:enemyteam}, ${3:printFriendly}, ${4:printEnemy}, ${5:soundFriendly}, ${6:soundEnemy}, ${7:printarg})"},
	{ "trigger": "_playLocalSound\t#using scripts\\mp\\_util;", "contents": "util::_playLocalSound(${1:soundAlias})"},
	{ "trigger": "getOtherTeam\t#using scripts\\mp\\_util;", "contents": "util::getOtherTeam(${1:team})"},
	{ "trigger": "getTeamMask\t#using scripts\\mp\\_util;", "contents": "util::getTeamMask(${1:team})"},
	{ "trigger": "getOtherTeamsMask\t#using scripts\\mp\\_util;", "contents": "util::getOtherTeamsMask(${1:skip_team})"},
	{ "trigger": "wait_endon\t#using scripts\\mp\\_util;", "contents": "util::wait_endon(${1:waitTime}, ${2:endOnString}, ${3:endonString2}, ${4:endonString3}, ${5:endonString4})"},
	{ "trigger": "plot_points\t#using scripts\\mp\\_util;", "contents": "util::plot_points(${1:plotpoints}, ${2:r}, ${3:g}, ${4:b}, ${5:timer})"},
	{ "trigger": "getfx\t#using scripts\\mp\\_util;", "contents": "util::getfx(${1:fx})"},
	{ "trigger": "set_dvar_if_unset\t#using scripts\\mp\\_util;", "contents": "util::set_dvar_if_unset()"},
	{ "trigger": "set_dvar_float_if_unset\t#using scripts\\mp\\_util;", "contents": "util::set_dvar_float_if_unset()"},
	{ "trigger": "set_dvar_int_if_unset\t#using scripts\\mp\\_util;", "contents": "util::set_dvar_int_if_unset()"},
	{ "trigger": "add_trigger_to_ent\t#using scripts\\mp\\_util; Self == The trigger volume", "contents": "util::add_trigger_to_ent(${1:ent})"},
	{ "trigger": "remove_trigger_from_ent\t#using scripts\\mp\\_util; Self == The trigger volume.", "contents": "util::remove_trigger_from_ent(${1:ent})"},
	{ "trigger": "ent_already_in_trigger\t#using scripts\\mp\\_util; Self == The entity in the trigger volume.", "contents": "util::ent_already_in_trigger(${1:trig})"},
	{ "trigger": "trigger_thread_death_monitor\t#using scripts\\mp\\_util;", "contents": "util::trigger_thread_death_monitor(${1:ent}, ${2:ender})"},
	{ "trigger": "trigger_thread\t#using scripts\\mp\\_util; Self == The trigger.", "contents": "util::trigger_thread(${1:ent}, ${2:on_enter_payload}, ${3:on_exit_payload})"},
	{ "trigger": "isStrStart\t#using scripts\\mp\\_util;", "contents": "util::isStrStart(${1:string1}, ${2:subStr})"},
	{ "trigger": "isKillStreaksEnabled\t#using scripts\\mp\\_util;", "contents": "util::isKillStreaksEnabled()"},
	{ "trigger": "setUsingRemote\t#using scripts\\mp\\_util;", "contents": "util::setUsingRemote(${1:remoteName}, ${2:set_killstreak_delay_killcam = true})"},
	{ "trigger": "setObjectiveText\t#using scripts\\mp\\_util;", "contents": "util::setObjectiveText(${1:team}, ${2:text})"},
	{ "trigger": "setObjectiveScoreText\t#using scripts\\mp\\_util;", "contents": "util::setObjectiveScoreText(${1:team}, ${2:text})"},
	{ "trigger": "setObjectiveHintText\t#using scripts\\mp\\_util;", "contents": "util::setObjectiveHintText(${1:team}, ${2:text})"},
	{ "trigger": "getObjectiveText\t#using scripts\\mp\\_util;", "contents": "util::getObjectiveText(${1:team})"},
	{ "trigger": "getObjectiveScoreText\t#using scripts\\mp\\_util;", "contents": "util::getObjectiveScoreText(${1:team})"},
	{ "trigger": "getObjectiveHintText\t#using scripts\\mp\\_util;", "contents": "util::getObjectiveHintText(${1:team})"},
	{ "trigger": "registerRoundSwitch\t#using scripts\\mp\\_util;", "contents": "util::registerRoundSwitch(${1:minValue}, ${2:maxValue})"},
	{ "trigger": "registerRoundLimit\t#using scripts\\mp\\_util;", "contents": "util::registerRoundLimit(${1:minValue}, ${2:maxValue})"},
	{ "trigger": "registerRoundWinLimit\t#using scripts\\mp\\_util;", "contents": "util::registerRoundWinLimit(${1:minValue}, ${2:maxValue})"},
	{ "trigger": "registerScoreLimit\t#using scripts\\mp\\_util;", "contents": "util::registerScoreLimit(${1:minValue}, ${2:maxValue})"},
	{ "trigger": "registerRoundScoreLimit\t#using scripts\\mp\\_util;", "contents": "util::registerRoundScoreLimit(${1:minValue}, ${2:maxValue})"},
	{ "trigger": "registerTimeLimit\t#using scripts\\mp\\_util;", "contents": "util::registerTimeLimit(${1:minValue}, ${2:maxValue})"},
	{ "trigger": "registerNumLives\t#using scripts\\mp\\_util;", "contents": "util::registerNumLives(${1:minValue}, ${2:maxValue}, ${3:teamLivesMinValue}, ${4:teamLivesMaxValue})"},
	{ "trigger": "getPlayerFromClientNum\t#using scripts\\mp\\_util;", "contents": "util::getPlayerFromClientNum(${1:clientNum})"},
	{ "trigger": "isPressBuild\t#using scripts\\mp\\_util;", "contents": "util::isPressBuild()"},
	{ "trigger": "isFlashbanged\t#using scripts\\mp\\_util;", "contents": "util::isFlashbanged()"},
	{ "trigger": "DoMaxDamage\t#using scripts\\mp\\_util; self == entity to damage", "contents": "util::DoMaxDamage(${1:origin}, ${2:attacker}, ${3:inflictor}, ${4:headshot}, ${5:mod})"},
	{ "trigger": "self_delete\t#using scripts\\mp\\_util;", "contents": "util::self_delete()"},
	{ "trigger": "screen_message_create\t#using scripts\\mp\\_util;", "contents": "util::screen_message_create(${1:string_message_1}, ${2:string_message_2}, ${3:string_message_3}, ${4:n_offset_y}, ${5:n_time})"},
	{ "trigger": "screen_message_delete\t#using scripts\\mp\\_util;", "contents": "util::screen_message_delete(${1:delay})"},
	{ "trigger": "ghost_wait_show\t#using scripts\\mp\\_util;", "contents": "util::ghost_wait_show(${1:wait_time = 0.1})"},
	{ "trigger": "ghost_wait_show_to_player\t#using scripts\\mp\\_util;", "contents": "util::ghost_wait_show_to_player(${1:player}, ${2:wait_time = 0.1}, ${3:self_endon_string1})"},
	{ "trigger": "ghost_wait_show_to_others\t#using scripts\\mp\\_util;", "contents": "util::ghost_wait_show_to_others(${1:player}, ${2:wait_time = 0.1}, ${3:self_endon_string1})"},
	{ "trigger": "use_button_pressed\t#using scripts\\mp\\_util;", "contents": "util::use_button_pressed()"},
	{ "trigger": "waittill_use_button_pressed\t#using scripts\\mp\\_util;", "contents": "util::waittill_use_button_pressed()"},
	{ "trigger": "show_hint_text\t#using scripts\\mp\\_util;", "contents": "util::show_hint_text(${1:str_text_to_show}, ${2:b_should_blink=false}, ${3:str_turn_off_notify=HINT_TEXT_TURN_OFF_NOTIFY}, ${4:n_display_time=HINT_TEXT_DISPLAY_TIME_DEFAULT})"},
	{ "trigger": "hide_hint_text\t#using scripts\\mp\\_util;", "contents": "util::hide_hint_text(${1:b_fade_before_hiding=true})"},
	{ "trigger": "fade_hint_text_after_time\t#using scripts\\mp\\_util;", "contents": "util::fade_hint_text_after_time(${1:n_display_time}, ${2:str_turn_off_notify})"},
	{ "trigger": "hide_hint_text_listener\t#using scripts\\mp\\_util;", "contents": "util::hide_hint_text_listener(${1:n_time})"},
	{ "trigger": "set_team_radar\t#using scripts\\mp\\_util;", "contents": "util::set_team_radar(${1:team}, ${2:value})"},
	{ "trigger": "register_player_contract_event\t#using scripts\\mp\\_util;", "contents": "util::register_player_contract_event(${1:event_name}, ${2:event_func}, ${3:max_param_count = 0})"},
	{ "trigger": "player_contract_event\t#using scripts\\mp\\_util;", "contents": "util::player_contract_event(${1:event_name}, ${2:param1 = undefined}, ${3:param2 = undefined}, ${4:param3 = undefined})"},
	{ "trigger": "is_objective_game\t#using scripts\\mp\\_util;", "contents": "util::is_objective_game(${1:game_type})"},
	{ "trigger": "in_whitelist\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::in_whitelist(${1:itemName})"},
	{ "trigger": "build_classes\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::build_classes()"},
	{ "trigger": "pick_item\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::pick_item(${1:&pickedItems}, ${2:items})"},
	{ "trigger": "pick_classes\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::pick_classes()"},
	{ "trigger": "get_current_class\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::get_current_class()"},
	{ "trigger": "pick_hero_gadget\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::pick_hero_gadget()"},
	{ "trigger": "pick_hero_weapon\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::pick_hero_weapon()"},
	{ "trigger": "pick_hero_ability\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::pick_hero_ability()"},
	{ "trigger": "pick_killstreaks\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::pick_killstreaks()"},
	{ "trigger": "get_available_items\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::get_available_items(${1:filterGroup}, ${2:filterSlot})"},
	{ "trigger": "get_item_name\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::get_item_name(${1:itemReference})"},
	{ "trigger": "on_bot_connect\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::on_bot_connect()"},
	{ "trigger": "construct_loadout\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::construct_loadout(${1:allocation_max})"},
	{ "trigger": "construct_class\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::construct_class(${1:constructclass}, ${2:items}, ${3:allocation_max})"},
	{ "trigger": "make_choice\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::make_choice(${1:chance}, ${2:claimed}, ${3:max_claim})"},
	{ "trigger": "chose_action\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::chose_action(${1:action1}, ${2:chance1}, ${3:action2}, ${4:chance2}, ${5:action3}, ${6:chance3}, ${7:action4}, ${8:chance4})"},
	{ "trigger": "item_is_claimed\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::item_is_claimed(${1:item})"},
	{ "trigger": "choose_weapon\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::choose_weapon(${1:weaponclass}, ${2:items})"},
	{ "trigger": "build_weapon_options_list\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::build_weapon_options_list(${1:optionType})"},
	{ "trigger": "choose_weapon_option\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::choose_weapon_option(${1:weaponclass}, ${2:optionType}, ${3:primary})"},
	{ "trigger": "choose_primary_attachments\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::choose_primary_attachments(${1:weaponclass}, ${2:weapon}, ${3:allocation}, ${4:allocation_max})"},
	{ "trigger": "choose_secondary_attachments\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::choose_secondary_attachments(${1:weaponclass}, ${2:weapon}, ${3:allocation}, ${4:allocation_max})"},
	{ "trigger": "build_item_list\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::build_item_list()"},
	{ "trigger": "item_is_banned\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::item_is_banned(${1:slot}, ${2:item})"},
	{ "trigger": "build_claimed_list\t#using scripts\\mp\\bots\\_bot_loadout;", "contents": "bot_loadout::build_claimed_list(${1:items})"},
	{ "trigger": "precache\t#using scripts\\mp\\teams\\_teamset_multiteam;", "contents": "_teamset_multiteam::precache()"},
	{ "trigger": "onStartGameType\t#using scripts\\mp\\gametypes\\tdm;", "contents": "tdm::onStartGameType()"},
	{ "trigger": "onSpawnPlayer\t#using scripts\\mp\\gametypes\\tdm; self == player", "contents": "tdm::onSpawnPlayer(${1:predictedSpawn})"},
	{ "trigger": "onEndGame\t#using scripts\\mp\\gametypes\\tdm;", "contents": "tdm::onEndGame(${1:winningTeam})"},
	{ "trigger": "onRoundSwitch\t#using scripts\\mp\\gametypes\\tdm;", "contents": "tdm::onRoundSwitch()"},
	{ "trigger": "onRoundEndGame\t#using scripts\\mp\\gametypes\\tdm;", "contents": "tdm::onRoundEndGame(${1:roundWinner})"},
	{ "trigger": "onScoreCloseMusic\t#using scripts\\mp\\gametypes\\tdm;", "contents": "tdm::onScoreCloseMusic()"},
	{ "trigger": "onPlayerKilled\t#using scripts\\mp\\gametypes\\tdm;", "contents": "tdm::onPlayerKilled(${1:eInflictor}, ${2:attacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime}, ${9:deathAnimDuration})"},
	{ "trigger": "on_player_connect\t#using scripts\\mp\\gametypes\\_deathicons;", "contents": "deathicons::on_player_connect()"},
	{ "trigger": "update_enabled\t#using scripts\\mp\\gametypes\\_deathicons;", "contents": "deathicons::update_enabled()"},
	{ "trigger": "add\t#using scripts\\mp\\gametypes\\_deathicons;", "contents": "deathicons::add(${1:entity}, ${2:dyingplayer}, ${3:team}, ${4:timeout})"},
	{ "trigger": "destroy_slowly\t#using scripts\\mp\\gametypes\\_deathicons;", "contents": "deathicons::destroy_slowly(${1:timeout}, ${2:deathIconObjId})"},
	{ "trigger": "ragdoll_override\t#using scripts\\mp\\gametypes\\_deathicons;", "contents": "deathicons::ragdoll_override(${1:iDamage}, ${2:sMeansOfDeath}, ${3:sWeapon}, ${4:sHitLoc}, ${5:vDir}, ${6:vAttackerOrigin}, ${7:deathAnimDuration}, ${8:eInflictor}, ${9:ragdoll_jib}, ${10:body})"},
	{ "trigger": "InitFlakDrone\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::InitFlakDrone()"},
	{ "trigger": "state_off_enter\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::state_off_enter(${1:params})"},
	{ "trigger": "state_off_update\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::state_off_update(${1:params})"},
	{ "trigger": "UpdateFlakDroneSpeed\t#using scripts\\mp\\killstreaks\\_flak_drone; self == flak drone", "contents": "flak_drone::UpdateFlakDroneSpeed()"},
	{ "trigger": "state_combat_enter\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::state_combat_enter(${1:params})"},
	{ "trigger": "state_combat_update\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::state_combat_update(${1:params})"},
	{ "trigger": "SpawnFlakRocket\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::SpawnFlakRocket(${1:missile}, ${2:spawnPos}, ${3:parent})"},
	{ "trigger": "CleanupAfterMissileDeath\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::CleanupAfterMissileDeath(${1:rocket}, ${2:flak_drone})"},
	{ "trigger": "state_death_update\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::state_death_update(${1:params})"},
	{ "trigger": "drone_pain_for_time\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::drone_pain_for_time(${1:time}, ${2:stablizeParam}, ${3:restoreLookPoint})"},
	{ "trigger": "drone_pain\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::drone_pain(${1:eAttacker}, ${2:damageType}, ${3:hitPoint}, ${4:hitDirection}, ${5:hitLocationInfo}, ${6:partName})"},
	{ "trigger": "FlakDroneDamageOverride\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::FlakDroneDamageOverride(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:vDamageOrigin}, ${11:psOffsetTime}, ${12:damageFromUnderneath}, ${13:modelIndex}, ${14:partName}, ${15:vSurfaceNormal})"},
	{ "trigger": "Spawn\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::Spawn(${1:parent}, ${2:onDeathCallback})"},
	{ "trigger": "configureTeam\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::configureTeam(${1:parent}, ${2:isHacked})"},
	{ "trigger": "WatchGameEvents\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::WatchGameEvents()"},
	{ "trigger": "WatchDeath\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::WatchDeath()"},
	{ "trigger": "WatchParentDeath\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::WatchParentDeath()"},
	{ "trigger": "WatchParentMissiles\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::WatchParentMissiles()"},
	{ "trigger": "SetCamoState\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::SetCamoState(${1:state})"},
	{ "trigger": "Shutdown\t#using scripts\\mp\\killstreaks\\_flak_drone;", "contents": "flak_drone::Shutdown(${1:explode})"},
	{ "trigger": "on_player_spawned\t#using scripts\\mp\\_explosive_bolt; self == player", "contents": "explosive_bolt::on_player_spawned()"},
	{ "trigger": "begin_other_grenade_tracking\t#using scripts\\mp\\_explosive_bolt;", "contents": "explosive_bolt::begin_other_grenade_tracking()"},
	{ "trigger": "watch_bolt_detonation\t#using scripts\\mp\\_explosive_bolt; self == explosive_bolt entity", "contents": "explosive_bolt::watch_bolt_detonation(${1:owner})"},
	{ "trigger": "SetupCallbacks\t#using scripts\\mp\\gametypes\\_globallogic_ui;", "contents": "globallogic_ui::SetupCallbacks()"},
	{ "trigger": "freeGameplayHudElems\t#using scripts\\mp\\gametypes\\_globallogic_ui;", "contents": "globallogic_ui::freeGameplayHudElems()"},
	{ "trigger": "teamPlayerCountsEqual\t#using scripts\\mp\\gametypes\\_globallogic_ui;", "contents": "globallogic_ui::teamPlayerCountsEqual(${1:playerCounts})"},
	{ "trigger": "teamWithLowestPlayerCount\t#using scripts\\mp\\gametypes\\_globallogic_ui;", "contents": "globallogic_ui::teamWithLowestPlayerCount(${1:playerCounts}, ${2:ignore_team})"},
	{ "trigger": "shouldBeSpectatorLateJoin\t#using scripts\\mp\\gametypes\\_globallogic_ui;", "contents": "globallogic_ui::shouldBeSpectatorLateJoin(${1:teamName}, ${2:comingFromMenu})"},
	{ "trigger": "menuAutoAssign\t#using scripts\\mp\\gametypes\\_globallogic_ui;", "contents": "globallogic_ui::menuAutoAssign(${1:comingFromMenu})"},
	{ "trigger": "teamScoresEqual\t#using scripts\\mp\\gametypes\\_globallogic_ui;", "contents": "globallogic_ui::teamScoresEqual()"},
	{ "trigger": "teamWithLowestScore\t#using scripts\\mp\\gametypes\\_globallogic_ui;", "contents": "globallogic_ui::teamWithLowestScore()"},
	{ "trigger": "pickTeamFromScores\t#using scripts\\mp\\gametypes\\_globallogic_ui;", "contents": "globallogic_ui::pickTeamFromScores(${1:teams})"},
	{ "trigger": "get_splitscreen_team\t#using scripts\\mp\\gametypes\\_globallogic_ui;", "contents": "globallogic_ui::get_splitscreen_team()"},
	{ "trigger": "updateObjectiveText\t#using scripts\\mp\\gametypes\\_globallogic_ui;", "contents": "globallogic_ui::updateObjectiveText()"},
	{ "trigger": "closeMenus\t#using scripts\\mp\\gametypes\\_globallogic_ui;", "contents": "globallogic_ui::closeMenus()"},
	{ "trigger": "beginClassChoice\t#using scripts\\mp\\gametypes\\_globallogic_ui;", "contents": "globallogic_ui::beginClassChoice()"},
	{ "trigger": "showMainMenuForTeam\t#using scripts\\mp\\gametypes\\_globallogic_ui;", "contents": "globallogic_ui::showMainMenuForTeam()"},
	{ "trigger": "menuTeam\t#using scripts\\mp\\gametypes\\_globallogic_ui;", "contents": "globallogic_ui::menuTeam(${1:team})"},
	{ "trigger": "menuSpectator\t#using scripts\\mp\\gametypes\\_globallogic_ui;", "contents": "globallogic_ui::menuSpectator()"},
	{ "trigger": "menuClass\t#using scripts\\mp\\gametypes\\_globallogic_ui;", "contents": "globallogic_ui::menuClass(${1:response}, ${2:forcedClass})"},
	{ "trigger": "removeSpawnMessageShortly\t#using scripts\\mp\\gametypes\\_globallogic_ui;", "contents": "globallogic_ui::removeSpawnMessageShortly(${1:delay})"},
	{ "trigger": "finishHardpointLocationUsage\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::finishHardpointLocationUsage(${1:location}, ${2:usedCallback})"},
	{ "trigger": "finishDualHardpointLocationUsage\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::finishDualHardpointLocationUsage(${1:locationStart}, ${2:locationEnd}, ${3:usedCallback})"},
	{ "trigger": "endSelectionOnGameEnd\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::endSelectionOnGameEnd()"},
	{ "trigger": "endSelectionOnHostMigration\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::endSelectionOnHostMigration()"},
	{ "trigger": "endSelectionThink\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::endSelectionThink()"},
	{ "trigger": "clearUpLocationSelection\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::clearUpLocationSelection()"},
	{ "trigger": "stopLoopSoundAfterTime\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::stopLoopSoundAfterTime(${1:time})"},
	{ "trigger": "calculateFallTime\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::calculateFallTime(${1:flyHeight})"},
	{ "trigger": "calculateReleaseTime\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::calculateReleaseTime(${1:flyTime}, ${2:flyHeight}, ${3:flySpeed}, ${4:bombSpeedScale})"},
	{ "trigger": "getMinimumFlyHeight\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::getMinimumFlyHeight()"},
	{ "trigger": "callStrike\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::callStrike(${1:flightPlan})"},
	{ "trigger": "planeStrike\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::planeStrike(${1:owner}, ${2:requiredDeathCount}, ${3:pathStart}, ${4:pathEnd}, ${5:bombTime}, ${6:flyTime}, ${7:flyspeed}, ${8:bombSpeedScale}, ${9:direction}, ${10:planeSpawnedFunction})"},
	{ "trigger": "determineGroundPoint\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::determineGroundPoint(${1:player}, ${2:position})"},
	{ "trigger": "determineTargetPoint\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::determineTargetPoint(${1:player}, ${2:position})"},
	{ "trigger": "getMinTargetHeight\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::getMinTargetHeight()"},
	{ "trigger": "getMaxTargetHeight\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::getMaxTargetHeight()"},
	{ "trigger": "clampTarget\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::clampTarget(${1:target})"},
	{ "trigger": "_insideCylinder\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::_insideCylinder(${1:point}, ${2:base}, ${3:radius}, ${4:height})"},
	{ "trigger": "_insideNoFlyZoneByIndex\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::_insideNoFlyZoneByIndex(${1:point}, ${2:index}, ${3:disregardHeight})"},
	{ "trigger": "getNoFlyZoneHeight\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::getNoFlyZoneHeight(${1:point})"},
	{ "trigger": "insideNoFlyZones\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::insideNoFlyZones(${1:point}, ${2:disregardHeight})"},
	{ "trigger": "crossesNoFlyZone\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::crossesNoFlyZone(${1:start}, ${2:end})"},
	{ "trigger": "crossesNoFlyZones\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::crossesNoFlyZones(${1:start}, ${2:end})"},
	{ "trigger": "getNoFlyZoneHeightCrossed\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::getNoFlyZoneHeightCrossed(${1:start}, ${2:end}, ${3:minHeight})"},
	{ "trigger": "_shouldIgnoreNoFlyZone\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::_shouldIgnoreNoFlyZone(${1:noFlyZone}, ${2:noFlyZones})"},
	{ "trigger": "_shouldIgnoreStartGoalNoFlyZone\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::_shouldIgnoreStartGoalNoFlyZone(${1:noFlyZone}, ${2:startNoFlyZones}, ${3:goalNoFlyZones})"},
	{ "trigger": "getHeliPath\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::getHeliPath(${1:start}, ${2:goal})"},
	{ "trigger": "followPath\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::followPath(${1:path}, ${2:doneNotify}, ${3:stopAtGoal})"},
	{ "trigger": "setGoalPosition\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::setGoalPosition(${1:goal}, ${2:doneNotify}, ${3:stopAtGoal})"},
	{ "trigger": "clearPath\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::clearPath(${1:start}, ${2:end}, ${3:startNoFlyZone}, ${4:goalNoFlyZone})"},
	{ "trigger": "append_array\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::append_array(${1:dst}, ${2:src})"},
	{ "trigger": "calculatePath_r\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::calculatePath_r(${1:start}, ${2:end}, ${3:points}, ${4:startNoFlyZones}, ${5:goalNoFlyZones}, ${6:depth})"},
	{ "trigger": "calculatePath\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::calculatePath(${1:start}, ${2:end}, ${3:startNoFlyZones}, ${4:goalNoFlyZones})"},
	{ "trigger": "_getStrikePathStartAndEnd\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::_getStrikePathStartAndEnd(${1:goal}, ${2:yaw}, ${3:halfDistance})"},
	{ "trigger": "getStrikePath\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::getStrikePath(${1:target}, ${2:height}, ${3:halfDistance}, ${4:yaw})"},
	{ "trigger": "doGlassDamage\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::doGlassDamage(${1:pos}, ${2:radius}, ${3:max}, ${4:min}, ${5:mod})"},
	{ "trigger": "entLOSRadiusDamage\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::entLOSRadiusDamage(${1:ent}, ${2:pos}, ${3:radius}, ${4:max}, ${5:min}, ${6:owner}, ${7:eInflictor})"},
	{ "trigger": "GetMapCenter\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::GetMapCenter()"},
	{ "trigger": "GetRandomMapPoint\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::GetRandomMapPoint(${1:x_offset}, ${2:y_offset}, ${3:map_x_percentage}, ${4:map_y_percentage})"},
	{ "trigger": "GetMaxMapWidth\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::GetMaxMapWidth()"},
	{ "trigger": "InitRotatingRig\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::InitRotatingRig()"},
	{ "trigger": "RotateRig\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::RotateRig()"},
	{ "trigger": "SwayRig\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::SwayRig()"},
	{ "trigger": "StopRotation\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::StopRotation(${1:time})"},
	{ "trigger": "FlattenYaw\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::FlattenYaw(${1:goal})"},
	{ "trigger": "FlattenRoll\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::FlattenRoll()"},
	{ "trigger": "Leave\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::Leave(${1:duration})"},
	{ "trigger": "GetRandomHelicopterStartOrigin\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::GetRandomHelicopterStartOrigin()"},
	{ "trigger": "getPointOnLine\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::getPointOnLine(${1:startPoint}, ${2:endPoint}, ${3:ratio})"},
	{ "trigger": "canTargetPlayerWithSpecialty\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::canTargetPlayerWithSpecialty()"},
	{ "trigger": "monitorSpeed\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::monitorSpeed(${1:spawnProtectionTime})"},
	{ "trigger": "clearmonitoredspeed\t#using scripts\\mp\\killstreaks\\_airsupport;", "contents": "airsupport::clearmonitoredspeed()"},
	{ "trigger": "on_connect\t#using scripts\\mp\\_arena; self = player", "contents": "arena::on_connect()"},
	{ "trigger": "update_arena_challenge_seasons\t#using scripts\\mp\\_arena;", "contents": "arena::update_arena_challenge_seasons()"},
	{ "trigger": "match_end\t#using scripts\\mp\\_arena;", "contents": "arena::match_end(${1:winner})"},
	{ "trigger": "is_bot_soak\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::is_bot_soak()"},
	{ "trigger": "wait_for_host\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::wait_for_host()"},
	{ "trigger": "get_host_team\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::get_host_team()"},
	{ "trigger": "is_bot_comp_stomp\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::is_bot_comp_stomp()"},
	{ "trigger": "on_bot_connect\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::on_bot_connect()"},
	{ "trigger": "on_bot_spawned\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::on_bot_spawned()"},
	{ "trigger": "on_bot_killed\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::on_bot_killed()"},
	{ "trigger": "respawn\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::respawn()"},
	{ "trigger": "bot_idle\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::bot_idle()"},
	{ "trigger": "do_supplydrop\t#using scripts\\mp\\bots\\_bot; A little under minimap width", "contents": "bot::do_supplydrop(${1:maxRange = 1400})"},
	{ "trigger": "watch_crate\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::watch_crate(${1:crate})"},
	{ "trigger": "populate_bots\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::populate_bots()"},
	{ "trigger": "monitor_bot_team_population\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::monitor_bot_team_population(${1:maxAllies}, ${2:maxAxis})"},
	{ "trigger": "fill_balanced_teams\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::fill_balanced_teams(${1:maxAllies}, ${2:maxAxis})"},
	{ "trigger": "add_balanced_bot\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::add_balanced_bot(${1:allies}, ${2:maxAllies}, ${3:axis}, ${4:maxAxis})"},
	{ "trigger": "monitor_bot_population\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::monitor_bot_population(${1:maxFree})"},
	{ "trigger": "remove_best_bot\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::remove_best_bot(${1:players})"},
	{ "trigger": "choose_class\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::choose_class()"},
	{ "trigger": "use_killstreak\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::use_killstreak()"},
	{ "trigger": "has_radar\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::has_radar()"},
	{ "trigger": "has_minimap\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::has_minimap()"},
	{ "trigger": "get_enemies\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::get_enemies(${1:on_radar})"},
	{ "trigger": "set_rank\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::set_rank()"},
	{ "trigger": "get_bot_settings\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::get_bot_settings()"},
	{ "trigger": "friend_goal_in_radius\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::friend_goal_in_radius(${1:goal_name}, ${2:origin}, ${3:radius})"},
	{ "trigger": "friend_in_radius\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::friend_in_radius(${1:goal_name}, ${2:origin}, ${3:radius})"},
	{ "trigger": "get_friends\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::get_friends()"},
	{ "trigger": "get_closest_enemy\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::get_closest_enemy(${1:origin}, ${2:someFlag})"},
	{ "trigger": "bot_vehicle_weapon_ammo\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::bot_vehicle_weapon_ammo(${1:weaponName})"},
	{ "trigger": "navmesh_points_visible\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::navmesh_points_visible(${1:origin}, ${2:point})"},
	{ "trigger": "dive_to_prone\t#using scripts\\mp\\bots\\_bot;", "contents": "bot::dive_to_prone(${1:exit_stance})"},
	{ "trigger": "on_player_killed\t#using scripts\\mp\\gametypes\\_friendicons;", "contents": "friendicons::on_player_killed()"},
	{ "trigger": "on_player_spawned\t#using scripts\\mp\\gametypes\\_friendicons; self == player", "contents": "friendicons::on_player_spawned()"},
	{ "trigger": "showFriendIcon\t#using scripts\\mp\\gametypes\\_friendicons;", "contents": "friendicons::showFriendIcon()"},
	{ "trigger": "updateFriendIconSettings\t#using scripts\\mp\\gametypes\\_friendicons;", "contents": "friendicons::updateFriendIconSettings()"},
	{ "trigger": "updateFriendIcons\t#using scripts\\mp\\gametypes\\_friendicons;", "contents": "friendicons::updateFriendIcons()"},
	{ "trigger": "onPrecacheGameType\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::onPrecacheGameType()"},
	{ "trigger": "onStartGameType\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::onStartGameType()"},
	{ "trigger": "shouldPlayOvertimeRound\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::shouldPlayOvertimeRound()"},
	{ "trigger": "minutesAndSecondsString\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::minutesAndSecondsString(${1:milliseconds})"},
	{ "trigger": "setMatchScoreHUDElemForTeam\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::setMatchScoreHUDElemForTeam(${1:team})"},
	{ "trigger": "onRoundSwitch\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::onRoundSwitch()"},
	{ "trigger": "onEndGame\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::onEndGame(${1:winningTeam})"},
	{ "trigger": "updateTeamScoreByRoundsWon\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::updateTeamScoreByRoundsWon()"},
	{ "trigger": "updateTeamScoreByFlagsCaptured\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::updateTeamScoreByFlagsCaptured()"},
	{ "trigger": "onRoundEndGame\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::onRoundEndGame(${1:winningTeam})"},
	{ "trigger": "onSpawnPlayer\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::onSpawnPlayer(${1:predictedSpawn})"},
	{ "trigger": "updateGametypeDvars\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::updateGametypeDvars()"},
	{ "trigger": "createFlag\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::createFlag(${1:trigger})"},
	{ "trigger": "createFlagZone\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::createFlagZone(${1:trigger})"},
	{ "trigger": "createFlagHint\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::createFlagHint(${1:team}, ${2:origin})"},
	{ "trigger": "ctf\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::ctf()"},
	{ "trigger": "ctf_icon_hide\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::ctf_icon_hide()"},
	{ "trigger": "removeInfluencers\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::removeInfluencers()"},
	{ "trigger": "onDrop\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::onDrop(${1:player})"},
	{ "trigger": "onPickup\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::onPickup(${1:player})"},
	{ "trigger": "OnPickupMusicState\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::OnPickupMusicState(${1:player})"},
	{ "trigger": "isHome\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::isHome()"},
	{ "trigger": "returnFlag\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::returnFlag()"},
	{ "trigger": "onCapture\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::onCapture(${1:player})"},
	{ "trigger": "giveFlagCaptureXP\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::giveFlagCaptureXP(${1:player})"},
	{ "trigger": "onReset\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::onReset()"},
	{ "trigger": "getOtherFlag\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::getOtherFlag(${1:flag})"},
	{ "trigger": "onPlayerKilled\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::onPlayerKilled(${1:eInflictor}, ${2:attacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime}, ${9:deathAnimDuration})"},
	{ "trigger": "createReturnMessageElems\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::createReturnMessageElems()"},
	{ "trigger": "returnFlagAfterTimeMsg\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::returnFlagAfterTimeMsg(${1:time})"},
	{ "trigger": "returnFlagHudElems\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::returnFlagHudElems(${1:time})"},
	{ "trigger": "clearReturnFlagHudElems\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::clearReturnFlagHudElems()"},
	{ "trigger": "turn_on\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::turn_on()"},
	{ "trigger": "turn_off\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::turn_off()"},
	{ "trigger": "update_hints\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::update_hints()"},
	{ "trigger": "claim_trigger\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::claim_trigger(${1:trigger})"},
	{ "trigger": "createFlagSpawnInfluencer\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::createFlagSpawnInfluencer(${1:entityTeam})"},
	{ "trigger": "ctf_getTeamKillPenalty\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::ctf_getTeamKillPenalty(${1:eInflictor}, ${2:attacker}, ${3:sMeansOfDeath}, ${4:weapon})"},
	{ "trigger": "ctf_getTeamKillScore\t#using scripts\\mp\\gametypes\\ctf;", "contents": "ctf::ctf_getTeamKillScore(${1:eInflictor}, ${2:attacker}, ${3:sMeansOfDeath}, ${4:weapon})"},
	{ "trigger": "ActivateDroneStrike\t#using scripts\\mp\\killstreaks\\_drone_strike;", "contents": "drone_strike::ActivateDroneStrike()"},
	{ "trigger": "SelectDroneStrikePath\t#using scripts\\mp\\killstreaks\\_drone_strike;", "contents": "drone_strike::SelectDroneStrikePath()"},
	{ "trigger": "WaitForLocationSelection\t#using scripts\\mp\\killstreaks\\_drone_strike;", "contents": "drone_strike::WaitForLocationSelection()"},
	{ "trigger": "DroneStrikeLocationSelected\t#using scripts\\mp\\killstreaks\\_drone_strike;", "contents": "drone_strike::DroneStrikeLocationSelected(${1:location})"},
	{ "trigger": "WatchForKillstreakEnd\t#using scripts\\mp\\killstreaks\\_drone_strike;", "contents": "drone_strike::WatchForKillstreakEnd(${1:team}, ${2:influencer}, ${3:killstreak_id})"},
	{ "trigger": "StartDroneStrike\t#using scripts\\mp\\killstreaks\\_drone_strike;", "contents": "drone_strike::StartDroneStrike(${1:position}, ${2:yaw}, ${3:team}, ${4:killstreak_id})"},
	{ "trigger": "SpawnDrone\t#using scripts\\mp\\killstreaks\\_drone_strike;", "contents": "drone_strike::SpawnDrone(${1:startPoint}, ${2:endPoint}, ${3:targetPoint}, ${4:angles}, ${5:team}, ${6:killstreak_id})"},
	{ "trigger": "SetupDamageHandling\t#using scripts\\mp\\killstreaks\\_drone_strike;", "contents": "drone_strike::SetupDamageHandling()"},
	{ "trigger": "DestroyDronePlane\t#using scripts\\mp\\killstreaks\\_drone_strike;", "contents": "drone_strike::DestroyDronePlane(${1:attacker}, ${2:weapon})"},
	{ "trigger": "WatchOwnerEvents\t#using scripts\\mp\\killstreaks\\_drone_strike;", "contents": "drone_strike::WatchOwnerEvents(${1:bomb})"},
	{ "trigger": "WatchForEmp\t#using scripts\\mp\\killstreaks\\_drone_strike;", "contents": "drone_strike::WatchForEmp(${1:owner})"},
	{ "trigger": "EmpDamageDrone\t#using scripts\\mp\\killstreaks\\_drone_strike;", "contents": "drone_strike::EmpDamageDrone(${1:attacker})"},
	{ "trigger": "DroneStrikeAwardEMPScoreEvent\t#using scripts\\mp\\killstreaks\\_drone_strike;", "contents": "drone_strike::DroneStrikeAwardEMPScoreEvent(${1:attacker}, ${2:victim})"},
	{ "trigger": "BlowUpDroneStrike\t#using scripts\\mp\\killstreaks\\_drone_strike;", "contents": "drone_strike::BlowUpDroneStrike()"},
	{ "trigger": "update\t#using scripts\\mp\\gametypes\\_serversettings;", "contents": "serversettings::update()"},
	{ "trigger": "constrain_gametype\t#using scripts\\mp\\gametypes\\_serversettings;", "contents": "serversettings::constrain_gametype(${1:gametype})"},
	{ "trigger": "constrain_map_size\t#using scripts\\mp\\gametypes\\_serversettings;", "contents": "serversettings::constrain_map_size(${1:mapsize})"},
	{ "trigger": "createRule\t#using scripts\\mp\\killstreaks\\_killstreakrules;", "contents": "killstreakrules::createRule(${1:rule}, ${2:maxAllowable}, ${3:maxAllowablePerTeam})"},
	{ "trigger": "addKillstreakToRule\t#using scripts\\mp\\killstreaks\\_killstreakrules;", "contents": "killstreakrules::addKillstreakToRule(${1:killstreak}, ${2:rule}, ${3:countTowards}, ${4:checkAgainst}, ${5:inventoryVariant})"},
	{ "trigger": "killstreakStart\t#using scripts\\mp\\killstreaks\\_killstreakrules;", "contents": "killstreakrules::killstreakStart(${1:hardpointType}, ${2:team}, ${3:hacked}, ${4:displayTeamMessage})"},
	{ "trigger": "displayKillstreakStartTeamMessageToAll\t#using scripts\\mp\\killstreaks\\_killstreakrules;", "contents": "killstreakrules::displayKillstreakStartTeamMessageToAll(${1:hardpointType})"},
	{ "trigger": "RecordKillstreakEndDirect\t#using scripts\\mp\\killstreaks\\_killstreakrules;", "contents": "killstreakrules::RecordKillstreakEndDirect(${1:eventIndex}, ${2:recordStreakIndex}, ${3:totalKills})"},
	{ "trigger": "RecordKillstreakEnd\t#using scripts\\mp\\killstreaks\\_killstreakrules;", "contents": "killstreakrules::RecordKillstreakEnd(${1:recordStreakIndex}, ${2:totalKills})"},
	{ "trigger": "killstreakStop\t#using scripts\\mp\\killstreaks\\_killstreakrules;", "contents": "killstreakrules::killstreakStop(${1:hardpointType}, ${2:team}, ${3:id})"},
	{ "trigger": "isKillstreakAllowed\t#using scripts\\mp\\killstreaks\\_killstreakrules;", "contents": "killstreakrules::isKillstreakAllowed(${1:hardpointType}, ${2:team})"},
	{ "trigger": "InitTurret\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::InitTurret()"},
	{ "trigger": "ActivateTurret\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::ActivateTurret()"},
	{ "trigger": "OnPlaceTurret\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::OnPlaceTurret(${1:turret})"},
	{ "trigger": "HackedCallbackPre\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::HackedCallbackPre(${1:hacker})"},
	{ "trigger": "HackedCallbackPost\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::HackedCallbackPost(${1:hacker})"},
	{ "trigger": "play_deploy_anim_after_wait\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::play_deploy_anim_after_wait(${1:wait_time})"},
	{ "trigger": "play_deploy_anim\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::play_deploy_anim()"},
	{ "trigger": "OnCancelPlacement\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::OnCancelPlacement(${1:turret})"},
	{ "trigger": "OnPickupTurret\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::OnPickupTurret(${1:turret})"},
	{ "trigger": "OnTurretDamage\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::OnTurretDamage(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:vDamageOrigin}, ${11:psOffsetTime}, ${12:damageFromUnderneath}, ${13:modelIndex}, ${14:partName}, ${15:vSurfaceNormal})"},
	{ "trigger": "OnTurretDeath\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::OnTurretDeath(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime})"},
	{ "trigger": "OnDeathAfterFrameEnd\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::OnDeathAfterFrameEnd(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime})"},
	{ "trigger": "OnDeath\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::OnDeath(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime})"},
	{ "trigger": "OnShutdown\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::OnShutdown(${1:turret})"},
	{ "trigger": "StartTurretRemoteControl\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::StartTurretRemoteControl(${1:turretVehicle})"},
	{ "trigger": "EndTurretRemoteControl\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::EndTurretRemoteControl(${1:turretVehicle}, ${2:exitRequestedByOwner})"},
	{ "trigger": "EnableTurretAfterWait\t#using scripts\\mp\\killstreaks\\_turret; self == turretVehicle", "contents": "turret::EnableTurretAfterWait(${1:wait_time})"},
	{ "trigger": "CreateTurretInfluencer\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::CreateTurretInfluencer(${1:name})"},
	{ "trigger": "turret_watch_owner_events\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::turret_watch_owner_events()"},
	{ "trigger": "turret_laser_watch\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::turret_laser_watch()"},
	{ "trigger": "setup_death_watch_for_new_targets\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::setup_death_watch_for_new_targets()"},
	{ "trigger": "target_death_watch\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::target_death_watch(${1:turretVehicle})"},
	{ "trigger": "TurretScanning\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::TurretScanning()"},
	{ "trigger": "WatchTurretShutdown\t#using scripts\\mp\\killstreaks\\_turret;", "contents": "turret::WatchTurretShutdown(${1:killstreakId}, ${2:team})"},
	{ "trigger": "water_killbrush_think\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::water_killbrush_think()"},
	{ "trigger": "get_vehicle_name\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::get_vehicle_name()"},
	{ "trigger": "get_default_vehicle_name\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::get_default_vehicle_name()"},
	{ "trigger": "get_vehicle_name_key_for_damage_states\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::get_vehicle_name_key_for_damage_states()"},
	{ "trigger": "get_vehicle_damage_state_index_from_health_percentage\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::get_vehicle_damage_state_index_from_health_percentage()"},
	{ "trigger": "update_damage_effects\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::update_damage_effects()"},
	{ "trigger": "play_damage_state_effects\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::play_damage_state_effects()"},
	{ "trigger": "play_vehicle_effects\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::play_vehicle_effects(${1:effects}, ${2:isDamagedTread})"},
	{ "trigger": "precache_vehicles\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::precache_vehicles()"},
	{ "trigger": "register_vehicle\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::register_vehicle()"},
	{ "trigger": "manage_vehicles\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::manage_vehicles()"},
	{ "trigger": "player_wait_exit_vehicle_t\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::player_wait_exit_vehicle_t()"},
	{ "trigger": "player_update_vehicle_hud\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::player_update_vehicle_hud(${1:show}, ${2:vehicle})"},
	{ "trigger": "build_template\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::build_template(${1:type}, ${2:model}, ${3:typeoverride})"},
	{ "trigger": "build_rumble\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::build_rumble(${1:rumble}, ${2:scale}, ${3:duration}, ${4:radius}, ${5:basetime}, ${6:randomaditionaltime})"},
	{ "trigger": "build_quake\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::build_quake(${1:scale}, ${2:duration}, ${3:radius}, ${4:basetime}, ${5:randomaditionaltime})"},
	{ "trigger": "build_exhaust\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::build_exhaust(${1:effect})"},
	{ "trigger": "vehicle_abandoned_by_drift_t\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_abandoned_by_drift_t()"},
	{ "trigger": "vehicle_abandoned_by_occupants_timeout_t\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_abandoned_by_occupants_timeout_t()"},
	{ "trigger": "wait_then_cleanup_vehicle\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::wait_then_cleanup_vehicle(${1:test_name}, ${2:cleanup_dvar_name})"},
	{ "trigger": "wait_until_severely_damaged\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::wait_until_severely_damaged()"},
	{ "trigger": "get_random_cleanup_wait_time\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::get_random_cleanup_wait_time(${1:state})"},
	{ "trigger": "do_alive_cleanup_wait\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::do_alive_cleanup_wait(${1:test_name})"},
	{ "trigger": "do_dead_cleanup_wait\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::do_dead_cleanup_wait(${1:test_name})"},
	{ "trigger": "cleanup\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::cleanup(${1:test_name}, ${2:cleanup_dvar_name}, ${3:cleanup_func})"},
	{ "trigger": "vehicle_wait_tread_damage\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_wait_tread_damage()"},
	{ "trigger": "wait_for_vehicle_to_stop_outside_min_radius\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::wait_for_vehicle_to_stop_outside_min_radius()"},
	{ "trigger": "vehicle_abandoned_by_occupants_t\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_abandoned_by_occupants_t()"},
	{ "trigger": "play_start_stop_sound\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::play_start_stop_sound(${1:sound_alias}, ${2:modulation})"},
	{ "trigger": "vehicle_ghost_entering_occupants_t\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_ghost_entering_occupants_t()"},
	{ "trigger": "player_is_occupant_invulnerable\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::player_is_occupant_invulnerable(${1:sMeansOfDeath})"},
	{ "trigger": "player_is_driver\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::player_is_driver()"},
	{ "trigger": "player_change_seat_handler_t\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::player_change_seat_handler_t(${1:vehicle})"},
	{ "trigger": "player_leave_vehicle_cleanup_t\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::player_leave_vehicle_cleanup_t(${1:vehicle})"},
	{ "trigger": "vehicle_is_tank\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_is_tank()"},
	{ "trigger": "vehicle_should_explode_on_cleanup\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_should_explode_on_cleanup()"},
	{ "trigger": "vehicle_recycle\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_recycle()"},
	{ "trigger": "wait_for_vehicle_overturn\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::wait_for_vehicle_overturn()"},
	{ "trigger": "vehicle_overturn_eject_occupants\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_overturn_eject_occupants()"},
	{ "trigger": "vehicle_eject_all_occupants\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_eject_all_occupants()"},
	{ "trigger": "vehicle_overturn_suicide\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_overturn_suicide()"},
	{ "trigger": "suicide\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::suicide()"},
	{ "trigger": "kill_vehicle\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::kill_vehicle(${1:attacker})"},
	{ "trigger": "value_with_default\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::value_with_default(${1:preferred_value}, ${2:default_value})"},
	{ "trigger": "vehicle_transmute\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_transmute(${1:attacker})"},
	{ "trigger": "respawn_vehicle\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::respawn_vehicle(${1:respawn_parameters})"},
	{ "trigger": "remove_vehicle_from_world\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::remove_vehicle_from_world()"},
	{ "trigger": "_delete_entity\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::_delete_entity()"},
	{ "trigger": "hide_vehicle\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::hide_vehicle()"},
	{ "trigger": "wait_for_unnoticeable_cleanup_opportunity\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::wait_for_unnoticeable_cleanup_opportunity()"},
	{ "trigger": "wait_until_vehicle_position_wont_telefrag\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::wait_until_vehicle_position_wont_telefrag(${1:position})"},
	{ "trigger": "vehicle_position_will_telefrag\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_position_will_telefrag(${1:position})"},
	{ "trigger": "vehicle_telefrag_griefers_at_position\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_telefrag_griefers_at_position(${1:position})"},
	{ "trigger": "player_vehicle_position_will_telefrag\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::player_vehicle_position_will_telefrag(${1:position})"},
	{ "trigger": "vehicle_recycle_spawner_t\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_recycle_spawner_t()"},
	{ "trigger": "vehicle_play_explosion_sound\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_play_explosion_sound()"},
	{ "trigger": "vehicle_damage_t\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_damage_t()"},
	{ "trigger": "_spawn_husk\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::_spawn_husk(${1:origin}, ${2:angles}, ${3:modelname})"},
	{ "trigger": "is_vehicle\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::is_vehicle()"},
	{ "trigger": "swap_to_husk_model\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::swap_to_husk_model()"},
	{ "trigger": "husk_cleanup_t\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::husk_cleanup_t()"},
	{ "trigger": "final_husk_cleanup_t\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::final_husk_cleanup_t(${1:respawn_parameters})"},
	{ "trigger": "husk_do_cleanup\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::husk_do_cleanup()"},
	{ "trigger": "_spawn_explosion\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::_spawn_explosion(${1:origin})"},
	{ "trigger": "_play_sound_in_space\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::_play_sound_in_space(${1:soundEffectName}, ${2:origin})"},
	{ "trigger": "vehicle_kill_disconnect_paths_forever\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_kill_disconnect_paths_forever()"},
	{ "trigger": "vehicle_disconnect_paths\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::vehicle_disconnect_paths()"},
	{ "trigger": "follow_path\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::follow_path(${1:node})"},
	{ "trigger": "InitVehicleMap\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::InitVehicleMap()"},
	{ "trigger": "VehicleMainThread\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::VehicleMainThread()"},
	{ "trigger": "VehicleSpawnThread\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::VehicleSpawnThread(${1:veh_name}, ${2:origin}, ${3:angles}, ${4:time_interval})"},
	{ "trigger": "VehicleTeamThread\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::VehicleTeamThread()"},
	{ "trigger": "WatchPlayerExitRequestThread\t#using scripts\\mp\\_vehicle;", "contents": "vehicle::WatchPlayerExitRequestThread(${1:player})"},
	{ "trigger": "on_player_spawned\t#using scripts\\mp\\killstreaks\\_remote_weapons; self == player", "contents": "remote_weapons::on_player_spawned()"},
	{ "trigger": "RemoveAndAssignNewRemoteControlTrigger\t#using scripts\\mp\\killstreaks\\_remote_weapons; player = self", "contents": "remote_weapons::RemoveAndAssignNewRemoteControlTrigger(${1:remoteControlTrigger})"},
	{ "trigger": "AssignRemoteControlTrigger\t#using scripts\\mp\\killstreaks\\_remote_weapons; player = self", "contents": "remote_weapons::AssignRemoteControlTrigger(${1:force_new_assignment = false})"},
	{ "trigger": "RegisterRemoteWeapon\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::RegisterRemoteWeapon(${1:weaponName}, ${2:hintString}, ${3:useCallback}, ${4:endUseCallback}, ${5:hideCompassOnUse = true})"},
	{ "trigger": "UseRemoteWeapon\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::UseRemoteWeapon(${1:weapon}, ${2:weaponName}, ${3:immediate}, ${4:allowManualDeactivation = true}, ${5:always_allow_ride = false})"},
	{ "trigger": "WatchForHack\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::WatchForHack()"},
	{ "trigger": "WatchRemoveRemoteControlledWeapon\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::WatchRemoveRemoteControlledWeapon()"},
	{ "trigger": "CreateRemoteWeaponTrigger\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::CreateRemoteWeaponTrigger()"},
	{ "trigger": "WatchWeaponDeath\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::WatchWeaponDeath()"},
	{ "trigger": "WatchOwnerDisconnect\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::WatchOwnerDisconnect()"},
	{ "trigger": "WatchRemoteTriggerDisable\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::WatchRemoteTriggerDisable()"},
	{ "trigger": "AllowRemoteStart\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::AllowRemoteStart()"},
	{ "trigger": "WatchRemoteTriggerUse\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::WatchRemoteTriggerUse()"},
	{ "trigger": "UseRemoteControlWeapon\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::UseRemoteControlWeapon(${1:allowManualDeactivation = true}, ${2:always_allow_ride = false})"},
	{ "trigger": "ResetControlInitiatedUponOwnerRespawn\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::ResetControlInitiatedUponOwnerRespawn()"},
	{ "trigger": "WatchRemoteControlDeactivate\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::WatchRemoteControlDeactivate()"},
	{ "trigger": "EndRemoteControlWeaponUse\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::EndRemoteControlWeaponUse(${1:exitRequestedByOwner})"},
	{ "trigger": "FadeToBlackAndBackIn\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::FadeToBlackAndBackIn()"},
	{ "trigger": "stunStaticFX\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::stunStaticFX(${1:duration})"},
	{ "trigger": "destroyRemoteHUD\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::destroyRemoteHUD()"},
	{ "trigger": "set_static\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::set_static(${1:val})"},
	{ "trigger": "do_static_fx\t#using scripts\\mp\\killstreaks\\_remote_weapons;", "contents": "remote_weapons::do_static_fx()"},
	{ "trigger": "OnPlayerConnect\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::OnPlayerConnect()"},
	{ "trigger": "OnPlayerSpawned\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::OnPlayerSpawned()"},
	{ "trigger": "GenerateRandomPoints\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::GenerateRandomPoints(${1:count})"},
	{ "trigger": "MovementManagerThink\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::MovementManagerThink(${1:teamOrEntNum})"},
	{ "trigger": "GetCurrentPosition\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::GetCurrentPosition(${1:teamOrEntNum})"},
	{ "trigger": "AssignFirstAvailableOffsetIndex\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::AssignFirstAvailableOffsetIndex()"},
	{ "trigger": "GetFirstAvailableOffsetIndex\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::GetFirstAvailableOffsetIndex()"},
	{ "trigger": "MaintainCouterUavEntities\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::MaintainCouterUavEntities()"},
	{ "trigger": "BuildOffsetList\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::BuildOffsetList(${1:startOffset}, ${2:depth}, ${3:offset_x}, ${4:offset_y})"},
	{ "trigger": "ActivateCounterUAV\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::ActivateCounterUAV()"},
	{ "trigger": "HackedPreFunction\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::HackedPreFunction(${1:hacker})"},
	{ "trigger": "SpawnCounterUAV\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::SpawnCounterUAV(${1:owner}, ${2:killstreak_id})"},
	{ "trigger": "ConfigureTeamPost\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::ConfigureTeamPost(${1:owner}, ${2:isHacked})"},
	{ "trigger": "ListenForMove\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::ListenForMove()"},
	{ "trigger": "CounterUAVMove\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::CounterUAVMove()"},
	{ "trigger": "PlayFx\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::PlayFx(${1:name})"},
	{ "trigger": "OnLowHealth\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::OnLowHealth(${1:attacker}, ${2:weapon})"},
	{ "trigger": "OnTeamChange\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::OnTeamChange(${1:entNum}, ${2:event})"},
	{ "trigger": "OnPlayerJoinedTeam\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::OnPlayerJoinedTeam()"},
	{ "trigger": "OnTimeout\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::OnTimeout()"},
	{ "trigger": "OnTimecheck\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::OnTimecheck()"},
	{ "trigger": "DestroyCounterUavByEMP\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::DestroyCounterUavByEMP(${1:attacker}, ${2:arg})"},
	{ "trigger": "DestroyCounterUAV\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::DestroyCounterUAV(${1:attacker}, ${2:weapon})"},
	{ "trigger": "DeleteCounterUAV\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::DeleteCounterUAV()"},
	{ "trigger": "EnemyCounterUAVActive\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::EnemyCounterUAVActive()"},
	{ "trigger": "HasActiveCounterUAV\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::HasActiveCounterUAV()"},
	{ "trigger": "TeamHasActiveCounterUAV\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::TeamHasActiveCounterUAV(${1:team})"},
	{ "trigger": "HasIndexActiveCounterUAV\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::HasIndexActiveCounterUAV(${1:team_or_entnum})"},
	{ "trigger": "AddActiveCounterUAV\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::AddActiveCounterUAV()"},
	{ "trigger": "RemoveActiveCounterUAV\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::RemoveActiveCounterUAV()"},
	{ "trigger": "ResetActiveCounterUAV\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::ResetActiveCounterUAV()"},
	{ "trigger": "WatchCounterUAVs\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::WatchCounterUAVs()"},
	{ "trigger": "HideAllCounterUAVsToSameTeam\t#using scripts\\mp\\killstreaks\\_counteruav;", "contents": "counteruav::HideAllCounterUAVsToSameTeam()"},
	{ "trigger": "set_difficulty\t#using scripts\\mp\\_mgturret;", "contents": "mgturret::set_difficulty(${1:difficulty})"},
	{ "trigger": "turret_set_difficulty\t#using scripts\\mp\\_mgturret;", "contents": "mgturret::turret_set_difficulty(${1:turret}, ${2:difficulty})"},
	{ "trigger": "turret_suppression_fire\t#using scripts\\mp\\_mgturret; self == turret", "contents": "mgturret::turret_suppression_fire(${1:targets})"},
	{ "trigger": "burst_fire_settings\t#using scripts\\mp\\_mgturret;", "contents": "mgturret::burst_fire_settings(${1:setting})"},
	{ "trigger": "burst_fire\t#using scripts\\mp\\_mgturret;", "contents": "mgturret::burst_fire(${1:turret}, ${2:manual_target})"},
	{ "trigger": "burst_fire_unmanned\t#using scripts\\mp\\_mgturret; self == turret", "contents": "mgturret::burst_fire_unmanned()"},
	{ "trigger": "do_shoot\t#using scripts\\mp\\_mgturret;", "contents": "mgturret::do_shoot()"},
	{ "trigger": "turret_timer\t#using scripts\\mp\\_mgturret;", "contents": "mgturret::turret_timer(${1:duration})"},
	{ "trigger": "random_spread\t#using scripts\\mp\\_mgturret;", "contents": "mgturret::random_spread(${1:ent})"},
	{ "trigger": "Callback_HostMigrationSave\t#using scripts\\mp\\gametypes\\_hostmigration;", "contents": "hostmigration::Callback_HostMigrationSave()"},
	{ "trigger": "Callback_PreHostMigrationSave\t#using scripts\\mp\\gametypes\\_hostmigration;", "contents": "hostmigration::Callback_PreHostMigrationSave()"},
	{ "trigger": "Callback_HostMigration\t#using scripts\\mp\\gametypes\\_hostmigration;", "contents": "hostmigration::Callback_HostMigration()"},
	{ "trigger": "HackedPreFunction\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::HackedPreFunction(${1:hacker})"},
	{ "trigger": "ConfigureTeamPost\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::ConfigureTeamPost(${1:owner}, ${2:isHacked})"},
	{ "trigger": "ActivateUAV\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::ActivateUAV()"},
	{ "trigger": "OnLowHealth\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::OnLowHealth(${1:attacker}, ${2:weapon})"},
	{ "trigger": "OnTeamChange\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::OnTeamChange(${1:entNum}, ${2:event})"},
	{ "trigger": "DestroyUAV\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::DestroyUAV(${1:attacker}, ${2:weapon})"},
	{ "trigger": "OnPlayerConnect\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::OnPlayerConnect()"},
	{ "trigger": "OnPlayerSpawned\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::OnPlayerSpawned()"},
	{ "trigger": "OnPlayerJoinedTeam\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::OnPlayerJoinedTeam()"},
	{ "trigger": "OnTimeout\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::OnTimeout()"},
	{ "trigger": "OnTimecheck\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::OnTimecheck()"},
	{ "trigger": "StartUAVFx\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::StartUAVFx()"},
	{ "trigger": "PlayAfterburnerFx\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::PlayAfterburnerFx()"},
	{ "trigger": "HasUAV\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::HasUAV(${1:team_or_entnum})"},
	{ "trigger": "AddActiveUAV\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::AddActiveUAV()"},
	{ "trigger": "RemoveActiveUAV\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::RemoveActiveUAV()"},
	{ "trigger": "ResetActiveUAV\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::ResetActiveUAV()"},
	{ "trigger": "UAVTracker\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::UAVTracker()"},
	{ "trigger": "HideAllUAVsToSameTeam\t#using scripts\\mp\\killstreaks\\_uav;", "contents": "uav::HideAllUAVsToSameTeam()"},
	{ "trigger": "set_leader_gametype_dialog\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::set_leader_gametype_dialog(${1:startGameDialogKey}, ${2:startHcGameDialogKey}, ${3:offenseOrderDialogKey}, ${4:defenseOrderDialogKey})"},
	{ "trigger": "announce_round_winner\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::announce_round_winner(${1:winner}, ${2:delay})"},
	{ "trigger": "announce_game_winner\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::announce_game_winner(${1:winner})"},
	{ "trigger": "flush_dialog\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::flush_dialog()"},
	{ "trigger": "flush_dialog_on_player\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::flush_dialog_on_player()"},
	{ "trigger": "flush_killstreak_dialog_on_player\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::flush_killstreak_dialog_on_player(${1:killstreakId})"},
	{ "trigger": "killstreak_dialog_queued\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::killstreak_dialog_queued(${1:dialogKey}, ${2:killstreakType}, ${3:killstreakId})"},
	{ "trigger": "flush_objective_dialog\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::flush_objective_dialog(${1:objectiveKey})"},
	{ "trigger": "flush_objective_dialog_on_player\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::flush_objective_dialog_on_player(${1:objectiveKey})"},
	{ "trigger": "flush_leader_dialog_key\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::flush_leader_dialog_key(${1:dialogKey})"},
	{ "trigger": "flush_leader_dialog_key_on_player\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::flush_leader_dialog_key_on_player(${1:dialogKey})"},
	{ "trigger": "play_taacom_dialog\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::play_taacom_dialog(${1:dialogKey}, ${2:killstreakType}, ${3:killstreakId})"},
	{ "trigger": "killstreak_dialog_on_player\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::killstreak_dialog_on_player(${1:dialogKey}, ${2:killstreakType}, ${3:killstreakId}, ${4:pilotIndex})"},
	{ "trigger": "wait_for_player_dialog\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::wait_for_player_dialog()"},
	{ "trigger": "play_next_killstreak_dialog\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::play_next_killstreak_dialog()"},
	{ "trigger": "wait_next_killstreak_dialog\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::wait_next_killstreak_dialog()"},
	{ "trigger": "leader_dialog_for_other_teams\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::leader_dialog_for_other_teams(${1:dialogKey}, ${2:skipTeam}, ${3:objectiveKey}, ${4:killstreakId}, ${5:dialogBufferKey})"},
	{ "trigger": "leader_dialog\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::leader_dialog(${1:dialogKey}, ${2:team}, ${3:excludeList}, ${4:objectiveKey}, ${5:killstreakId}, ${6:dialogBufferKey})"},
	{ "trigger": "leader_dialog_on_player\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::leader_dialog_on_player(${1:dialogKey}, ${2:objectiveKey}, ${3:killstreakId}, ${4:dialogBufferKey}, ${5:introDialog})"},
	{ "trigger": "play_next_leader_dialog\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::play_next_leader_dialog()"},
	{ "trigger": "wait_next_leader_dialog\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::wait_next_leader_dialog(${1:dialogBuffer})"},
	{ "trigger": "dialogkey_priority\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::dialogkey_priority(${1:dialogKey})"},
	{ "trigger": "play_equipment_destroyed_on_player\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::play_equipment_destroyed_on_player()"},
	{ "trigger": "play_equipment_hacked_on_player\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::play_equipment_hacked_on_player()"},
	{ "trigger": "get_commander_dialog_alias\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::get_commander_dialog_alias(${1:dialogKey})"},
	{ "trigger": "get_dialog_bundle_alias\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::get_dialog_bundle_alias(${1:dialogBundle}, ${2:dialogKey})"},
	{ "trigger": "is_team_winning\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::is_team_winning(${1:checkTeam})"},
	{ "trigger": "announce_team_is_winning\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::announce_team_is_winning()"},
	{ "trigger": "play_2d_on_team\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::play_2d_on_team(${1:alias}, ${2:team})"},
	{ "trigger": "get_round_switch_dialog\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::get_round_switch_dialog(${1:switchType})"},
	{ "trigger": "post_match_snapshot_watcher\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::post_match_snapshot_watcher()"},
	{ "trigger": "announcerController\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::announcerController()"},
	{ "trigger": "sndMusicFunctions\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::sndMusicFunctions()"},
	{ "trigger": "sndMusicSetRandomizer\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::sndMusicSetRandomizer()"},
	{ "trigger": "sndMusicUnlock\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::sndMusicUnlock()"},
	{ "trigger": "sndMusicTimesOut\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::sndMusicTimesOut()"},
	{ "trigger": "sndMusicHalfway\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::sndMusicHalfway()"},
	{ "trigger": "sndMusicTimeLimitWatcher\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::sndMusicTimeLimitWatcher()"},
	{ "trigger": "set_music_on_team\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::set_music_on_team(${1:state}, ${2:team = \"both\"}, ${3:wait_time = 0}, ${4:save_state = false}, ${5:return_state = false})"},
	{ "trigger": "set_music_on_player\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::set_music_on_player(${1:state}, ${2:wait_time = 0}, ${3:save_state = false}, ${4:return_state = false})"},
	{ "trigger": "set_music_global\t#using scripts\\mp\\gametypes\\_globallogic_audio;", "contents": "globallogic_audio::set_music_global(${1:state}, ${2:wait_time = 0}, ${3:save_state = false}, ${4:return_state = false})"},
	{ "trigger": "on_player_connect\t#using scripts\\mp\\gametypes\\_menus;", "contents": "menus::on_player_connect()"},
	{ "trigger": "on_menu_response\t#using scripts\\mp\\gametypes\\_menus;", "contents": "menus::on_menu_response()"},
	{ "trigger": "quadtank_update_difficulty\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::quadtank_update_difficulty()"},
	{ "trigger": "defaultRole\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::defaultRole()"},
	{ "trigger": "quadtank_off\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::quadtank_off()"},
	{ "trigger": "quadtank_on\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::quadtank_on()"},
	{ "trigger": "state_off_enter\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::state_off_enter(${1:params})"},
	{ "trigger": "state_off_exit\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::state_off_exit(${1:params})"},
	{ "trigger": "bootup\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::bootup()"},
	{ "trigger": "pain_update\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::pain_update(${1:params})"},
	{ "trigger": "state_scripted_update\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::state_scripted_update(${1:params})"},
	{ "trigger": "state_driving_update\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::state_driving_update(${1:params})"},
	{ "trigger": "quadtank_exit_vehicle\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::quadtank_exit_vehicle()"},
	{ "trigger": "state_combat_update\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::state_combat_update(${1:params})"},
	{ "trigger": "state_combat_exit\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::state_combat_exit(${1:params})"},
	{ "trigger": "quadtank_death\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::quadtank_death(${1:params})"},
	{ "trigger": "quadtank_emped\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::quadtank_emped(${1:params})"},
	{ "trigger": "trophy_disabled\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::trophy_disabled()"},
	{ "trigger": "trophy_destroyed\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::trophy_destroyed()"},
	{ "trigger": "quadtank_disabletrophy\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::quadtank_disabletrophy()"},
	{ "trigger": "quadtank_enabletrophy\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::quadtank_enabletrophy()"},
	{ "trigger": "quadtank_side_turrets_forward\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::quadtank_side_turrets_forward()"},
	{ "trigger": "quadtank_turret_scan\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::quadtank_turret_scan(${1:scan_forever})"},
	{ "trigger": "set_side_turrets_enabled\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::set_side_turrets_enabled(${1:on})"},
	{ "trigger": "set_detonation_time\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::set_detonation_time(${1:target})"},
	{ "trigger": "quadtank_weapon_think_cannon\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::quadtank_weapon_think_cannon()"},
	{ "trigger": "Attack_Thread_rocket\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::Attack_Thread_rocket()"},
	{ "trigger": "trigger_player_shock_fx\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::trigger_player_shock_fx()"},
	{ "trigger": "path_update_interrupt\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::path_update_interrupt()"},
	{ "trigger": "Movement_Thread_Wander\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::Movement_Thread_Wander()"},
	{ "trigger": "quadtank_movementupdate\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::quadtank_movementupdate()"},
	{ "trigger": "quadtank_player_fireupdate\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::quadtank_player_fireupdate()"},
	{ "trigger": "do_melee\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::do_melee(${1:shouldDoDamage}, ${2:enemy})"},
	{ "trigger": "quadtank_automelee_update\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::quadtank_automelee_update()"},
	{ "trigger": "quadtank_destroyturret\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::quadtank_destroyturret(${1:index})"},
	{ "trigger": "monitor_enter_vehicle\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::monitor_enter_vehicle()"},
	{ "trigger": "QuadtankCallback_VehicleDamage\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::QuadtankCallback_VehicleDamage(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:vDamageOrigin}, ${11:psOffsetTime}, ${12:damageFromUnderneath}, ${13:modelIndex}, ${14:partName}, ${15:vSurfaceNormal})"},
	{ "trigger": "quadtank_set_team\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::quadtank_set_team(${1:team})"},
	{ "trigger": "remove_repulsor\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::remove_repulsor()"},
	{ "trigger": "repulsor_fx\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::repulsor_fx()"},
	{ "trigger": "quadtank_projectile_watcher\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::quadtank_projectile_watcher()"},
	{ "trigger": "turn_off_laser_after\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::turn_off_laser_after(${1:time})"},
	{ "trigger": "side_turret_is_target_in_view_score\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::side_turret_is_target_in_view_score(${1:v_target}, ${2:n_index})"},
	{ "trigger": "_get_best_target_quadtank_side_turret\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::_get_best_target_quadtank_side_turret(${1:a_potential_targets}, ${2:n_index})"},
	{ "trigger": "quadtank_weakpoint_display\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::quadtank_weakpoint_display(${1:state})"},
	{ "trigger": "footstep_handler\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::footstep_handler()"},
	{ "trigger": "javeline_incoming\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::javeline_incoming(${1:projectile})"},
	{ "trigger": "railgun_sound\t#using scripts\\mp\\vehicles\\_quadtank;", "contents": "quadtank::railgun_sound(${1:projectile})"},
	{ "trigger": "setupTeam\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::setupTeam(${1:team})"},
	{ "trigger": "onStartGameType\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::onStartGameType()"},
	{ "trigger": "watch_for_game_end\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::watch_for_game_end()"},
	{ "trigger": "on_player_connect\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::on_player_connect()"},
	{ "trigger": "on_menu_response\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::on_menu_response()"},
	{ "trigger": "onSpawnPlayer\t#using scripts\\mp\\gametypes\\fr; self == player", "contents": "fr::onSpawnPlayer(${1:predictedSpawn})"},
	{ "trigger": "on_player_damage\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::on_player_damage(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:modelIndex}, ${11:psOffsetTime})"},
	{ "trigger": "trackPlayerOrigin\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::trackPlayerOrigin()"},
	{ "trigger": "readHighScores\t#using scripts\\mp\\gametypes\\fr; self == player", "contents": "fr::readHighScores()"},
	{ "trigger": "updateHighScores\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::updateHighScores()"},
	{ "trigger": "activateTrack\t#using scripts\\mp\\gametypes\\fr; self == player", "contents": "fr::activateTrack(${1:trackIndex})"},
	{ "trigger": "startRun\t#using scripts\\mp\\gametypes\\fr; self == player", "contents": "fr::startRun()"},
	{ "trigger": "onCheckpointTrigger\t#using scripts\\mp\\gametypes\\fr; self == trigger", "contents": "fr::onCheckpointTrigger(${1:player}, ${2:endOnString})"},
	{ "trigger": "leaveCheckpointTrigger\t#using scripts\\mp\\gametypes\\fr; self == trigger", "contents": "fr::leaveCheckpointTrigger(${1:player})"},
	{ "trigger": "get_current_track_time\t#using scripts\\mp\\gametypes\\fr; self == checkpoint trigger", "contents": "fr::get_current_track_time(${1:player})"},
	{ "trigger": "watchCheckpointTrigger\t#using scripts\\mp\\gametypes\\fr; self == checkpoint trigger", "contents": "fr::watchCheckpointTrigger()"},
	{ "trigger": "watchDeathTrigger\t#using scripts\\mp\\gametypes\\fr; self == death trigger", "contents": "fr::watchDeathTrigger()"},
	{ "trigger": "add_current_run_to_high_scores\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::add_current_run_to_high_scores(${1:player})"},
	{ "trigger": "watchGoalTrigger\t#using scripts\\mp\\gametypes\\fr; self == goal trigger", "contents": "fr::watchGoalTrigger()"},
	{ "trigger": "freeze\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::freeze()"},
	{ "trigger": "unfreeze\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::unfreeze()"},
	{ "trigger": "setup_weapon_targets\t#using scripts\\mp\\gametypes\\fr; self == checkpoint", "contents": "fr::setup_weapon_targets()"},
	{ "trigger": "watch_target_trigger_thread\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::watch_target_trigger_thread(${1:weaponObject})"},
	{ "trigger": "turn_off_target\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::turn_off_target(${1:weapon})"},
	{ "trigger": "blocker_enable\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::blocker_enable()"},
	{ "trigger": "blocker_disable\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::blocker_disable()"},
	{ "trigger": "reset_targets\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::reset_targets()"},
	{ "trigger": "reset_all_targets\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::reset_all_targets()"},
	{ "trigger": "play_fault_VO\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::play_fault_VO()"},
	{ "trigger": "faultDeath\t#using scripts\\mp\\gametypes\\fr; self == player", "contents": "fr::faultDeath()"},
	{ "trigger": "dpad_up_pressed\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::dpad_up_pressed()"},
	{ "trigger": "dpad_down_pressed\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::dpad_down_pressed()"},
	{ "trigger": "dpad_right_pressed\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::dpad_right_pressed()"},
	{ "trigger": "dpad_left_pressed\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::dpad_left_pressed()"},
	{ "trigger": "end_game_state\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::end_game_state()"},
	{ "trigger": "watchTrackSwitch\t#using scripts\\mp\\gametypes\\fr; self == player", "contents": "fr::watchTrackSwitch()"},
	{ "trigger": "watchUserRespawn\t#using scripts\\mp\\gametypes\\fr; self == player", "contents": "fr::watchUserRespawn()"},
	{ "trigger": "ignoreBulletsFired\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::ignoreBulletsFired(${1:weapon})"},
	{ "trigger": "watchWeaponFire\t#using scripts\\mp\\gametypes\\fr; self == player", "contents": "fr::watchWeaponFire()"},
	{ "trigger": "getGroundPointForOrigin\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::getGroundPointForOrigin(${1:position})"},
	{ "trigger": "watchStartRun\t#using scripts\\mp\\gametypes\\fr; self == start trigger", "contents": "fr::watchStartRun(${1:player})"},
	{ "trigger": "respawnAtActiveCheckpoint\t#using scripts\\mp\\gametypes\\fr; self == player", "contents": "fr::respawnAtActiveCheckpoint()"},
	{ "trigger": "giveCustomLoadout\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::giveCustomLoadout()"},
	{ "trigger": "set_high_score_stat\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::set_high_score_stat(${1:trackIndex}, ${2:slot}, ${3:stat}, ${4:value})"},
	{ "trigger": "write_high_scores_stats\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::write_high_scores_stats(${1:start_index})"},
	{ "trigger": "write_checkpoint_times\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::write_checkpoint_times()"},
	{ "trigger": "get_high_score_stat\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::get_high_score_stat(${1:trackIndex}, ${2:slot}, ${3:stat})"},
	{ "trigger": "create_high_score_struct\t#using scripts\\mp\\gametypes\\fr; self == player", "contents": "fr::create_high_score_struct(${1:time}, ${2:faults}, ${3:retries}, ${4:bulletPenalty})"},
	{ "trigger": "get_stats_for_track\t#using scripts\\mp\\gametypes\\fr; self == player", "contents": "fr::get_stats_for_track(${1:trackIndex}, ${2:slot})"},
	{ "trigger": "get_checkpoint_times_for_track\t#using scripts\\mp\\gametypes\\fr; self == player", "contents": "fr::get_checkpoint_times_for_track(${1:trackIndex})"},
	{ "trigger": "get_top_scores_stats\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::get_top_scores_stats()"},
	{ "trigger": "take_all_player_weapons\t#using scripts\\mp\\gametypes\\fr; self == player", "contents": "fr::take_all_player_weapons(${1:only_default}, ${2:immediate})"},
	{ "trigger": "freerunMusic\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::freerunMusic(${1:start=true})"},
	{ "trigger": "_tutorial_mode\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::_tutorial_mode(${1:b_tutorial_mode})"},
	{ "trigger": "take_players_out_of_tutorial_mode\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::take_players_out_of_tutorial_mode()"},
	{ "trigger": "put_players_in_tutorial_mode\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::put_players_in_tutorial_mode()"},
	{ "trigger": "enable_all_tutorial_triggers\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::enable_all_tutorial_triggers()"},
	{ "trigger": "activate_tutorial_mode\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::activate_tutorial_mode()"},
	{ "trigger": "setup_tutorial\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::setup_tutorial()"},
	{ "trigger": "watchTutorialTrigger\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::watchTutorialTrigger()"},
	{ "trigger": "stop_tutorial_when_restarting_track\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::stop_tutorial_when_restarting_track()"},
	{ "trigger": "start_tutorial\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::start_tutorial(${1:tutorial})"},
	{ "trigger": "stop_tutorial_vo\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::stop_tutorial_vo()"},
	{ "trigger": "play_tutorial_vo\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::play_tutorial_vo(${1:aliasstring})"},
	{ "trigger": "play_tutorial_vo_with_hint\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::play_tutorial_vo_with_hint(${1:aliasstring}, ${2:text})"},
	{ "trigger": "_show_tutorial_hint_with_vo\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::_show_tutorial_hint_with_vo(${1:text}, ${2:time}, ${3:unlock_player})"},
	{ "trigger": "show_tutorial_hint\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::show_tutorial_hint(${1:text}, ${2:time}, ${3:unlock_player})"},
	{ "trigger": "show_tutorial_hint_with_full_movement\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::show_tutorial_hint_with_full_movement(${1:text}, ${2:time})"},
	{ "trigger": "register_tutorials\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::register_tutorials()"},
	{ "trigger": "tutorial_01\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_01()"},
	{ "trigger": "tutorial_02\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_02()"},
	{ "trigger": "tutorial_03\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_03()"},
	{ "trigger": "tutorial_06\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_06()"},
	{ "trigger": "tutorial_08\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_08()"},
	{ "trigger": "tutorial_09\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_09()"},
	{ "trigger": "tutorial_10\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_10()"},
	{ "trigger": "tutorial_10a\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_10a()"},
	{ "trigger": "tutorial_12\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_12()"},
	{ "trigger": "tutorial_12a\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_12a()"},
	{ "trigger": "tutorial_13\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_13()"},
	{ "trigger": "tutorial_14\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_14()"},
	{ "trigger": "tutorial_15\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_15()"},
	{ "trigger": "tutorial_16\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_16()"},
	{ "trigger": "tutorial_17\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_17()"},
	{ "trigger": "tutorial_17a\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_17a()"},
	{ "trigger": "tutorial_18\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_18()"},
	{ "trigger": "tutorial_19\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_19()"},
	{ "trigger": "tutorial_20\t#using scripts\\mp\\gametypes\\fr;", "contents": "fr::tutorial_20()"},
	{ "trigger": "set_default_callbacks\t#using scripts\\mp\\_callbacks;", "contents": "callback::set_default_callbacks()"},
	{ "trigger": "onPrecacheGameType\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::onPrecacheGameType()"},
	{ "trigger": "sd_getTeamKillPenalty\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::sd_getTeamKillPenalty(${1:eInflictor}, ${2:attacker}, ${3:sMeansOfDeath}, ${4:weapon})"},
	{ "trigger": "sd_getTeamKillScore\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::sd_getTeamKillScore(${1:eInflictor}, ${2:attacker}, ${3:sMeansOfDeath}, ${4:weapon})"},
	{ "trigger": "onRoundSwitch\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::onRoundSwitch()"},
	{ "trigger": "getBetterTeam\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::getBetterTeam()"},
	{ "trigger": "onStartGameType\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::onStartGameType()"},
	{ "trigger": "onSpawnPlayer\t#using scripts\\mp\\gametypes\\sd; self == player", "contents": "sd::onSpawnPlayer(${1:predictedSpawn})"},
	{ "trigger": "sd_playerSpawnedCB\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::sd_playerSpawnedCB()"},
	{ "trigger": "onPlayerKilled\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::onPlayerKilled(${1:eInflictor}, ${2:attacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime}, ${9:deathAnimDuration})"},
	{ "trigger": "checkAllowSpectating\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::checkAllowSpectating()"},
	{ "trigger": "sd_endGame\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::sd_endGame(${1:winningTeam}, ${2:endReasonText})"},
	{ "trigger": "sd_endGameWithKillcam\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::sd_endGameWithKillcam(${1:winningTeam}, ${2:endReasonText})"},
	{ "trigger": "onDeadEvent\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::onDeadEvent(${1:team})"},
	{ "trigger": "onOneLeftEvent\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::onOneLeftEvent(${1:team})"},
	{ "trigger": "onTimeLimit\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::onTimeLimit()"},
	{ "trigger": "warnLastPlayer\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::warnLastPlayer(${1:team})"},
	{ "trigger": "giveLastAttackerWarning\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::giveLastAttackerWarning(${1:team})"},
	{ "trigger": "updateGametypeDvars\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::updateGametypeDvars()"},
	{ "trigger": "bombs\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::bombs()"},
	{ "trigger": "setBombOverheatingAfterWeaponChange\t#using scripts\\mp\\gametypes\\sd; self == player", "contents": "sd::setBombOverheatingAfterWeaponChange(${1:useObject}, ${2:overheated}, ${3:heat})"},
	{ "trigger": "onBeginUse\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::onBeginUse(${1:player})"},
	{ "trigger": "onEndUse\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::onEndUse(${1:team}, ${2:player}, ${3:result})"},
	{ "trigger": "onCantUse\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::onCantUse(${1:player})"},
	{ "trigger": "onUsePlantObject\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::onUsePlantObject(${1:player})"},
	{ "trigger": "onUseDefuseObject\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::onUseDefuseObject(${1:player})"},
	{ "trigger": "onDrop\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::onDrop(${1:player})"},
	{ "trigger": "onPickup\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::onPickup(${1:player})"},
	{ "trigger": "onReset\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::onReset()"},
	{ "trigger": "bombPlantedMusicDelay\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::bombPlantedMusicDelay()"},
	{ "trigger": "bombPlanted\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::bombPlanted(${1:destroyedObj}, ${2:player})"},
	{ "trigger": "BombTimerWait\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::BombTimerWait()"},
	{ "trigger": "bombDefused\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::bombDefused(${1:defusedObject}, ${2:player})"},
	{ "trigger": "sd_isKillBoosting\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::sd_isKillBoosting()"},
	{ "trigger": "figureOutGameTypeFriendlyFire\t#using scripts\\mp\\gametypes\\sd;", "contents": "sd::figureOutGameTypeFriendlyFire(${1:victim})"},
	{ "trigger": "end_health_regen\t#using scripts\\mp\\gametypes\\_healthoverlay;", "contents": "healthoverlay::end_health_regen()"},
	{ "trigger": "player_health_regen\t#using scripts\\mp\\gametypes\\_healthoverlay;", "contents": "healthoverlay::player_health_regen()"},
	{ "trigger": "decay_player_damages\t#using scripts\\mp\\gametypes\\_healthoverlay;", "contents": "healthoverlay::decay_player_damages(${1:decay})"},
	{ "trigger": "player_breathing_sound\t#using scripts\\mp\\gametypes\\_healthoverlay;", "contents": "healthoverlay::player_breathing_sound(${1:healthcap})"},
	{ "trigger": "player_heartbeat_sound\t#using scripts\\mp\\gametypes\\_healthoverlay;", "contents": "healthoverlay::player_heartbeat_sound(${1:healthcap})"},
	{ "trigger": "getBaseWeaponParam\t#using scripts\\mp\\gametypes\\_weapon_utils;", "contents": "weapon_utils::getBaseWeaponParam(${1:weapon})"},
	{ "trigger": "testMenu\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::testMenu()"},
	{ "trigger": "testShock\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::testShock()"},
	{ "trigger": "testHPs\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::testHPs()"},
	{ "trigger": "timeUntilRoundEnd\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::timeUntilRoundEnd()"},
	{ "trigger": "registerPostRoundEvent\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::registerPostRoundEvent(${1:eventFunc})"},
	{ "trigger": "executePostRoundEvents\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::executePostRoundEvents()"},
	{ "trigger": "getValueInRange\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::getValueInRange(${1:value}, ${2:minValue}, ${3:maxValue})"},
	{ "trigger": "isValidClass\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::isValidClass(${1:c})"},
	{ "trigger": "playTickingSound\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::playTickingSound(${1:gametype_tick_sound})"},
	{ "trigger": "stopTickingSound\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::stopTickingSound()"},
	{ "trigger": "gameTimer\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::gameTimer()"},
	{ "trigger": "DisablePlayerRoundStartDelay\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::DisablePlayerRoundStartDelay()"},
	{ "trigger": "GetRoundStartDelay\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::GetRoundStartDelay()"},
	{ "trigger": "ApplyRoundStartDelay\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::ApplyRoundStartDelay()"},
	{ "trigger": "getTimePassed\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::getTimePassed()"},
	{ "trigger": "pauseTimer\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::pauseTimer(${1:pausePlayableTimer = false})"},
	{ "trigger": "resumeTimer\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::resumeTimer()"},
	{ "trigger": "resumeTimerDiscardOverride\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::resumeTimerDiscardOverride(${1:discardTime})"},
	{ "trigger": "GetTeamScoreForRound\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::GetTeamScoreForRound(${1:team})"},
	{ "trigger": "getScorePerMinute\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::getScorePerMinute(${1:team})"},
	{ "trigger": "getEstimatedTimeUntilScoreLimit\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::getEstimatedTimeUntilScoreLimit(${1:team})"},
	{ "trigger": "rumbler\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::rumbler()"},
	{ "trigger": "waitForTimeOrNotify\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::waitForTimeOrNotify(${1:time}, ${2:notifyname})"},
	{ "trigger": "waitForTimeOrNotifyNoArtillery\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::waitForTimeOrNotifyNoArtillery(${1:time}, ${2:notifyname})"},
	{ "trigger": "isHeadShot\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::isHeadShot(${1:weapon}, ${2:sHitLoc}, ${3:sMeansOfDeath}, ${4:eInflictor})"},
	{ "trigger": "getHitLocHeight\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::getHitLocHeight(${1:sHitLoc})"},
	{ "trigger": "isExcluded\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::isExcluded(${1:entity}, ${2:entityList})"},
	{ "trigger": "waitForTimeOrNotifies\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::waitForTimeOrNotifies(${1:desiredDelay})"},
	{ "trigger": "logTeamWinString\t#using scripts\\mp\\gametypes\\_globallogic_utils;", "contents": "globallogic_utils::logTeamWinString(${1:wintype}, ${2:winner})"},
	{ "trigger": "register\t#using scripts\\mp\\killstreaks\\_helicopter_guard;", "contents": "helicopter_guard::register()"},
	{ "trigger": "tryUseheliGuardSupport\t#using scripts\\mp\\killstreaks\\_helicopter_guard; self == player", "contents": "helicopter_guard::tryUseheliGuardSupport(${1:lifeId})"},
	{ "trigger": "ConfigureTeamPost\t#using scripts\\mp\\killstreaks\\_helicopter_guard;", "contents": "helicopter_guard::ConfigureTeamPost(${1:owner}, ${2:isHacked})"},
	{ "trigger": "createHeliGuardSupport\t#using scripts\\mp\\killstreaks\\_helicopter_guard;", "contents": "helicopter_guard::createHeliGuardSupport(${1:lifeId}, ${2:killstreak_id})"},
	{ "trigger": "getMeshHeight\t#using scripts\\mp\\killstreaks\\_helicopter_guard;", "contents": "helicopter_guard::getMeshHeight(${1:littleBird}, ${2:owner})"},
	{ "trigger": "startHeliGuardSupport\t#using scripts\\mp\\killstreaks\\_helicopter_guard; self == player", "contents": "helicopter_guard::startHeliGuardSupport(${1:littleBird}, ${2:lifeId})"},
	{ "trigger": "heliGuardSupport_followPlayer\t#using scripts\\mp\\killstreaks\\_helicopter_guard; self == heliGuard", "contents": "helicopter_guard::heliGuardSupport_followPlayer()"},
	{ "trigger": "heliGuardSupport_moveToPlayer\t#using scripts\\mp\\killstreaks\\_helicopter_guard; self == heliGuard", "contents": "helicopter_guard::heliGuardSupport_moveToPlayer()"},
	{ "trigger": "heliGuardSupport_moveToPlayerVertical\t#using scripts\\mp\\killstreaks\\_helicopter_guard; self == heli", "contents": "helicopter_guard::heliGuardSupport_moveToPlayerVertical(${1:maxMeshHeight})"},
	{ "trigger": "heliGuardSupport_watchForEarlyLeave\t#using scripts\\mp\\killstreaks\\_helicopter_guard;", "contents": "helicopter_guard::heliGuardSupport_watchForEarlyLeave()"},
	{ "trigger": "heliGuardSupport_watchOwnerDamage\t#using scripts\\mp\\killstreaks\\_helicopter_guard; self == heliGuard", "contents": "helicopter_guard::heliGuardSupport_watchOwnerDamage()"},
	{ "trigger": "heliGuardSupport_watchRoundEnd\t#using scripts\\mp\\killstreaks\\_helicopter_guard;", "contents": "helicopter_guard::heliGuardSupport_watchRoundEnd()"},
	{ "trigger": "heliGuardSupport_leave\t#using scripts\\mp\\killstreaks\\_helicopter_guard;", "contents": "helicopter_guard::heliGuardSupport_leave()"},
	{ "trigger": "heliDestroyed\t#using scripts\\mp\\killstreaks\\_helicopter_guard;", "contents": "helicopter_guard::heliDestroyed()"},
	{ "trigger": "lbExplode\t#using scripts\\mp\\killstreaks\\_helicopter_guard;", "contents": "helicopter_guard::lbExplode()"},
	{ "trigger": "lbSpin\t#using scripts\\mp\\killstreaks\\_helicopter_guard;", "contents": "helicopter_guard::lbSpin(${1:speed})"},
	{ "trigger": "trail_fx\t#using scripts\\mp\\killstreaks\\_helicopter_guard;", "contents": "helicopter_guard::trail_fx(${1:trail_fx}, ${2:trail_tag}, ${3:stop_notify})"},
	{ "trigger": "removeLittlebird\t#using scripts\\mp\\killstreaks\\_helicopter_guard;", "contents": "helicopter_guard::removeLittlebird()"},
	{ "trigger": "heliGuardSupport_watchSAMProximity\t#using scripts\\mp\\killstreaks\\_helicopter_guard; self == level", "contents": "helicopter_guard::heliGuardSupport_watchSAMProximity(${1:player}, ${2:missileTeam}, ${3:missileTarget}, ${4:missileGroup})"},
	{ "trigger": "heliGuardSupport_getClosestStartNode\t#using scripts\\mp\\killstreaks\\_helicopter_guard;", "contents": "helicopter_guard::heliGuardSupport_getClosestStartNode(${1:pos})"},
	{ "trigger": "heliGuardSupport_getClosestNode\t#using scripts\\mp\\killstreaks\\_helicopter_guard;", "contents": "helicopter_guard::heliGuardSupport_getClosestNode(${1:pos})"},
	{ "trigger": "heliGuardSupport_getClosestLinkedNode\t#using scripts\\mp\\killstreaks\\_helicopter_guard; self == heliGuard", "contents": "helicopter_guard::heliGuardSupport_getClosestLinkedNode(${1:pos})"},
	{ "trigger": "heliGuardSupport_arrayContains\t#using scripts\\mp\\killstreaks\\_helicopter_guard;", "contents": "helicopter_guard::heliGuardSupport_arrayContains(${1:array}, ${2:compare})"},
	{ "trigger": "heliGuardSupport_getLinkedStructs\t#using scripts\\mp\\killstreaks\\_helicopter_guard;", "contents": "helicopter_guard::heliGuardSupport_getLinkedStructs()"},
	{ "trigger": "heliGuardSupport_setAirStartNodes\t#using scripts\\mp\\killstreaks\\_helicopter_guard;", "contents": "helicopter_guard::heliGuardSupport_setAirStartNodes()"},
	{ "trigger": "heliGuardSupport_setAirNodeMesh\t#using scripts\\mp\\killstreaks\\_helicopter_guard;", "contents": "helicopter_guard::heliGuardSupport_setAirNodeMesh()"},
	{ "trigger": "heliGuardSupport_attackTargets\t#using scripts\\mp\\killstreaks\\_helicopter_guard; self == turret", "contents": "helicopter_guard::heliGuardSupport_attackTargets()"},
	{ "trigger": "heliGuardSupport_fireStart\t#using scripts\\mp\\killstreaks\\_helicopter_guard; self == turret", "contents": "helicopter_guard::heliGuardSupport_fireStart()"},
	{ "trigger": "heliGuardSupport_fireStop\t#using scripts\\mp\\killstreaks\\_helicopter_guard; self == turret", "contents": "helicopter_guard::heliGuardSupport_fireStop(${1:targetEnt})"},
	{ "trigger": "remote_mortar_killstreak\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::remote_mortar_killstreak(${1:hardpointType})"},
	{ "trigger": "remote_killstreak_copilot\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::remote_killstreak_copilot(${1:voice})"},
	{ "trigger": "remote_killstreak_abort\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::remote_killstreak_abort()"},
	{ "trigger": "remote_owner_teamKillKicked\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::remote_owner_teamKillKicked(${1:hardpointtype})"},
	{ "trigger": "remote_owner_exit\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::remote_owner_exit()"},
	{ "trigger": "remote_killstreak_game_end\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::remote_killstreak_game_end()"},
	{ "trigger": "remote_mortar_spawn\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::remote_mortar_spawn()"},
	{ "trigger": "rotateRig\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::rotateRig(${1:clockwise})"},
	{ "trigger": "remote_mortar_visibility\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::remote_mortar_visibility()"},
	{ "trigger": "play_lockon_sounds\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::play_lockon_sounds(${1:player})"},
	{ "trigger": "enemy_locking\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::enemy_locking()"},
	{ "trigger": "enemy_locked\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::enemy_locked()"},
	{ "trigger": "create_remote_mortar_hud\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::create_remote_mortar_hud(${1:remote})"},
	{ "trigger": "fade_out_hint_hud\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::fade_out_hint_hud(${1:remote})"},
	{ "trigger": "remove_hud\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::remove_hud()"},
	{ "trigger": "remote_killstreak_end\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::remote_killstreak_end(${1:explode}, ${2:disconnected})"},
	{ "trigger": "player_linkto_remote\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::player_linkto_remote(${1:remote})"},
	{ "trigger": "player_center_view\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::player_center_view(${1:org})"},
	{ "trigger": "player_aim_think\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::player_aim_think(${1:remote})"},
	{ "trigger": "player_fire_think\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::player_fire_think(${1:remote})"},
	{ "trigger": "remote_missile_life\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::remote_missile_life(${1:remote})"},
	{ "trigger": "remote_damage_think\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::remote_damage_think()"},
	{ "trigger": "remote_leave\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::remote_leave()"},
	{ "trigger": "play_remote_fx\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::play_remote_fx()"},
	{ "trigger": "play_afterburner_fx\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::play_afterburner_fx()"},
	{ "trigger": "remote_explode\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::remote_explode()"},
	{ "trigger": "visionSwitch\t#using scripts\\mp\\killstreaks\\_remotemortar;", "contents": "remotemortar::visionSwitch()"},
	{ "trigger": "start_gametype\t#using scripts\\mp\\_challenges;", "contents": "challenges::start_gametype()"},
	{ "trigger": "on_player_connect\t#using scripts\\mp\\_challenges;", "contents": "challenges::on_player_connect()"},
	{ "trigger": "addSpecialistUsedStatOnConnect\t#using scripts\\mp\\_challenges;", "contents": "challenges::addSpecialistUsedStatOnConnect()"},
	{ "trigger": "spawnWatcher\t#using scripts\\mp\\_challenges;", "contents": "challenges::spawnWatcher()"},
	{ "trigger": "watchScavengeLethal\t#using scripts\\mp\\_challenges;", "contents": "challenges::watchScavengeLethal()"},
	{ "trigger": "watchDoublejump\t#using scripts\\mp\\_challenges;", "contents": "challenges::watchDoublejump()"},
	{ "trigger": "watchJump\t#using scripts\\mp\\_challenges;", "contents": "challenges::watchJump()"},
	{ "trigger": "watchSwimming\t#using scripts\\mp\\_challenges;", "contents": "challenges::watchSwimming()"},
	{ "trigger": "watchWallrun\t#using scripts\\mp\\_challenges;", "contents": "challenges::watchWallrun()"},
	{ "trigger": "watchSlide\t#using scripts\\mp\\_challenges;", "contents": "challenges::watchSlide()"},
	{ "trigger": "watchSprint\t#using scripts\\mp\\_challenges;", "contents": "challenges::watchSprint()"},
	{ "trigger": "challengeKills\t#using scripts\\mp\\_challenges;", "contents": "challenges::challengeKills(${1:data})"},
	{ "trigger": "on_player_spawn\t#using scripts\\mp\\_challenges;", "contents": "challenges::on_player_spawn()"},
	{ "trigger": "get_challenge_stat\t#using scripts\\mp\\_challenges;", "contents": "challenges::get_challenge_stat(${1:stat_name})"},
	{ "trigger": "force_challenge_stat\t#using scripts\\mp\\_challenges;", "contents": "challenges::force_challenge_stat(${1:stat_name}, ${2:stat_value})"},
	{ "trigger": "get_challenge_group_stat\t#using scripts\\mp\\_challenges;", "contents": "challenges::get_challenge_group_stat(${1:group_name}, ${2:stat_name})"},
	{ "trigger": "fix_challenge_stats_on_spawn\t#using scripts\\mp\\_challenges;", "contents": "challenges::fix_challenge_stats_on_spawn()"},
	{ "trigger": "fix_TU6_weapon_for_diamond\t#using scripts\\mp\\_challenges;", "contents": "challenges::fix_TU6_weapon_for_diamond(${1:stat_name})"},
	{ "trigger": "fix_TU6_ar_garand\t#using scripts\\mp\\_challenges;", "contents": "challenges::fix_TU6_ar_garand()"},
	{ "trigger": "fix_TU6_pistol_shotgun\t#using scripts\\mp\\_challenges;", "contents": "challenges::fix_TU6_pistol_shotgun()"},
	{ "trigger": "completed_specific_challenge\t#using scripts\\mp\\_challenges;", "contents": "challenges::completed_specific_challenge(${1:target_value}, ${2:challenge_name})"},
	{ "trigger": "tally_completed_challenge\t#using scripts\\mp\\_challenges;", "contents": "challenges::tally_completed_challenge(${1:target_value}, ${2:challenge_name})"},
	{ "trigger": "TU7_fix_100_percenter\t#using scripts\\mp\\_challenges;", "contents": "challenges::TU7_fix_100_percenter()"},
	{ "trigger": "TU7_fix_mastery_perk_2\t#using scripts\\mp\\_challenges;", "contents": "challenges::TU7_fix_mastery_perk_2()"},
	{ "trigger": "getBaseWeapon\t#using scripts\\mp\\_challenges;", "contents": "challenges::getBaseWeapon(${1:weapon})"},
	{ "trigger": "str_strip_lh_from_crossbow\t#using scripts\\mp\\_challenges;", "contents": "challenges::str_strip_lh_from_crossbow(${1:str})"},
	{ "trigger": "str_strip_lh_or_dw\t#using scripts\\mp\\_challenges;", "contents": "challenges::str_strip_lh_or_dw(${1:str})"},
	{ "trigger": "checkKillStreak5\t#using scripts\\mp\\_challenges;", "contents": "challenges::checkKillStreak5(${1:baseWeapon}, ${2:player})"},
	{ "trigger": "checkDualWield\t#using scripts\\mp\\_challenges;", "contents": "challenges::checkDualWield(${1:baseWeapon}, ${2:player}, ${3:attacker}, ${4:time}, ${5:attackerWasSprinting}, ${6:attacker_sprint_end})"},
	{ "trigger": "challengeGameEndMP\t#using scripts\\mp\\_challenges;", "contents": "challenges::challengeGameEndMP(${1:data})"},
	{ "trigger": "killedBaseOffender\t#using scripts\\mp\\_challenges;", "contents": "challenges::killedBaseOffender(${1:objective}, ${2:weapon})"},
	{ "trigger": "killedBaseDefender\t#using scripts\\mp\\_challenges;", "contents": "challenges::killedBaseDefender(${1:objective})"},
	{ "trigger": "waitTillTimeoutOrDeath\t#using scripts\\mp\\_challenges;", "contents": "challenges::waitTillTimeoutOrDeath(${1:timeout})"},
	{ "trigger": "killstreak_30_noscorestreaks\t#using scripts\\mp\\_challenges;", "contents": "challenges::killstreak_30_noscorestreaks()"},
	{ "trigger": "heroAbilityActivateNearDeath\t#using scripts\\mp\\_challenges;", "contents": "challenges::heroAbilityActivateNearDeath()"},
	{ "trigger": "checkForHeroSurvival\t#using scripts\\mp\\_challenges;", "contents": "challenges::checkForHeroSurvival()"},
	{ "trigger": "callbackEndHeroSpecialistEMP\t#using scripts\\mp\\_challenges;", "contents": "challenges::callbackEndHeroSpecialistEMP()"},
	{ "trigger": "calledInComlinkChopper\t#using scripts\\mp\\_challenges;", "contents": "challenges::calledInComlinkChopper()"},
	{ "trigger": "combat_robot_damage\t#using scripts\\mp\\_challenges;", "contents": "challenges::combat_robot_damage(${1:eAttacker}, ${2:combatRobotOwner})"},
	{ "trigger": "trackKillstreakSupportKills\t#using scripts\\mp\\_challenges;", "contents": "challenges::trackKillstreakSupportKills(${1:victim})"},
	{ "trigger": "monitorReloads\t#using scripts\\mp\\_challenges;", "contents": "challenges::monitorReloads()"},
	{ "trigger": "monitorGrenadeFire\t#using scripts\\mp\\_challenges;", "contents": "challenges::monitorGrenadeFire()"},
	{ "trigger": "watchWeaponChangeComplete\t#using scripts\\mp\\_challenges;", "contents": "challenges::watchWeaponChangeComplete()"},
	{ "trigger": "longDistanceKillMP\t#using scripts\\mp\\_challenges;", "contents": "challenges::longDistanceKillMP(${1:weapon})"},
	{ "trigger": "capturedObjectiveFunction\t#using scripts\\mp\\_challenges;", "contents": "challenges::capturedObjectiveFunction()"},
	{ "trigger": "watchWallRunTwoOppositeWallsNoGround\t#using scripts\\mp\\_challenges;", "contents": "challenges::watchWallRunTwoOppositeWallsNoGround()"},
	{ "trigger": "processSpecialistChallenge\t#using scripts\\mp\\_challenges;", "contents": "challenges::processSpecialistChallenge(${1:statName})"},
	{ "trigger": "flakjacketProtectedMP\t#using scripts\\mp\\_challenges;", "contents": "challenges::flakjacketProtectedMP(${1:weapon}, ${2:attacker})"},
	{ "trigger": "add_ball_return_trigger\t#using scripts\\mp\\gametypes\\_ball_utils;", "contents": "ball::add_ball_return_trigger(${1:trigger})"},
	{ "trigger": "precache\t#using scripts\\mp\\mp_freerun;", "contents": "mp_freerun::precache()"},
	{ "trigger": "speed_test\t#using scripts\\mp\\mp_freerun;", "contents": "mp_freerun::speed_test()"},
	{ "trigger": "player_on_trigger\t#using scripts\\mp\\mp_freerun;", "contents": "mp_freerun::player_on_trigger(${1:player}, ${2:endon_string})"},
	{ "trigger": "player_off_trigger\t#using scripts\\mp\\mp_freerun;", "contents": "mp_freerun::player_off_trigger(${1:player})"},
	{ "trigger": "setLightArmorHP\t#using scripts\\mp\\_armor;", "contents": "armor::setLightArmorHP(${1:newValue})"},
	{ "trigger": "setLightArmor\t#using scripts\\mp\\_armor;", "contents": "armor::setLightArmor(${1:optionalArmorValue})"},
	{ "trigger": "removeLightArmorOnDeath\t#using scripts\\mp\\_armor;", "contents": "armor::removeLightArmorOnDeath()"},
	{ "trigger": "unsetLightArmor\t#using scripts\\mp\\_armor;", "contents": "armor::unsetLightArmor()"},
	{ "trigger": "removeLightArmorOnMatchEnd\t#using scripts\\mp\\_armor;", "contents": "armor::removeLightArmorOnMatchEnd()"},
	{ "trigger": "hasLightArmor\t#using scripts\\mp\\_armor;", "contents": "armor::hasLightArmor()"},
	{ "trigger": "getArmor\t#using scripts\\mp\\_armor;", "contents": "armor::getArmor()"},
	{ "trigger": "defaultRole\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::defaultRole()"},
	{ "trigger": "state_death_update\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::state_death_update(${1:params})"},
	{ "trigger": "clean_up_spawned\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::clean_up_spawned()"},
	{ "trigger": "pain_toggle\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::pain_toggle(${1:enabled})"},
	{ "trigger": "pain_canenter\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::pain_canenter()"},
	{ "trigger": "pain_enter\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::pain_enter(${1:params})"},
	{ "trigger": "pain_exit\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::pain_exit(${1:params})"},
	{ "trigger": "pain_update\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::pain_update(${1:params})"},
	{ "trigger": "should_prepare_death\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::should_prepare_death(${1:from_state}, ${2:to_state}, ${3:connection})"},
	{ "trigger": "prepare_death_update\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::prepare_death_update(${1:params})"},
	{ "trigger": "scripted_exit\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::scripted_exit(${1:params})"},
	{ "trigger": "can_jump_up\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::can_jump_up(${1:from_state}, ${2:to_state}, ${3:connection})"},
	{ "trigger": "state_jumpUp_enter\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::state_jumpUp_enter(${1:params})"},
	{ "trigger": "can_jump_down\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::can_jump_down(${1:from_state}, ${2:to_state}, ${3:connection})"},
	{ "trigger": "state_jumpDown_enter\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::state_jumpDown_enter(${1:params})"},
	{ "trigger": "can_jump_ground_to_ground\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::can_jump_ground_to_ground(${1:from_state}, ${2:to_state}, ${3:connection})"},
	{ "trigger": "state_jump_exit\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::state_jump_exit(${1:params})"},
	{ "trigger": "state_jumpDown_exit\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::state_jumpDown_exit(${1:params})"},
	{ "trigger": "state_jump_update\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::state_jump_update(${1:params})"},
	{ "trigger": "state_balconyCombat_enter\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::state_balconyCombat_enter(${1:params})"},
	{ "trigger": "state_balconyCombat_update\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::state_balconyCombat_update(${1:params})"},
	{ "trigger": "side_step\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::side_step()"},
	{ "trigger": "state_balconyCombat_exit\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::state_balconyCombat_exit(${1:params})"},
	{ "trigger": "state_groundCombat_update\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::state_groundCombat_update(${1:params})"},
	{ "trigger": "footstep_damage\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::footstep_damage(${1:tag_name})"},
	{ "trigger": "footstep_left_monitor\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::footstep_left_monitor()"},
	{ "trigger": "footstep_right_monitor\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::footstep_right_monitor()"},
	{ "trigger": "highGroundPoint\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::highGroundPoint(${1:distanceLimitMin}, ${2:distanceLimitMax}, ${3:pointsArray}, ${4:idealDist})"},
	{ "trigger": "state_groundCombat_exit\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::state_groundCombat_exit(${1:params})"},
	{ "trigger": "get_player_vehicle\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::get_player_vehicle(${1:player})"},
	{ "trigger": "get_player_and_vehicle_array\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::get_player_and_vehicle_array()"},
	{ "trigger": "reset_player_threat\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::reset_player_threat(${1:player})"},
	{ "trigger": "add_player_threat_damage\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::add_player_threat_damage(${1:player}, ${2:damage})"},
	{ "trigger": "add_player_threat_boost\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::add_player_threat_boost(${1:player}, ${2:boost}, ${3:timeSeconds})"},
	{ "trigger": "get_player_threat\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::get_player_threat(${1:player})"},
	{ "trigger": "update_target_player\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::update_target_player()"},
	{ "trigger": "shoulder_light_focus\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::shoulder_light_focus(${1:target})"},
	{ "trigger": "Pin_first_three_spikes_to_ground\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::Pin_first_three_spikes_to_ground(${1:delay})"},
	{ "trigger": "Attack_Thread_Gun\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::Attack_Thread_Gun()"},
	{ "trigger": "Attack_Thread_Rocket\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::Attack_Thread_Rocket()"},
	{ "trigger": "toggle_rocketaim\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::toggle_rocketaim(${1:is_aiming})"},
	{ "trigger": "locomotion_start\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::locomotion_start()"},
	{ "trigger": "Get_Strong_Target\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::Get_Strong_Target()"},
	{ "trigger": "Movement_Thread\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::Movement_Thread()"},
	{ "trigger": "path_update_interrupt\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::path_update_interrupt()"},
	{ "trigger": "GetNextMovePosition\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::GetNextMovePosition(${1:enemy})"},
	{ "trigger": "_sort_by_distance2d\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::_sort_by_distance2d(${1:left}, ${2:right}, ${3:point})"},
	{ "trigger": "too_close_to_high_ground\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::too_close_to_high_ground(${1:point}, ${2:minDistance})"},
	{ "trigger": "get_jumpon_target\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::get_jumpon_target(${1:distanceLimitMin}, ${2:distanceLimitMax}, ${3:idealDist}, ${4:includingAI}, ${5:minAngleDiffCos}, ${6:mustJump})"},
	{ "trigger": "stopMovementAndSetBrake\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::stopMovementAndSetBrake()"},
	{ "trigger": "face_target\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::face_target(${1:position}, ${2:targetAngleDiff})"},
	{ "trigger": "theia_callback_damage\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::theia_callback_damage(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:psOffsetTime}, ${11:damageFromUnderneath}, ${12:modelIndex}, ${13:partName}, ${14:vSurfaceNormal})"},
	{ "trigger": "attack_javelin\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::attack_javelin()"},
	{ "trigger": "javeline_incoming\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::javeline_incoming(${1:projectile})"},
	{ "trigger": "pin_to_ground\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::pin_to_ground()"},
	{ "trigger": "pin_spike_to_ground\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::pin_spike_to_ground()"},
	{ "trigger": "spike_score\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::spike_score(${1:target})"},
	{ "trigger": "spike_group_score\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::spike_group_score(${1:target}, ${2:targetList}, ${3:radius})"},
	{ "trigger": "attack_spike_minefield\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::attack_spike_minefield()"},
	{ "trigger": "Delay_Target_ToEnemy_Thread\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::Delay_Target_ToEnemy_Thread(${1:point}, ${2:enemy}, ${3:timeToHit})"},
	{ "trigger": "is_valid_target\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::is_valid_target(${1:target})"},
	{ "trigger": "get_enemy\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::get_enemy()"},
	{ "trigger": "attack_minigun_sweep\t#using scripts\\mp\\vehicles\\_siegebot_theia;", "contents": "siegebot_theia::attack_minigun_sweep()"},
	{ "trigger": "startMonitoringTearUsage\t#using scripts\\mp\\_teargrenades;", "contents": "_teargrenades::startMonitoringTearUsage()"},
	{ "trigger": "stopMonitoringTearUsage\t#using scripts\\mp\\_teargrenades;", "contents": "_teargrenades::stopMonitoringTearUsage(${1:disconnected})"},
	{ "trigger": "monitorTearUsage\t#using scripts\\mp\\_teargrenades;", "contents": "_teargrenades::monitorTearUsage()"},
	{ "trigger": "tearGrenade_think\t#using scripts\\mp\\_teargrenades;", "contents": "_teargrenades::tearGrenade_think(${1:team})"},
	{ "trigger": "tear\t#using scripts\\mp\\_teargrenades;", "contents": "_teargrenades::tear(${1:pos})"},
	{ "trigger": "teartimer\t#using scripts\\mp\\_teargrenades;", "contents": "_teargrenades::teartimer()"},
	{ "trigger": "teargassuffering\t#using scripts\\mp\\_teargrenades;", "contents": "_teargrenades::teargassuffering()"},
	{ "trigger": "PlayPilotDialog\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::PlayPilotDialog(${1:dialog})"},
	{ "trigger": "useKillstreakStrafeRun\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::useKillstreakStrafeRun(${1:hardpointType})"},
	{ "trigger": "playContrail\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::playContrail()"},
	{ "trigger": "cleanupOnDeath\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::cleanupOnDeath(${1:team})"},
	{ "trigger": "watchdamage\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::watchdamage()"},
	{ "trigger": "watchForOtherKillstreaks\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::watchForOtherKillstreaks()"},
	{ "trigger": "watchForKills\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::watchForKills()"},
	{ "trigger": "watchForOwnerExit\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::watchForOwnerExit(${1:owner})"},
	{ "trigger": "addStraferunKill\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::addStraferunKill()"},
	{ "trigger": "doStrafeRuns\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::doStrafeRuns()"},
	{ "trigger": "fireFlares\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::fireFlares()"},
	{ "trigger": "startStrafe\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::startStrafe()"},
	{ "trigger": "firstStrafe\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::firstStrafe()"},
	{ "trigger": "fireRockets\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::fireRockets()"},
	{ "trigger": "stopStrafe\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::stopStrafe()"},
	{ "trigger": "PilotDialogWait\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::PilotDialogWait(${1:Dialog}, ${2:time})"},
	{ "trigger": "shouldLeaveMap\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::shouldLeaveMap()"},
	{ "trigger": "leaveMap\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::leaveMap()"},
	{ "trigger": "explode\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::explode()"},
	{ "trigger": "canTargetEntity\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::canTargetEntity(${1:entity})"},
	{ "trigger": "canTargetPlayer\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::canTargetPlayer(${1:player})"},
	{ "trigger": "canTargetActor\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::canTargetActor(${1:actor})"},
	{ "trigger": "targetInFrontOfPlane\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::targetInFrontOfPlane(${1:target})"},
	{ "trigger": "getValidTargets\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::getValidTargets()"},
	{ "trigger": "deadReconTargetOrigin\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::deadReconTargetOrigin(${1:rocket_start}, ${2:target})"},
	{ "trigger": "shellShockPlayers\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::shellShockPlayers(${1:origin})"},
	{ "trigger": "strafeRunShellShock\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::strafeRunShellShock()"},
	{ "trigger": "createKillcams\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::createKillcams(${1:numKillcams}, ${2:numRockets})"},
	{ "trigger": "resetKillcams\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::resetKillcams(${1:time})"},
	{ "trigger": "unlinkKillcams\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::unlinkKillcams()"},
	{ "trigger": "createKillcamEnt\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::createKillcamEnt()"},
	{ "trigger": "resetKillcamEnt\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::resetKillcamEnt(${1:parent})"},
	{ "trigger": "resetRocketKillcamEnt\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::resetRocketKillcamEnt(${1:parent}, ${2:rocketIndex})"},
	{ "trigger": "deleteWhenParentDies\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::deleteWhenParentDies(${1:parent})"},
	{ "trigger": "unlinkWhenParentDies\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::unlinkWhenParentDies(${1:parent})"},
	{ "trigger": "attachKillcamToRocket\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::attachKillcamToRocket(${1:killCamEnt}, ${2:selectedTarget}, ${3:targetOrigin})"},
	{ "trigger": "unlinkWhenClose\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::unlinkWhenClose(${1:selectedTarget}, ${2:targetOrigin}, ${3:plane})"},
	{ "trigger": "getLookaheadOrigin\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::getLookaheadOrigin(${1:previous_origin}, ${2:next_origin}, ${3:lookAhead})"},
	{ "trigger": "strafeKillcam\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::strafeKillcam(${1:parent}, ${2:node}, ${3:distance})"},
	{ "trigger": "killcamMoveto\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::killcamMoveto(${1:goal}, ${2:speed}, ${3:accel}, ${4:pathHeight})"},
	{ "trigger": "startStrafeKillcams\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::startStrafeKillcams()"},
	{ "trigger": "getStrafeDistance\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::getStrafeDistance(${1:node})"},
	{ "trigger": "getOriginAlongStrafePath\t#using scripts\\mp\\killstreaks\\_straferun;", "contents": "straferun::getOriginAlongStrafePath(${1:node}, ${2:start_origin}, ${3:distance_along})"},
	{ "trigger": "Callback_VehicleSpawned\t#using scripts\\mp\\gametypes\\_globallogic_vehicle;", "contents": "globallogic_vehicle::Callback_VehicleSpawned(${1:spawner})"},
	{ "trigger": "Callback_VehicleDamage\t#using scripts\\mp\\gametypes\\_globallogic_vehicle;", "contents": "globallogic_vehicle::Callback_VehicleDamage(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:vDamageOrigin}, ${11:psOffsetTime}, ${12:damageFromUnderneath}, ${13:modelIndex}, ${14:partName}, ${15:vSurfaceNormal})"},
	{ "trigger": "Callback_VehicleRadiusDamage\t#using scripts\\mp\\gametypes\\_globallogic_vehicle;", "contents": "globallogic_vehicle::Callback_VehicleRadiusDamage(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:fInnerDamage}, ${5:fOuterDamage}, ${6:iDFlags}, ${7:sMeansOfDeath}, ${8:weapon}, ${9:vPoint}, ${10:fRadius}, ${11:fConeAngleCos}, ${12:vConeDir}, ${13:psOffsetTime})"},
	{ "trigger": "Callback_VehicleKilled\t#using scripts\\mp\\gametypes\\_globallogic_vehicle;", "contents": "globallogic_vehicle::Callback_VehicleKilled(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime})"},
	{ "trigger": "vehicleCrush\t#using scripts\\mp\\gametypes\\_globallogic_vehicle;", "contents": "globallogic_vehicle::vehicleCrush()"},
	{ "trigger": "GetVehicleUnderneathSplashScalar\t#using scripts\\mp\\gametypes\\_globallogic_vehicle;", "contents": "globallogic_vehicle::GetVehicleUnderneathSplashScalar(${1:weapon})"},
	{ "trigger": "AllowFriendlyFireDamage\t#using scripts\\mp\\gametypes\\_globallogic_vehicle;", "contents": "globallogic_vehicle::AllowFriendlyFireDamage(${1:eInflictor}, ${2:eAttacker}, ${3:sMeansOfDeath}, ${4:weapon})"},
	{ "trigger": "updateMatchBonusScores\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::updateMatchBonusScores(${1:winner})"},
	{ "trigger": "updateCustomGameWinner\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::updateCustomGameWinner(${1:winner})"},
	{ "trigger": "giveMatchBonus\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::giveMatchBonus(${1:scoreType}, ${2:score})"},
	{ "trigger": "getHighestScoringPlayer\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::getHighestScoringPlayer()"},
	{ "trigger": "resetPlayerScoreChainAndMomentum\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::resetPlayerScoreChainAndMomentum(${1:player})"},
	{ "trigger": "resetScoreChain\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::resetScoreChain()"},
	{ "trigger": "scoreChainTimer\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::scoreChainTimer()"},
	{ "trigger": "roundToNearestFive\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::roundToNearestFive(${1:score})"},
	{ "trigger": "givePlayerMomentumNotification\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::givePlayerMomentumNotification(${1:score}, ${2:label}, ${3:descValue}, ${4:countsTowardRampage}, ${5:weapon}, ${6:combatEfficiencyBonus})"},
	{ "trigger": "resetPlayerMomentumOnSpawn\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::resetPlayerMomentumOnSpawn()"},
	{ "trigger": "givePlayerMomentum\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::givePlayerMomentum(${1:event}, ${2:player}, ${3:victim}, ${4:descValue}, ${5:weapon})"},
	{ "trigger": "givePlayerScore\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::givePlayerScore(${1:event}, ${2:player}, ${3:victim}, ${4:descValue}, ${5:weapon})"},
	{ "trigger": "default_onPlayerScore\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::default_onPlayerScore(${1:event}, ${2:player}, ${3:victim})"},
	{ "trigger": "_setPlayerScore\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::_setPlayerScore(${1:player}, ${2:score})"},
	{ "trigger": "_getPlayerScore\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::_getPlayerScore(${1:player})"},
	{ "trigger": "playTop3Sounds\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::playTop3Sounds()"},
	{ "trigger": "setPointsToWin\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::setPointsToWin(${1:points})"},
	{ "trigger": "givePointsToWin\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::givePointsToWin(${1:points})"},
	{ "trigger": "_setPlayerMomentum\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::_setPlayerMomentum(${1:player}, ${2:momentum}, ${3:updateScore = true})"},
	{ "trigger": "_givePlayerKillstreakInternal\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::_givePlayerKillstreakInternal(${1:player}, ${2:momentum}, ${3:oldMomentum}, ${4:killStreakTypeArray})"},
	{ "trigger": "giveTeamScore\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::giveTeamScore(${1:event}, ${2:team}, ${3:player}, ${4:victim})"},
	{ "trigger": "giveTeamScoreForObjective_DelayPostProcessing\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::giveTeamScoreForObjective_DelayPostProcessing(${1:team}, ${2:score})"},
	{ "trigger": "postProcessTeamScores\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::postProcessTeamScores(${1:teams})"},
	{ "trigger": "giveTeamScoreForObjective\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::giveTeamScoreForObjective(${1:team}, ${2:score})"},
	{ "trigger": "_setTeamScore\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::_setTeamScore(${1:team}, ${2:teamScore})"},
	{ "trigger": "resetTeamScores\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::resetTeamScores()"},
	{ "trigger": "resetAllScores\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::resetAllScores()"},
	{ "trigger": "resetPlayerScores\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::resetPlayerScores()"},
	{ "trigger": "updateTeamScores\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::updateTeamScores(${1:team})"},
	{ "trigger": "updateAllTeamScores\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::updateAllTeamScores()"},
	{ "trigger": "_getTeamScore\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::_getTeamScore(${1:team})"},
	{ "trigger": "getHighestTeamScoreTeam\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::getHighestTeamScoreTeam()"},
	{ "trigger": "areTeamArraysEqual\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::areTeamArraysEqual(${1:teamsA}, ${2:teamsB})"},
	{ "trigger": "onTeamScore\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::onTeamScore(${1:score}, ${2:team})"},
	{ "trigger": "onTeamScore_IncrementScore\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::onTeamScore_IncrementScore(${1:score}, ${2:team})"},
	{ "trigger": "onTeamScore_PostProcess\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::onTeamScore_PostProcess(${1:team})"},
	{ "trigger": "default_onTeamScore\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::default_onTeamScore(${1:event}, ${2:team})"},
	{ "trigger": "getPersStat\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::getPersStat(${1:dataName})"},
	{ "trigger": "incPersStat\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::incPersStat(${1:dataName}, ${2:increment}, ${3:record_stats}, ${4:includeGametype})"},
	{ "trigger": "threadedRecordPlayerStats\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::threadedRecordPlayerStats(${1:dataName})"},
	{ "trigger": "updateWinStats\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::updateWinStats(${1:winner})"},
	{ "trigger": "canUpdateWeaponContractStats\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::canUpdateWeaponContractStats()"},
	{ "trigger": "updateWeaponContractStart\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::updateWeaponContractStart(${1:player})"},
	{ "trigger": "updateWeaponContractWin\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::updateWeaponContractWin(${1:winner})"},
	{ "trigger": "updateWeaponContractPlayed\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::updateWeaponContractPlayed()"},
	{ "trigger": "updateContractWin\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::updateContractWin(${1:winner})"},
	{ "trigger": "registerContractWinEvent\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::registerContractWinEvent(${1:event})"},
	{ "trigger": "updateLossStats\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::updateLossStats(${1:loser})"},
	{ "trigger": "updateLossLateJoinStats\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::updateLossLateJoinStats(${1:loser})"},
	{ "trigger": "updateTieStats\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::updateTieStats(${1:loser})"},
	{ "trigger": "updateWinLossStats\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::updateWinLossStats(${1:winner})"},
	{ "trigger": "backupAndClearWinStreaks\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::backupAndClearWinStreaks()"},
	{ "trigger": "restoreWinStreaks\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::restoreWinStreaks(${1:winner})"},
	{ "trigger": "incKillstreakTracker\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::incKillstreakTracker(${1:weapon})"},
	{ "trigger": "trackAttackerKill\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::trackAttackerKill(${1:name}, ${2:rank}, ${3:xp}, ${4:prestige}, ${5:xuid}, ${6:weapon})"},
	{ "trigger": "trackAttackeeDeath\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::trackAttackeeDeath(${1:attackerName}, ${2:rank}, ${3:xp}, ${4:prestige}, ${5:xuid})"},
	{ "trigger": "default_isKillBoosting\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::default_isKillBoosting()"},
	{ "trigger": "giveKillStats\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::giveKillStats(${1:sMeansOfDeath}, ${2:weapon}, ${3:eVictim})"},
	{ "trigger": "incTotalKills\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::incTotalKills(${1:team})"},
	{ "trigger": "setInflictorStat\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::setInflictorStat(${1:eInflictor}, ${2:eAttacker}, ${3:weapon})"},
	{ "trigger": "processShieldAssist\t#using scripts\\mp\\gametypes\\_globallogic_score; self == riotshield player", "contents": "globallogic_score::processShieldAssist(${1:killedplayer})"},
	{ "trigger": "processAssist\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::processAssist(${1:killedplayer}, ${2:damagedone}, ${3:weapon})"},
	{ "trigger": "processKillstreakAssists\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::processKillstreakAssists(${1:attacker}, ${2:inflictor}, ${3:weapon})"},
	{ "trigger": "process_killstreak_assist_score\t#using scripts\\mp\\gametypes\\_globallogic_score;", "contents": "globallogic_score::process_killstreak_assist_score(${1:killstreak}, ${2:scoreGiven})"},
	{ "trigger": "getWinningTeamFromLoser\t#using scripts\\mp\\gametypes\\_globallogic_defaults;", "contents": "globallogic_defaults::getWinningTeamFromLoser(${1:losing_team})"},
	{ "trigger": "default_onForfeit\t#using scripts\\mp\\gametypes\\_globallogic_defaults;", "contents": "globallogic_defaults::default_onForfeit(${1:team})"},
	{ "trigger": "default_onDeadEvent\t#using scripts\\mp\\gametypes\\_globallogic_defaults;", "contents": "globallogic_defaults::default_onDeadEvent(${1:team})"},
	{ "trigger": "default_onLastTeamAliveEvent\t#using scripts\\mp\\gametypes\\_globallogic_defaults;", "contents": "globallogic_defaults::default_onLastTeamAliveEvent(${1:team})"},
	{ "trigger": "default_onAliveCountChange\t#using scripts\\mp\\gametypes\\_globallogic_defaults;", "contents": "globallogic_defaults::default_onAliveCountChange(${1:team})"},
	{ "trigger": "default_onRoundEndGame\t#using scripts\\mp\\gametypes\\_globallogic_defaults;", "contents": "globallogic_defaults::default_onRoundEndGame(${1:winner})"},
	{ "trigger": "default_determineWinner\t#using scripts\\mp\\gametypes\\_globallogic_defaults;", "contents": "globallogic_defaults::default_determineWinner(${1:roundWinner})"},
	{ "trigger": "default_onOneLeftEvent\t#using scripts\\mp\\gametypes\\_globallogic_defaults;", "contents": "globallogic_defaults::default_onOneLeftEvent(${1:team})"},
	{ "trigger": "default_onTimeLimit\t#using scripts\\mp\\gametypes\\_globallogic_defaults;", "contents": "globallogic_defaults::default_onTimeLimit()"},
	{ "trigger": "default_onScoreLimit\t#using scripts\\mp\\gametypes\\_globallogic_defaults;", "contents": "globallogic_defaults::default_onScoreLimit()"},
	{ "trigger": "default_onRoundScoreLimit\t#using scripts\\mp\\gametypes\\_globallogic_defaults;", "contents": "globallogic_defaults::default_onRoundScoreLimit()"},
	{ "trigger": "default_onSpawnSpectator\t#using scripts\\mp\\gametypes\\_globallogic_defaults;", "contents": "globallogic_defaults::default_onSpawnSpectator(${1:origin}, ${2:angles})"},
	{ "trigger": "default_onSpawnIntermission\t#using scripts\\mp\\gametypes\\_globallogic_defaults;", "contents": "globallogic_defaults::default_onSpawnIntermission(${1:endGame})"},
	{ "trigger": "default_getTimeLimit\t#using scripts\\mp\\gametypes\\_globallogic_defaults;", "contents": "globallogic_defaults::default_getTimeLimit()"},
	{ "trigger": "default_getTeamKillPenalty\t#using scripts\\mp\\gametypes\\_globallogic_defaults;", "contents": "globallogic_defaults::default_getTeamKillPenalty(${1:eInflictor}, ${2:attacker}, ${3:sMeansOfDeath}, ${4:weapon})"},
	{ "trigger": "default_getTeamKillScore\t#using scripts\\mp\\gametypes\\_globallogic_defaults;", "contents": "globallogic_defaults::default_getTeamKillScore(${1:eInflictor}, ${2:attacker}, ${3:sMeansOfDeath}, ${4:weapon})"},
	{ "trigger": "on_disconnect\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::on_disconnect()"},
	{ "trigger": "deduct_player_ante\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::deduct_player_ante()"},
	{ "trigger": "increment_escrow_for_player\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::increment_escrow_for_player(${1:amount})"},
	{ "trigger": "clear_escrows\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::clear_escrows()"},
	{ "trigger": "add_recent_earnings_to_stat\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::add_recent_earnings_to_stat(${1:recentEarnings})"},
	{ "trigger": "prematch_period\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::prematch_period()"},
	{ "trigger": "finalize_round\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::finalize_round()"},
	{ "trigger": "determine_winnings\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::determine_winnings()"},
	{ "trigger": "calculate_free_for_all_payouts\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::calculate_free_for_all_payouts()"},
	{ "trigger": "calculate_places_based_on_score\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::calculate_places_based_on_score()"},
	{ "trigger": "calculate_team_payouts\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::calculate_team_payouts()"},
	{ "trigger": "set_winnings_on_players\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::set_winnings_on_players(${1:players}, ${2:amount})"},
	{ "trigger": "finalize_game\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::finalize_game()"},
	{ "trigger": "pay_out_winnings\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::pay_out_winnings(${1:player}, ${2:winnings})"},
	{ "trigger": "determine_top_earners\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::determine_top_earners()"},
	{ "trigger": "post_round_side_bet\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::post_round_side_bet()"},
	{ "trigger": "side_bet_timer\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::side_bet_timer()"},
	{ "trigger": "side_bet_all_bets_placed\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::side_bet_all_bets_placed()"},
	{ "trigger": "setup_blank_random_player\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::setup_blank_random_player(${1:takeWeapons}, ${2:chooseRandomBody}, ${3:weapon})"},
	{ "trigger": "assign_random_body\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::assign_random_body()"},
	{ "trigger": "queue_popup\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::queue_popup(${1:message}, ${2:points}, ${3:subMessage}, ${4:announcement})"},
	{ "trigger": "help_game_end\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::help_game_end()"},
	{ "trigger": "set_radar_visibility\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::set_radar_visibility()"},
	{ "trigger": "player_scored\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::player_scored()"},
	{ "trigger": "announcer\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::announcer(${1:dialog}, ${2:group})"},
	{ "trigger": "create_powerup\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::create_powerup(${1:name}, ${2:type}, ${3:displayName}, ${4:iconMaterial})"},
	{ "trigger": "add_powerup\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::add_powerup(${1:name}, ${2:type}, ${3:displayName}, ${4:iconMaterial})"},
	{ "trigger": "copy_powerup\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::copy_powerup(${1:powerup})"},
	{ "trigger": "apply_powerup\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::apply_powerup(${1:powerup})"},
	{ "trigger": "give_powerup\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::give_powerup(${1:powerup}, ${2:doAnimation})"},
	{ "trigger": "pulse_powerup_icon\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::pulse_powerup_icon(${1:powerupIndex})"},
	{ "trigger": "show_powerup_message\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::show_powerup_message(${1:powerupIndex}, ${2:doAnimation})"},
	{ "trigger": "clear_powerups\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::clear_powerups()"},
	{ "trigger": "track_weapon_usage\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::track_weapon_usage(${1:name}, ${2:incValue}, ${3:statName})"},
	{ "trigger": "get_highest_weapon_usage\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::get_highest_weapon_usage(${1:statName})"},
	{ "trigger": "set_after_action_report_stats\t#using scripts\\mp\\gametypes\\_wager;", "contents": "wager::set_after_action_report_stats()"},
	{ "trigger": "define_elevator_parts\t#using scripts\\mp\\_elevator;", "contents": "elevator::define_elevator_parts()"},
	{ "trigger": "trigger_think\t#using scripts\\mp\\_elevator;", "contents": "elevator::trigger_think(${1:platform_name})"},
	{ "trigger": "elevator_looping_sounds\t#using scripts\\mp\\_elevator;", "contents": "elevator::elevator_looping_sounds(${1:notify_play}, ${2:notify_stop})"},
	{ "trigger": "setup_elevator_gates\t#using scripts\\mp\\_elevator;", "contents": "elevator::setup_elevator_gates(${1:platform_name})"},
	{ "trigger": "move_elevator_gates\t#using scripts\\mp\\_elevator;", "contents": "elevator::move_elevator_gates(${1:platform_name}, ${2:direction})"},
	{ "trigger": "move_platform\t#using scripts\\mp\\_elevator;", "contents": "elevator::move_platform(${1:platform_start}, ${2:platform_name})"},
	{ "trigger": "get_speed\t#using scripts\\mp\\_elevator;", "contents": "elevator::get_speed(${1:path_point}, ${2:speed})"},
	{ "trigger": "useKillstreakDogs\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::useKillstreakDogs(${1:hardpointType})"},
	{ "trigger": "ownerHadActiveDogs\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::ownerHadActiveDogs()"},
	{ "trigger": "dog_set_model\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::dog_set_model()"},
	{ "trigger": "get_spawn_node\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::get_spawn_node(${1:owner}, ${2:team})"},
	{ "trigger": "get_score_for_spawn\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::get_score_for_spawn(${1:origin}, ${2:team})"},
	{ "trigger": "dog_set_owner\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::dog_set_owner(${1:owner}, ${2:team}, ${3:requiredDeathCount})"},
	{ "trigger": "dog_create_spawn_influencer\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::dog_create_spawn_influencer(${1:team})"},
	{ "trigger": "dog_manager_spawn_dog\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::dog_manager_spawn_dog(${1:owner}, ${2:team}, ${3:spawn_node}, ${4:requiredDeathCount})"},
	{ "trigger": "monitor_dog_special_grenades\t#using scripts\\mp\\killstreaks\\_dogs; self == dog", "contents": "dogs::monitor_dog_special_grenades()"},
	{ "trigger": "dog_manager_spawn_dogs\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::dog_manager_spawn_dogs(${1:owner}, ${2:deathCount}, ${3:killstreak_id})"},
	{ "trigger": "dog_abort\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::dog_abort()"},
	{ "trigger": "dog_manager_abort\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::dog_manager_abort()"},
	{ "trigger": "dog_manager_game_ended\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::dog_manager_game_ended()"},
	{ "trigger": "dog_notify_level_on_death\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::dog_notify_level_on_death()"},
	{ "trigger": "dog_leave\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::dog_leave()"},
	{ "trigger": "dog_patrol\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::dog_patrol()"},
	{ "trigger": "dog_patrol_near_objective\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::dog_patrol_near_objective()"},
	{ "trigger": "dog_patrol_near_enemy\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::dog_patrol_near_enemy()"},
	{ "trigger": "dog_manager_get_dogs\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::dog_manager_get_dogs()"},
	{ "trigger": "dog_owner_kills\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::dog_owner_kills()"},
	{ "trigger": "dog_health_regen\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::dog_health_regen()"},
	{ "trigger": "trackAttackerDamage\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::trackAttackerDamage(${1:attacker})"},
	{ "trigger": "resetAttackerDamage\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::resetAttackerDamage()"},
	{ "trigger": "dog_health_regen_think\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::dog_health_regen_think(${1:delay}, ${2:interval}, ${3:regen_interval})"},
	{ "trigger": "selfDefenseChallenge\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::selfDefenseChallenge()"},
	{ "trigger": "dog_get_exit_node\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::dog_get_exit_node()"},
	{ "trigger": "flash_dogs\t#using scripts\\mp\\killstreaks\\_dogs;", "contents": "dogs::flash_dogs(${1:area})"},
	{ "trigger": "teamOutcomeNotify\t#using scripts\\mp\\gametypes\\_hud_message;", "contents": "hud_message::teamOutcomeNotify(${1:winner}, ${2:endType}, ${3:endReasonText})"},
	{ "trigger": "teamOutcomeNotifyZombie\t#using scripts\\mp\\gametypes\\_hud_message;", "contents": "hud_message::teamOutcomeNotifyZombie(${1:winner}, ${2:isRound}, ${3:endReasonText})"},
	{ "trigger": "outcomeNotify\t#using scripts\\mp\\gametypes\\_hud_message;", "contents": "hud_message::outcomeNotify(${1:winner}, ${2:isRoundEnd}, ${3:endReasonText})"},
	{ "trigger": "wagerOutcomeNotify\t#using scripts\\mp\\gametypes\\_hud_message;", "contents": "hud_message::wagerOutcomeNotify(${1:winner}, ${2:endReasonText})"},
	{ "trigger": "teamWagerOutcomeNotify\t#using scripts\\mp\\gametypes\\_hud_message;", "contents": "hud_message::teamWagerOutcomeNotify(${1:winner}, ${2:isRoundEnd}, ${3:endReasonText})"},
	{ "trigger": "resetOutcomeNotify\t#using scripts\\mp\\gametypes\\_hud_message;", "contents": "hud_message::resetOutcomeNotify(${1:hudElemList1}, ${2:hudElemList2}, ${3:hudElem3}, ${4:hudElem4}, ${5:hudElem5}, ${6:hudElem6}, ${7:hudElem7}, ${8:hudElem8}, ${9:hudElem9}, ${10:hudElem10})"},
	{ "trigger": "resetWagerOutcomeNotify\t#using scripts\\mp\\gametypes\\_hud_message;", "contents": "hud_message::resetWagerOutcomeNotify(${1:playerNameHudElems}, ${2:playerCPHudElems}, ${3:outcomeTitle}, ${4:outcomeText})"},
	{ "trigger": "updateOutcome\t#using scripts\\mp\\gametypes\\_hud_message;", "contents": "hud_message::updateOutcome(${1:firstTitle}, ${2:secondTitle}, ${3:thirdTitle})"},
	{ "trigger": "updateWagerOutcome\t#using scripts\\mp\\gametypes\\_hud_message;", "contents": "hud_message::updateWagerOutcome(${1:playerNameHudElems}, ${2:playerCPHudElems})"},
	{ "trigger": "remote_missile_game_end_think\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::remote_missile_game_end_think(${1:rocket}, ${2:team}, ${3:killstreak_id})"},
	{ "trigger": "tryUsePredatorMissile\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::tryUsePredatorMissile(${1:lifeId})"},
	{ "trigger": "getBestSpawnPoint\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::getBestSpawnPoint(${1:remoteMissileSpawnPoints})"},
	{ "trigger": "drawLine\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::drawLine(${1:start}, ${2:end}, ${3:timeSlice}, ${4:color})"},
	{ "trigger": "_fire\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::_fire(${1:lifeId}, ${2:player}, ${3:team}, ${4:killstreak_id})"},
	{ "trigger": "hackedHealthUpdate\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::hackedHealthUpdate(${1:hacker})"},
	{ "trigger": "HackedPostFunction\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::HackedPostFunction(${1:hacker})"},
	{ "trigger": "setup_rockect_map_icon\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::setup_rockect_map_icon()"},
	{ "trigger": "watch_missile_kill_z\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::watch_missile_kill_z()"},
	{ "trigger": "watch_missile_death\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::watch_missile_death(${1:rocket}, ${2:team}, ${3:killstreak_id})"},
	{ "trigger": "player_missile_end\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::player_missile_end(${1:rocket}, ${2:performPlayerKillstreakEnd}, ${3:unlink}, ${4:team}, ${5:killstreak_id})"},
	{ "trigger": "missile_brake_timeout_watch\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::missile_brake_timeout_watch()"},
	{ "trigger": "stopOndeath\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::stopOndeath(${1:snd})"},
	{ "trigger": "cleanupWaiter\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::cleanupWaiter(${1:rocket}, ${2:team}, ${3:killstreak_id})"},
	{ "trigger": "handleDamage\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::handleDamage()"},
	{ "trigger": "staticEffect\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::staticEffect(${1:duration})"},
	{ "trigger": "Rocket_CleanupOnDeath\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::Rocket_CleanupOnDeath()"},
	{ "trigger": "missile_sound_play\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::missile_sound_play(${1:player})"},
	{ "trigger": "missile_sound_boost\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::missile_sound_boost(${1:rocket})"},
	{ "trigger": "missile_sound_impact\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::missile_sound_impact(${1:player}, ${2:distance})"},
	{ "trigger": "sndWatchExplo\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::sndWatchExplo()"},
	{ "trigger": "missile_sound_deploy_bomblets\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::missile_sound_deploy_bomblets()"},
	{ "trigger": "getValidTargets\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::getValidTargets(${1:rocket}, ${2:trace}, ${3:max_targets})"},
	{ "trigger": "create_missile_hud\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::create_missile_hud(${1:rocket})"},
	{ "trigger": "destroy_missile_hud\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::destroy_missile_hud()"},
	{ "trigger": "targeting_hud_think\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::targeting_hud_think(${1:rocket})"},
	{ "trigger": "missile_deploy_watch\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::missile_deploy_watch(${1:rocket})"},
	{ "trigger": "missile_deploy\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::missile_deploy(${1:rocket}, ${2:hacked})"},
	{ "trigger": "bomblet_camera_waiter\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::bomblet_camera_waiter(${1:rocket})"},
	{ "trigger": "setup_bomblet_map_icon\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::setup_bomblet_map_icon()"},
	{ "trigger": "setup_bomblet\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::setup_bomblet(${1:bomb})"},
	{ "trigger": "fire_bomblet\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::fire_bomblet(${1:rocket}, ${2:explosionRadius}, ${3:target}, ${4:waitFrames})"},
	{ "trigger": "fire_random_bomblet\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::fire_random_bomblet(${1:rocket}, ${2:explosionRadius}, ${3:quadrant}, ${4:waitFrames})"},
	{ "trigger": "cleanup_bombs\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::cleanup_bombs(${1:bomb})"},
	{ "trigger": "bomblet_explostion_waiter\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::bomblet_explostion_waiter(${1:player})"},
	{ "trigger": "remotemissile_bda_dialog\t#using scripts\\mp\\killstreaks\\_remotemissile;", "contents": "remotemissile::remotemissile_bda_dialog()"},
	{ "trigger": "perplayer::enable\t#using scripts\\mp\\gametypes\\_perplayer;", "contents": "perplayer::perplayer::enable(${1:objectiveCreator);})"},
	{ "trigger": "perplayer::disable\t#using scripts\\mp\\gametypes\\_perplayer;", "contents": "perplayer::perplayer::disable(${1:objectiveCreator);})"},
	{ "trigger": "enable\t#using scripts\\mp\\gametypes\\_perplayer;", "contents": "perplayer::enable(${1:handler})"},
	{ "trigger": "disable\t#using scripts\\mp\\gametypes\\_perplayer;", "contents": "perplayer::disable(${1:handler})"},
	{ "trigger": "onPlayerConnect\t#using scripts\\mp\\gametypes\\_perplayer;", "contents": "perplayer::onPlayerConnect(${1:handler})"},
	{ "trigger": "onPlayerDisconnect\t#using scripts\\mp\\gametypes\\_perplayer;", "contents": "perplayer::onPlayerDisconnect(${1:handler})"},
	{ "trigger": "onJoinedTeam\t#using scripts\\mp\\gametypes\\_perplayer;", "contents": "perplayer::onJoinedTeam(${1:handler})"},
	{ "trigger": "onJoinedSpectators\t#using scripts\\mp\\gametypes\\_perplayer;", "contents": "perplayer::onJoinedSpectators(${1:handler})"},
	{ "trigger": "onPlayerSpawned\t#using scripts\\mp\\gametypes\\_perplayer;", "contents": "perplayer::onPlayerSpawned(${1:handler})"},
	{ "trigger": "onPlayerKilled\t#using scripts\\mp\\gametypes\\_perplayer;", "contents": "perplayer::onPlayerKilled(${1:handler})"},
	{ "trigger": "handlePlayer\t#using scripts\\mp\\gametypes\\_perplayer;", "contents": "perplayer::handlePlayer(${1:handler})"},
	{ "trigger": "unHandlePlayer\t#using scripts\\mp\\gametypes\\_perplayer;", "contents": "perplayer::unHandlePlayer(${1:handler}, ${2:unsetready}, ${3:disconnected})"},
	{ "trigger": "start_gametype\t#using scripts\\mp\\_blackjack_challenges;", "contents": "blackjack_challenges::start_gametype()"},
	{ "trigger": "on_player_connect\t#using scripts\\mp\\_blackjack_challenges;", "contents": "blackjack_challenges::on_player_connect()"},
	{ "trigger": "is_challenge_active\t#using scripts\\mp\\_blackjack_challenges;", "contents": "blackjack_challenges::is_challenge_active()"},
	{ "trigger": "on_hero_ability_kill\t#using scripts\\mp\\_blackjack_challenges;", "contents": "blackjack_challenges::on_hero_ability_kill(${1:ability}, ${2:victimAbility})"},
	{ "trigger": "check_blackjack_challenge\t#using scripts\\mp\\_blackjack_challenges;", "contents": "blackjack_challenges::check_blackjack_challenge()"},
	{ "trigger": "challenge_kills\t#using scripts\\mp\\_blackjack_challenges;", "contents": "blackjack_challenges::challenge_kills(${1:data})"},
	{ "trigger": "get_challenge_stat\t#using scripts\\mp\\_blackjack_challenges;", "contents": "blackjack_challenges::get_challenge_stat(${1:stat_name})"},
	{ "trigger": "set_challenge_stat\t#using scripts\\mp\\_blackjack_challenges;", "contents": "blackjack_challenges::set_challenge_stat(${1:stat_name}, ${2:stat_value})"},
	{ "trigger": "get_hero_weapon_mask\t#using scripts\\mp\\_blackjack_challenges;", "contents": "blackjack_challenges::get_hero_weapon_mask(${1:attacker}, ${2:weapon})"},
	{ "trigger": "get_hero_ability_mask\t#using scripts\\mp\\_blackjack_challenges;", "contents": "blackjack_challenges::get_hero_ability_mask(${1:ability})"},
	{ "trigger": "challenge_game_ended\t#using scripts\\mp\\_blackjack_challenges;", "contents": "blackjack_challenges::challenge_game_ended(${1:data})"},
	{ "trigger": "challenge_round_ended\t#using scripts\\mp\\_blackjack_challenges;", "contents": "blackjack_challenges::challenge_round_ended(${1:data})"},
	{ "trigger": "track_blackjack_consumable\t#using scripts\\mp\\_blackjack_challenges;", "contents": "blackjack_challenges::track_blackjack_consumable()"},
	{ "trigger": "report_consumable\t#using scripts\\mp\\_blackjack_challenges;", "contents": "blackjack_challenges::report_consumable()"},
	{ "trigger": "on_player_spawned\t#using scripts\\mp\\killstreaks\\_killstreak_weapons; self == player", "contents": "killstreak_weapons::on_player_spawned()"},
	{ "trigger": "watchKillstreakWeaponDelay\t#using scripts\\mp\\killstreaks\\_killstreak_weapons;", "contents": "killstreak_weapons::watchKillstreakWeaponDelay()"},
	{ "trigger": "useKillstreakWeaponDrop\t#using scripts\\mp\\killstreaks\\_killstreak_weapons;", "contents": "killstreak_weapons::useKillstreakWeaponDrop(${1:hardpointType})"},
	{ "trigger": "useCarriedKillstreakWeapon\t#using scripts\\mp\\killstreaks\\_killstreak_weapons;", "contents": "killstreak_weapons::useCarriedKillstreakWeapon(${1:hardpointType})"},
	{ "trigger": "useKillstreakWeaponFromCrate\t#using scripts\\mp\\killstreaks\\_killstreak_weapons;", "contents": "killstreak_weapons::useKillstreakWeaponFromCrate(${1:hardpointType})"},
	{ "trigger": "watchKillstreakWeaponSwitch\t#using scripts\\mp\\killstreaks\\_killstreak_weapons;", "contents": "killstreak_weapons::watchKillstreakWeaponSwitch(${1:killstreakWeapon}, ${2:killstreak_id}, ${3:isFromInventory})"},
	{ "trigger": "watchKillstreakWeaponDeath\t#using scripts\\mp\\killstreaks\\_killstreak_weapons;", "contents": "killstreak_weapons::watchKillstreakWeaponDeath(${1:killstreakWeapon}, ${2:killstreak_id}, ${3:isFromInventory})"},
	{ "trigger": "WatchPlayerDeath\t#using scripts\\mp\\killstreaks\\_killstreak_weapons;", "contents": "killstreak_weapons::WatchPlayerDeath(${1:killstreakWeapon})"},
	{ "trigger": "watchKillstreakRemoval\t#using scripts\\mp\\killstreaks\\_killstreak_weapons;", "contents": "killstreak_weapons::watchKillstreakRemoval(${1:killstreakType}, ${2:killstreak_id})"},
	{ "trigger": "watchKillstreakRoundChange\t#using scripts\\mp\\killstreaks\\_killstreak_weapons;", "contents": "killstreak_weapons::watchKillstreakRoundChange(${1:isFromInventory}, ${2:killstreak_id})"},
	{ "trigger": "checkIfSwitchableWeapon\t#using scripts\\mp\\killstreaks\\_killstreak_weapons;", "contents": "killstreak_weapons::checkIfSwitchableWeapon(${1:currentWeapon}, ${2:newWeapon}, ${3:killstreakWeapon}, ${4:currentKillstreakId})"},
	{ "trigger": "bot_ignore_threat\t#using scripts\\mp\\bots\\_bot_combat;", "contents": "bot_combat::bot_ignore_threat(${1:entity})"},
	{ "trigger": "mp_pre_combat\t#using scripts\\mp\\bots\\_bot_combat;", "contents": "bot_combat::mp_pre_combat()"},
	{ "trigger": "mp_post_combat\t#using scripts\\mp\\bots\\_bot_combat;", "contents": "bot_combat::mp_post_combat()"},
	{ "trigger": "threat_requires_launcher\t#using scripts\\mp\\bots\\_bot_combat;", "contents": "bot_combat::threat_requires_launcher(${1:enemy})"},
	{ "trigger": "combat_throw_proximity\t#using scripts\\mp\\bots\\_bot_combat;", "contents": "bot_combat::combat_throw_proximity(${1:origin})"},
	{ "trigger": "combat_throw_smoke\t#using scripts\\mp\\bots\\_bot_combat;", "contents": "bot_combat::combat_throw_smoke(${1:origin})"},
	{ "trigger": "combat_throw_lethal\t#using scripts\\mp\\bots\\_bot_combat;", "contents": "bot_combat::combat_throw_lethal(${1:origin})"},
	{ "trigger": "combat_throw_tactical\t#using scripts\\mp\\bots\\_bot_combat;", "contents": "bot_combat::combat_throw_tactical(${1:origin})"},
	{ "trigger": "combat_toss_frag\t#using scripts\\mp\\bots\\_bot_combat;", "contents": "bot_combat::combat_toss_frag(${1:origin})"},
	{ "trigger": "combat_toss_flash\t#using scripts\\mp\\bots\\_bot_combat;", "contents": "bot_combat::combat_toss_flash(${1:origin})"},
	{ "trigger": "combat_tactical_insertion\t#using scripts\\mp\\bots\\_bot_combat;", "contents": "bot_combat::combat_tactical_insertion(${1:origin})"},
	{ "trigger": "nearest_node\t#using scripts\\mp\\bots\\_bot_combat;", "contents": "bot_combat::nearest_node(${1:origin})"},
	{ "trigger": "dot_product\t#using scripts\\mp\\bots\\_bot_combat;", "contents": "bot_combat::dot_product(${1:origin})"},
	{ "trigger": "get_closest_tag\t#using scripts\\mp\\bots\\_bot_combat;", "contents": "bot_combat::get_closest_tag()"},
	{ "trigger": "set_goal_tag\t#using scripts\\mp\\bots\\_bot_combat;", "contents": "bot_combat::set_goal_tag(${1:tag})"},
	{ "trigger": "onPrecacheGameType\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::onPrecacheGameType()"},
	{ "trigger": "onStartGameType\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::onStartGameType()"},
	{ "trigger": "onEndGame\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::onEndGame(${1:winningTeam})"},
	{ "trigger": "onRoundEndGame\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::onRoundEndGame(${1:roundWinner})"},
	{ "trigger": "updateGametypeDvars\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::updateGametypeDvars()"},
	{ "trigger": "domFlags\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::domFlags()"},
	{ "trigger": "getUnownedFlagNearestStart\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::getUnownedFlagNearestStart(${1:team}, ${2:excludeFlag})"},
	{ "trigger": "onBeginUse\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::onBeginUse(${1:player})"},
	{ "trigger": "onUseUpdate\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::onUseUpdate(${1:team}, ${2:progress}, ${3:change})"},
	{ "trigger": "flushObjectiveFlagDialog\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::flushObjectiveFlagDialog()"},
	{ "trigger": "statusDialog\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::statusDialog(${1:dialog}, ${2:team}, ${3:objectiveKey})"},
	{ "trigger": "onEndUse\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::onEndUse(${1:team}, ${2:player}, ${3:success})"},
	{ "trigger": "flagCapturedFromNeutral\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::flagCapturedFromNeutral(${1:team})"},
	{ "trigger": "flagCapturedFromTeam\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::flagCapturedFromTeam(${1:team}, ${2:oldTeam})"},
	{ "trigger": "flagNeutralized\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::flagNeutralized(${1:team}, ${2:oldTeam})"},
	{ "trigger": "GetDomFlagUseString\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::GetDomFlagUseString(${1:label}, ${2:neutralized})"},
	{ "trigger": "onUseWithNeutralizingFlag\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::onUseWithNeutralizingFlag(${1:player})"},
	{ "trigger": "onUseWithoutNeutralizingFlag\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::onUseWithoutNeutralizingFlag(${1:player})"},
	{ "trigger": "onUse\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::onUse(${1:player})"},
	{ "trigger": "totalDomination\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::totalDomination(${1:team})"},
	{ "trigger": "watchForBFlagCap\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::watchForBFlagCap()"},
	{ "trigger": "endWatchForBFlagCapAfterTime\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::endWatchForBFlagCapAfterTime(${1:time})"},
	{ "trigger": "give_capture_credit\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::give_capture_credit(${1:touchList}, ${2:string}, ${3:lastOwnerTeam}, ${4:isBFlag}, ${5:neutralizing})"},
	{ "trigger": "give_neutralized_credit\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::give_neutralized_credit(${1:touchList}, ${2:string}, ${3:lastOwnerTeam}, ${4:isBFlag})"},
	{ "trigger": "updateDomScores\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::updateDomScores()"},
	{ "trigger": "onScoreCloseMusic\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::onScoreCloseMusic()"},
	{ "trigger": "onRoundSwitch\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::onRoundSwitch()"},
	{ "trigger": "onPlayerKilled\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::onPlayerKilled(${1:eInflictor}, ${2:attacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime}, ${9:deathAnimDuration})"},
	{ "trigger": "killWhileContesting\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::killWhileContesting(${1:flag})"},
	{ "trigger": "updateattackermultikills\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::updateattackermultikills()"},
	{ "trigger": "getTeamFlagCount\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::getTeamFlagCount(${1:team})"},
	{ "trigger": "getFlagTeam\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::getFlagTeam()"},
	{ "trigger": "getBoundaryFlags\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::getBoundaryFlags()"},
	{ "trigger": "getBoundaryFlagSpawns\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::getBoundaryFlagSpawns(${1:team})"},
	{ "trigger": "getSpawnsBoundingFlag\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::getSpawnsBoundingFlag(${1:avoidflag})"},
	{ "trigger": "getOwnedAndBoundingFlagSpawns\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::getOwnedAndBoundingFlagSpawns(${1:team})"},
	{ "trigger": "getOwnedFlagSpawns\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::getOwnedFlagSpawns(${1:team})"},
	{ "trigger": "flagSetup\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::flagSetup()"},
	{ "trigger": "createFlagSpawnInfluencers\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::createFlagSpawnInfluencers()"},
	{ "trigger": "update_spawn_influencers\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::update_spawn_influencers(${1:team})"},
	{ "trigger": "addSpawnPointsForFlag\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::addSpawnPointsForFlag(${1:team}, ${2:flag_team}, ${3:flagSpawnName})"},
	{ "trigger": "change_dom_spawns\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::change_dom_spawns()"},
	{ "trigger": "dominated_challenge_check\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::dominated_challenge_check()"},
	{ "trigger": "dominated_check\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::dominated_check()"},
	{ "trigger": "updateCapsPerMinute\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::updateCapsPerMinute(${1:lastOwnerTeam})"},
	{ "trigger": "isScoreBoosting\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::isScoreBoosting(${1:player}, ${2:flag})"},
	{ "trigger": "onUpdateUseRate\t#using scripts\\mp\\gametypes\\dom;", "contents": "dom::onUpdateUseRate()"},
	{ "trigger": "To set the speed, make a K/V pair of speed / 100\t#using scripts\\mp\\_elevator;", "contents": "_elevator::To set the speed, make a K/V pair of speed / 100(${1:or whatever speed you want).})"},
	{ "trigger": "To set the speed, make a K/V pair of speed / 1\t#using scripts\\mp\\_elevator;", "contents": "_elevator::To set the speed, make a K/V pair of speed / 1(${1:or whatever speed you want).})"},
	{ "trigger": "To set the desired amount of angles, make a K/V pair of script_int / 90\t#using scripts\\mp\\_elevator;", "contents": "_elevator::To set the desired amount of angles, make a K/V pair of script_int / 90(${1:or whatever angle you want).})"},
	{ "trigger": "register\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::register()"},
	{ "trigger": "useKillstreakAITankDrop\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::useKillstreakAITankDrop(${1:hardpointType})"},
	{ "trigger": "crateLand\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::crateLand(${1:crate}, ${2:category}, ${3:owner}, ${4:team}, ${5:context})"},
	{ "trigger": "is_location_good\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::is_location_good(${1:location}, ${2:context})"},
	{ "trigger": "valid_location\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::valid_location(${1:location})"},
	{ "trigger": "HackedCallbackPre\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::HackedCallbackPre(${1:hacker})"},
	{ "trigger": "HackedCallbackPost\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::HackedCallbackPost(${1:hacker})"},
	{ "trigger": "ConfigureTeamPost\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::ConfigureTeamPost(${1:owner}, ${2:isHacked})"},
	{ "trigger": "ai_tank_killstreak_start\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::ai_tank_killstreak_start(${1:owner}, ${2:origin}, ${3:killstreak_id}, ${4:category})"},
	{ "trigger": "get_vehicle_name\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::get_vehicle_name(${1:vehicle_version})"},
	{ "trigger": "setup_gameplay_think\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::setup_gameplay_think(${1:category})"},
	{ "trigger": "tank_team_kill\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::tank_team_kill()"},
	{ "trigger": "kill_monitor\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::kill_monitor()"},
	{ "trigger": "tank_abort_think\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::tank_abort_think()"},
	{ "trigger": "tank_timeout_callback\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::tank_timeout_callback()"},
	{ "trigger": "tank_watch_owner_events\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::tank_watch_owner_events()"},
	{ "trigger": "tank_game_end_think\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::tank_game_end_think(${1:drone})"},
	{ "trigger": "stop_remote\t#using scripts\\mp\\killstreaks\\_ai_tank; dead", "contents": "ai_tank::stop_remote()"},
	{ "trigger": "tank_hacked_health_update\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::tank_hacked_health_update(${1:hacker})"},
	{ "trigger": "tank_damage_think\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::tank_damage_think()"},
	{ "trigger": "tank_low_health_fx\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::tank_low_health_fx()"},
	{ "trigger": "deleteOnKillbrush\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::deleteOnKillbrush(${1:player})"},
	{ "trigger": "tank_stun\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::tank_stun(${1:duration})"},
	{ "trigger": "emp_crazy_death\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::emp_crazy_death()"},
	{ "trigger": "tank_death_think\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::tank_death_think(${1:hardpointName})"},
	{ "trigger": "killstreak_stop_and_assert\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::killstreak_stop_and_assert(${1:hardpoint_name}, ${2:team}, ${3:killstreak_id}, ${4:assert_msg})"},
	{ "trigger": "tank_too_far_from_nav_mesh_abort_think\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::tank_too_far_from_nav_mesh_abort_think()"},
	{ "trigger": "tank_has_radar\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::tank_has_radar()"},
	{ "trigger": "tank_get_player_enemies\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::tank_get_player_enemies(${1:on_radar})"},
	{ "trigger": "tank_compute_enemy_position\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::tank_compute_enemy_position()"},
	{ "trigger": "valid_target\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::valid_target(${1:target}, ${2:team}, ${3:owner})"},
	{ "trigger": "startTankRemoteControl\t#using scripts\\mp\\killstreaks\\_ai_tank; self == player", "contents": "ai_tank::startTankRemoteControl(${1:drone})"},
	{ "trigger": "endTankRemoteControl\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::endTankRemoteControl(${1:drone}, ${2:exitRequestedByOwner})"},
	{ "trigger": "perform_recoil_missile_turret\t#using scripts\\mp\\killstreaks\\_ai_tank; self == drone", "contents": "ai_tank::perform_recoil_missile_turret(${1:player})"},
	{ "trigger": "perform_recoil\t#using scripts\\mp\\killstreaks\\_ai_tank; self == drone", "contents": "ai_tank::perform_recoil(${1:recoil_tag}, ${2:force_scale_factor}, ${3:force_z_offset})"},
	{ "trigger": "update_client_ammo\t#using scripts\\mp\\killstreaks\\_ai_tank; self == vehicle", "contents": "ai_tank::update_client_ammo(${1:ammo_count}, ${2:driver_only_update = false})"},
	{ "trigger": "tank_rocket_watch\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::tank_rocket_watch(${1:player})"},
	{ "trigger": "tank_rocket_watch_ai\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::tank_rocket_watch_ai()"},
	{ "trigger": "reload_rockets\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::reload_rockets(${1:player})"},
	{ "trigger": "WatchWater\t#using scripts\\mp\\killstreaks\\_ai_tank;", "contents": "ai_tank::WatchWater()"},
	{ "trigger": "Callback_ActorSpawned\t#using scripts\\mp\\gametypes\\_globallogic_actor;", "contents": "globallogic_actor::Callback_ActorSpawned(${1:spawner})"},
	{ "trigger": "Callback_ActorDamage\t#using scripts\\mp\\gametypes\\_globallogic_actor;", "contents": "globallogic_actor::Callback_ActorDamage(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:vDamageOrigin}, ${11:psOffsetTime}, ${12:boneIndex}, ${13:modelIndex}, ${14:surfaceType}, ${15:vSurfaceNormal})"},
	{ "trigger": "Callback_ActorKilled\t#using scripts\\mp\\gametypes\\_globallogic_actor;", "contents": "globallogic_actor::Callback_ActorKilled(${1:eInflictor}, ${2:attacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime})"},
	{ "trigger": "Callback_ActorCloned\t#using scripts\\mp\\gametypes\\_globallogic_actor;", "contents": "globallogic_actor::Callback_ActorCloned(${1:original})"},
	{ "trigger": "on_damage\t#using scripts\\mp\\gametypes\\_shellshock;", "contents": "shellshock::on_damage(${1:cause}, ${2:damage}, ${3:weapon})"},
	{ "trigger": "end_on_death\t#using scripts\\mp\\gametypes\\_shellshock;", "contents": "shellshock::end_on_death()"},
	{ "trigger": "end_on_timer\t#using scripts\\mp\\gametypes\\_shellshock;", "contents": "shellshock::end_on_timer(${1:timer})"},
	{ "trigger": "rcbomb_earthquake\t#using scripts\\mp\\gametypes\\_shellshock;", "contents": "shellshock::rcbomb_earthquake(${1:position})"},
	{ "trigger": "reset_meleeSnd\t#using scripts\\mp\\gametypes\\_shellshock;", "contents": "shellshock::reset_meleeSnd()"},
	{ "trigger": "getTeamopsTableID\t#using scripts\\mp\\_teamops;", "contents": "teamops::getTeamopsTableID()"},
	{ "trigger": "getID\t#using scripts\\mp\\_teamops;", "contents": "teamops::getID(${1:name})"},
	{ "trigger": "teamOpsAllowed\t#using scripts\\mp\\_teamops;", "contents": "teamops::teamOpsAllowed(${1:name})"},
	{ "trigger": "startTeamops\t#using scripts\\mp\\_teamops;", "contents": "teamops::startTeamops(${1:name})"},
	{ "trigger": "teamOpsWatcher\t#using scripts\\mp\\_teamops;", "contents": "teamops::teamOpsWatcher()"},
	{ "trigger": "stopTeamops\t#using scripts\\mp\\_teamops;", "contents": "teamops::stopTeamops()"},
	{ "trigger": "processPlayerEvent\t#using scripts\\mp\\_teamops;", "contents": "teamops::processPlayerEvent(${1:event}, ${2:player})"},
	{ "trigger": "processTeamEvent\t#using scripts\\mp\\_teamops;", "contents": "teamops::processTeamEvent(${1:event}, ${2:player}, ${3:team})"},
	{ "trigger": "updateTeamOps\t#using scripts\\mp\\_teamops;", "contents": "teamops::updateTeamOps(${1:event}, ${2:player}, ${3:team})"},
	{ "trigger": "teamOpsAcheived\t#using scripts\\mp\\_teamops;", "contents": "teamops::teamOpsAcheived(${1:player}, ${2:team})"},
	{ "trigger": "GetCompatibleOperation\t#using scripts\\mp\\_teamops;", "contents": "teamops::GetCompatibleOperation()"},
	{ "trigger": "watchTeamOpsTime\t#using scripts\\mp\\_teamops;", "contents": "teamops::watchTeamOpsTime()"},
	{ "trigger": "onPlayerKilled\t#using scripts\\mp\\_teamops;", "contents": "teamops::onPlayerKilled(${1:eInflictor}, ${2:attacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime}, ${9:deathAnimDuration})"},
	{ "trigger": "setupTeam\t#using scripts\\mp\\gametypes\\dm;", "contents": "dm::setupTeam(${1:team})"},
	{ "trigger": "onStartGameType\t#using scripts\\mp\\gametypes\\dm;", "contents": "dm::onStartGameType()"},
	{ "trigger": "onEndGame\t#using scripts\\mp\\gametypes\\dm;", "contents": "dm::onEndGame(${1:winningPlayer})"},
	{ "trigger": "onScoreCloseMusic\t#using scripts\\mp\\gametypes\\dm;", "contents": "dm::onScoreCloseMusic()"},
	{ "trigger": "onSpawnPlayer\t#using scripts\\mp\\gametypes\\dm;", "contents": "dm::onSpawnPlayer(${1:predictedSpawn})"},
	{ "trigger": "onPlayerKilled\t#using scripts\\mp\\gametypes\\dm;", "contents": "dm::onPlayerKilled(${1:eInflictor}, ${2:attacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime}, ${9:deathAnimDuration})"},
	{ "trigger": "start_gametype\t#using scripts\\mp\\_contracts;", "contents": "contracts::start_gametype()"},
	{ "trigger": "on_killed_hero_ability_enemy\t#using scripts\\mp\\_contracts;", "contents": "contracts::on_killed_hero_ability_enemy()"},
	{ "trigger": "on_killed_hero_weapon_enemy\t#using scripts\\mp\\_contracts;", "contents": "contracts::on_killed_hero_weapon_enemy()"},
	{ "trigger": "on_player_connect\t#using scripts\\mp\\_contracts;", "contents": "contracts::on_player_connect()"},
	{ "trigger": "can_process_contracts\t#using scripts\\mp\\_contracts;", "contents": "contracts::can_process_contracts()"},
	{ "trigger": "setup_player_contracts\t#using scripts\\mp\\_contracts;", "contents": "contracts::setup_player_contracts()"},
	{ "trigger": "is_contract_active\t#using scripts\\mp\\_contracts;", "contents": "contracts::is_contract_active(${1:challenge_index})"},
	{ "trigger": "on_hero_ability_kill\t#using scripts\\mp\\_contracts;", "contents": "contracts::on_hero_ability_kill(${1:ability}, ${2:victimAbility})"},
	{ "trigger": "on_hero_ability_medal\t#using scripts\\mp\\_contracts;", "contents": "contracts::on_hero_ability_medal()"},
	{ "trigger": "on_hero_ability_multikill\t#using scripts\\mp\\_contracts;", "contents": "contracts::on_hero_ability_multikill(${1:killcount}, ${2:ability})"},
	{ "trigger": "on_hero_weapon_multikill\t#using scripts\\mp\\_contracts;", "contents": "contracts::on_hero_weapon_multikill(${1:killcount}, ${2:weapon})"},
	{ "trigger": "on_player_score\t#using scripts\\mp\\_contracts;", "contents": "contracts::on_player_score(${1:delta_score})"},
	{ "trigger": "on_killstreak_score\t#using scripts\\mp\\_contracts;", "contents": "contracts::on_killstreak_score(${1:delta_score}, ${2:killstreak_purchased})"},
	{ "trigger": "contract_kills\t#using scripts\\mp\\_contracts;", "contents": "contracts::contract_kills(${1:data})"},
	{ "trigger": "add_stat\t#using scripts\\mp\\_contracts;", "contents": "contracts::add_stat(${1:contract_index}, ${2:delta})"},
	{ "trigger": "add_active_stat\t#using scripts\\mp\\_contracts;", "contents": "contracts::add_active_stat(${1:contract_index}, ${2:delta = 1})"},
	{ "trigger": "get_contract_stat\t#using scripts\\mp\\_contracts;", "contents": "contracts::get_contract_stat(${1:slot}, ${2:stat_name})"},
	{ "trigger": "set_contract_stat\t#using scripts\\mp\\_contracts;", "contents": "contracts::set_contract_stat(${1:slot}, ${2:stat_name}, ${3:stat_value})"},
	{ "trigger": "award_loot_xp_due\t#using scripts\\mp\\_contracts;", "contents": "contracts::award_loot_xp_due(${1:amount})"},
	{ "trigger": "get_hero_weapon_mask\t#using scripts\\mp\\_contracts;", "contents": "contracts::get_hero_weapon_mask(${1:attacker}, ${2:weapon})"},
	{ "trigger": "get_hero_ability_mask\t#using scripts\\mp\\_contracts;", "contents": "contracts::get_hero_ability_mask(${1:ability})"},
	{ "trigger": "contract_game_ended\t#using scripts\\mp\\_contracts;", "contents": "contracts::contract_game_ended(${1:data})"},
	{ "trigger": "contract_win\t#using scripts\\mp\\_contracts;", "contents": "contracts::contract_win(${1:winner})"},
	{ "trigger": "gametype_win\t#using scripts\\mp\\_contracts;", "contents": "contracts::gametype_win(${1:winner})"},
	{ "trigger": "on_offender_kill\t#using scripts\\mp\\_contracts;", "contents": "contracts::on_offender_kill()"},
	{ "trigger": "on_defender_kill\t#using scripts\\mp\\_contracts;", "contents": "contracts::on_defender_kill()"},
	{ "trigger": "on_headshot_kill\t#using scripts\\mp\\_contracts;", "contents": "contracts::on_headshot_kill()"},
	{ "trigger": "award_loot_xp\t#using scripts\\mp\\_contracts;", "contents": "contracts::award_loot_xp()"},
	{ "trigger": "contract_slot_met\t#using scripts\\mp\\_contracts;", "contents": "contracts::contract_slot_met(${1:slot})"},
	{ "trigger": "award_daily_contract\t#using scripts\\mp\\_contracts;", "contents": "contracts::award_daily_contract()"},
	{ "trigger": "award_weekly_contract\t#using scripts\\mp\\_contracts;", "contents": "contracts::award_weekly_contract()"},
	{ "trigger": "award_blackjack_contract\t#using scripts\\mp\\_contracts;", "contents": "contracts::award_blackjack_contract()"},
	{ "trigger": "register\t#using scripts\\mp\\killstreaks\\_killstreaks; killstreak name", "contents": "killstreaks::register(${1:killstreakType}, ${2:})"},
	{ "trigger": "is_registered\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::is_registered(${1:killstreakType})"},
	{ "trigger": "register_strings\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::register_strings(${1:killstreakType}, ${2:receivedText}, ${3:notUsableText}, ${4:inboundText}, ${5:inboundNearPlayerText}, ${6:hackedText}, ${7:utilizesAirspace = true}, ${8:isInventory = false})"},
	{ "trigger": "register_dialog\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::register_dialog()"},
	{ "trigger": "register_alt_weapon\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::register_alt_weapon(${1:killstreakType}, ${2:weaponName}, ${3:isInventory})"},
	{ "trigger": "register_remote_override_weapon\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::register_remote_override_weapon(${1:killstreakType}, ${2:weaponName}, ${3:isInventory})"},
	{ "trigger": "is_remote_override_weapon\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::is_remote_override_weapon(${1:killstreakType}, ${2:weapon})"},
	{ "trigger": "register_dev_dvars\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::register_dev_dvars(${1:killstreakType})"},
	{ "trigger": "register_tos_dvar\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::register_tos_dvar(${1:dvar})"},
	{ "trigger": "allow_assists\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::allow_assists(${1:killstreakType}, ${2:allow})"},
	{ "trigger": "set_team_kill_penalty_scale\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::set_team_kill_penalty_scale(${1:killstreakType}, ${2:scale}, ${3:isInventory})"},
	{ "trigger": "override_entity_camera_in_demo\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::override_entity_camera_in_demo(${1:killstreakType}, ${2:value}, ${3:isInventory})"},
	{ "trigger": "is_available\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::is_available(${1:killstreak})"},
	{ "trigger": "get_by_menu_name\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_by_menu_name(${1:killstreak})"},
	{ "trigger": "get_menu_name\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_menu_name(${1:killstreakType})"},
	{ "trigger": "get_level\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_level(${1:index}, ${2:killstreak})"},
	{ "trigger": "give_if_streak_count_matches\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::give_if_streak_count_matches(${1:index}, ${2:killstreak}, ${3:streakCount})"},
	{ "trigger": "give_for_streak\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::give_for_streak()"},
	{ "trigger": "is_an_a_killstreak\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::is_an_a_killstreak()"},
	{ "trigger": "give\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::give(${1:killstreakType}, ${2:streak}, ${3:suppressNotification}, ${4:noXP}, ${5:toBottom})"},
	{ "trigger": "take\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::take(${1:killstreak})"},
	{ "trigger": "remove_oldest\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::remove_oldest()"},
	{ "trigger": "give_internal\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::give_internal(${1:killstreakType}, ${2:do_not_update_death_count}, ${3:noXP}, ${4:toBottom})"},
	{ "trigger": "add_to_notification_queue\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::add_to_notification_queue(${1:menuName}, ${2:streakCount}, ${3:hardpointType}, ${4:noNotify})"},
	{ "trigger": "has_equipped\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::has_equipped()"},
	{ "trigger": "_get_from_weapon\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::_get_from_weapon(${1:weapon})"},
	{ "trigger": "get_from_weapon\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_from_weapon(${1:weapon})"},
	{ "trigger": "give_weapon\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::give_weapon(${1:weapon}, ${2:isinventory}, ${3:useStoredAmmo})"},
	{ "trigger": "activate_next\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::activate_next(${1:do_not_update_death_count})"},
	{ "trigger": "give_owned\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::give_owned()"},
	{ "trigger": "get_killstreak_quantity\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_killstreak_quantity(${1:killstreakWeapon})"},
	{ "trigger": "change_killstreak_quantity\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::change_killstreak_quantity(${1:killstreakWeapon}, ${2:delta})"},
	{ "trigger": "has_killstreak_in_class\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::has_killstreak_in_class(${1:killstreakMenuName})"},
	{ "trigger": "has_killstreak\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::has_killstreak(${1:killstreak})"},
	{ "trigger": "RecordKillstreakBeginDirect\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::RecordKillstreakBeginDirect(${1:recordStreakIndex})"},
	{ "trigger": "remove_when_done\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::remove_when_done(${1:killstreak}, ${2:hasKillstreakBeenUsed}, ${3:isFromInventory})"},
	{ "trigger": "useKillstreak\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::useKillstreak(${1:killstreak}, ${2:isFromInventory})"},
	{ "trigger": "remove_used_killstreak\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::remove_used_killstreak(${1:killstreak}, ${2:killstreakId}, ${3:take_weapon_after_use = true})"},
	{ "trigger": "take_weapon_after_use\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::take_weapon_after_use(${1:killstreakWeapon})"},
	{ "trigger": "get_top_killstreak\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_top_killstreak()"},
	{ "trigger": "get_if_top_killstreak_has_been_used\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_if_top_killstreak_has_been_used()"},
	{ "trigger": "get_top_killstreak_unique_id\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_top_killstreak_unique_id()"},
	{ "trigger": "get_killstreak_index_by_id\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_killstreak_index_by_id(${1:killstreakId})"},
	{ "trigger": "get_killstreak_momentum_cost\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_killstreak_momentum_cost(${1:killstreak})"},
	{ "trigger": "get_killstreak_for_weapon\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_killstreak_for_weapon(${1:weapon})"},
	{ "trigger": "get_killstreak_for_weapon_for_stats\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_killstreak_for_weapon_for_stats(${1:weapon})"},
	{ "trigger": "is_killstreak_weapon_assist_allowed\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::is_killstreak_weapon_assist_allowed(${1:weapon})"},
	{ "trigger": "get_killstreak_team_kill_penalty_scale\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_killstreak_team_kill_penalty_scale(${1:weapon})"},
	{ "trigger": "should_override_entity_camera_in_demo\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::should_override_entity_camera_in_demo(${1:player}, ${2:weapon})"},
	{ "trigger": "wait_till_hero_weapon_is_fully_on\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::wait_till_hero_weapon_is_fully_on(${1:weapon})"},
	{ "trigger": "track_weapon_usage\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::track_weapon_usage()"},
	{ "trigger": "killstreak_waiter\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::killstreak_waiter()"},
	{ "trigger": "should_delay_killstreak\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::should_delay_killstreak(${1:killstreakType})"},
	{ "trigger": "is_delayable_killstreak\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::is_delayable_killstreak(${1:killstreakType})"},
	{ "trigger": "get_xp_amount_for_killstreak\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_xp_amount_for_killstreak(${1:killstreakType})"},
	{ "trigger": "display_unavailable_time\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::display_unavailable_time()"},
	{ "trigger": "trigger_killstreak\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::trigger_killstreak(${1:killstreakType}, ${2:isFromInventory})"},
	{ "trigger": "add_to_killstreak_count\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::add_to_killstreak_count(${1:weapon})"},
	{ "trigger": "get_first_valid_killstreak_alt_weapon\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_first_valid_killstreak_alt_weapon(${1:killstreakType})"},
	{ "trigger": "should_give_killstreak\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::should_give_killstreak(${1:weapon})"},
	{ "trigger": "point_is_in_danger_area\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::point_is_in_danger_area(${1:point}, ${2:targetpos}, ${3:radius})"},
	{ "trigger": "print_killstreak_start_text\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::print_killstreak_start_text(${1:killstreakType}, ${2:owner}, ${3:team}, ${4:targetpos}, ${5:dangerRadius})"},
	{ "trigger": "play_killstreak_firewall_being_hacked_dialog\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::play_killstreak_firewall_being_hacked_dialog(${1:killstreakType}, ${2:killstreakId})"},
	{ "trigger": "play_killstreak_firewall_hacked_dialog\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::play_killstreak_firewall_hacked_dialog(${1:killstreakType}, ${2:killstreakId})"},
	{ "trigger": "play_killstreak_being_hacked_dialog\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::play_killstreak_being_hacked_dialog(${1:killstreakType}, ${2:killstreakId})"},
	{ "trigger": "play_killstreak_hacked_dialog\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::play_killstreak_hacked_dialog(${1:killstreakType}, ${2:killstreakId}, ${3:hacker})"},
	{ "trigger": "play_killstreak_start_dialog\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::play_killstreak_start_dialog(${1:killstreakType}, ${2:team}, ${3:killstreakId})"},
	{ "trigger": "play_killstreak_ready_sfx\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::play_killstreak_ready_sfx(${1:killstreaktype})"},
	{ "trigger": "play_killstreak_ready_dialog\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::play_killstreak_ready_dialog(${1:killstreakType}, ${2:taacomWaitTime})"},
	{ "trigger": "play_destroyed_dialog_on_owner\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::play_destroyed_dialog_on_owner(${1:killstreakType}, ${2:killstreakId})"},
	{ "trigger": "play_taacom_dialog_on_owner\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::play_taacom_dialog_on_owner(${1:dialogKey}, ${2:killstreakType}, ${3:killstreakId})"},
	{ "trigger": "play_pilot_dialog_on_owner\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::play_pilot_dialog_on_owner(${1:dialogKey}, ${2:killstreakType}, ${3:killstreakId})"},
	{ "trigger": "play_pilot_dialog\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::play_pilot_dialog(${1:dialogKey}, ${2:killstreakType}, ${3:killstreakId}, ${4:pilotIndex})"},
	{ "trigger": "play_taacom_dialog_response_on_owner\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::play_taacom_dialog_response_on_owner(${1:dialogKey}, ${2:killstreakType}, ${3:killstreakId})"},
	{ "trigger": "play_taacom_dialog_response\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::play_taacom_dialog_response(${1:dialogKey}, ${2:killstreakType}, ${3:killstreakId}, ${4:pilotIndex})"},
	{ "trigger": "get_random_pilot_index\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_random_pilot_index(${1:killstreakType})"},
	{ "trigger": "player_killstreak_threat_tracking\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::player_killstreak_threat_tracking(${1:killstreakType})"},
	{ "trigger": "get_killstreak_inform_dialog\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_killstreak_inform_dialog(${1:killstreakType})"},
	{ "trigger": "get_killstreak_usage_by_killstreak\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_killstreak_usage_by_killstreak(${1:killstreakType})"},
	{ "trigger": "get_killstreak_usage\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_killstreak_usage(${1:usageKey})"},
	{ "trigger": "on_player_spawned\t#using scripts\\mp\\killstreaks\\_killstreaks; self == player", "contents": "killstreaks::on_player_spawned()"},
	{ "trigger": "on_joined_team\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::on_joined_team()"},
	{ "trigger": "watch_for_remove_remote_weapon\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::watch_for_remove_remote_weapon()"},
	{ "trigger": "clear_ride_intro\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::clear_ride_intro(${1:delay})"},
	{ "trigger": "is_interacting_with_object\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::is_interacting_with_object()"},
	{ "trigger": "clear_using_remote\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::clear_using_remote(${1:immediate}, ${2:skipNotify})"},
	{ "trigger": "hide_tablet\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::hide_tablet()"},
	{ "trigger": "set_killstreak_delay_killcam\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::set_killstreak_delay_killcam(${1:killstreak_name})"},
	{ "trigger": "reset_killstreak_delay_killcam\t#using scripts\\mp\\killstreaks\\_killstreaks; self == player", "contents": "killstreaks::reset_killstreak_delay_killcam()"},
	{ "trigger": "hide_compass\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::hide_compass()"},
	{ "trigger": "unhide_compass\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::unhide_compass()"},
	{ "trigger": "setup_health\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::setup_health(${1:killstreak_ref}, ${2:max_health}, ${3:low_health})"},
	{ "trigger": "MonitorDamage\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::MonitorDamage(${1:killstreak_ref}, ${2:})"},
	{ "trigger": "defaultHackedHealthUpdateCallback\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::defaultHackedHealthUpdateCallback(${1:hacker})"},
	{ "trigger": "OnDamagePerWeapon\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::OnDamagePerWeapon(${1:killstreak_ref}, ${2:})"},
	{ "trigger": "get_old_damage\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::get_old_damage(${1:attacker}, ${2:weapon}, ${3:type}, ${4:damage}, ${5:allow_bullet_damage})"},
	{ "trigger": "configure_team\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::configure_team(${1:killstreakType}, ${2:killstreakId}, ${3:owner}, ${4:influencerType}, ${5:configureTeamPreFunction}, ${6:configureTeamPostFunction}, ${7:isHacked = false})"},
	{ "trigger": "trackActiveKillstreak\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::trackActiveKillstreak(${1:killstreak})"},
	{ "trigger": "getActiveKillstreaks\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::getActiveKillstreaks()"},
	{ "trigger": "configure_team_internal\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::configure_team_internal(${1:owner}, ${2:isHacked})"},
	{ "trigger": "WatchTeamChange\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::WatchTeamChange(${1:teamChangeNotify})"},
	{ "trigger": "should_not_timeout\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::should_not_timeout(${1:killstreak})"},
	{ "trigger": "WaitForTimeout\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::WaitForTimeout(${1:killstreak}, ${2:duration}, ${3:callback}, ${4:endCondition1}, ${5:endCondition2}, ${6:endCondition3})"},
	{ "trigger": "WaitForTimeoutBeep\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::WaitForTimeoutBeep(${1:killstreakBundle}, ${2:duration})"},
	{ "trigger": "WaitForTimeoutHacked\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::WaitForTimeoutHacked(${1:killstreak}, ${2:callback}, ${3:endCondition1}, ${4:endCondition2}, ${5:endCondition3})"},
	{ "trigger": "update_player_threat\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::update_player_threat(${1:player})"},
	{ "trigger": "update_non_player_threat\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::update_non_player_threat(${1:non_player})"},
	{ "trigger": "update_actor_threat\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::update_actor_threat(${1:actor})"},
	{ "trigger": "update_dog_threat\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::update_dog_threat(${1:dog})"},
	{ "trigger": "missile_valid_target_check\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::missile_valid_target_check(${1:missiletarget})"},
	{ "trigger": "update_missile_player_threat\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::update_missile_player_threat(${1:player})"},
	{ "trigger": "update_missile_dog_threat\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::update_missile_dog_threat(${1:dog})"},
	{ "trigger": "killstreak_assist\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::killstreak_assist(${1:victim}, ${2:assister}, ${3:killstreak})"},
	{ "trigger": "add_ricochet_protection\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::add_ricochet_protection(${1:killstreak_id}, ${2:owner}, ${3:origin}, ${4:ricochet_distance})"},
	{ "trigger": "set_ricochet_protection_endtime\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::set_ricochet_protection_endtime(${1:killstreak_id}, ${2:owner}, ${3:endTime})"},
	{ "trigger": "remove_ricochet_protection\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::remove_ricochet_protection(${1:killstreak_id}, ${2:owner})"},
	{ "trigger": "is_ricochet_protected\t#using scripts\\mp\\killstreaks\\_killstreaks;", "contents": "killstreaks::is_ricochet_protected(${1:player})"},
	{ "trigger": "on_player_connect\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::on_player_connect()"},
	{ "trigger": "on_free_player_connect\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::on_free_player_connect()"},
	{ "trigger": "on_joined_team\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::on_joined_team()"},
	{ "trigger": "on_joined_spectators\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::on_joined_spectators()"},
	{ "trigger": "track_played_time\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::track_played_time()"},
	{ "trigger": "update_player_times\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::update_player_times()"},
	{ "trigger": "update_played_time\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::update_played_time()"},
	{ "trigger": "update_time\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::update_time()"},
	{ "trigger": "update_balance_dvar\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::update_balance_dvar()"},
	{ "trigger": "change\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::change(${1:team})"},
	{ "trigger": "count_players\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::count_players()"},
	{ "trigger": "track_free_played_time\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::track_free_played_time()"},
	{ "trigger": "set_player_model\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::set_player_model(${1:team}, ${2:weapon})"},
	{ "trigger": "get_flag_model\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::get_flag_model(${1:teamRef})"},
	{ "trigger": "get_flag_carry_model\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::get_flag_carry_model(${1:teamRef})"},
	{ "trigger": "getTeamIndex\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::getTeamIndex(${1:team})"},
	{ "trigger": "getEnemyTeam\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::getEnemyTeam(${1:player_team})"},
	{ "trigger": "GetEnemyPlayers\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::GetEnemyPlayers()"},
	{ "trigger": "GetFriendlyPlayers\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::GetFriendlyPlayers()"},
	{ "trigger": "WaitUntilTeamChange\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::WaitUntilTeamChange(${1:player}, ${2:callback}, ${3:arg}, ${4:end_condition1}, ${5:end_condition2}, ${6:end_condition3})"},
	{ "trigger": "WaitUntilTeamChangeSingleTon\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::WaitUntilTeamChangeSingleTon(${1:player}, ${2:singletonString}, ${3:callback}, ${4:arg}, ${5:end_condition1}, ${6:end_condition2}, ${7:end_condition3})"},
	{ "trigger": "HideToSameTeam\t#using scripts\\mp\\teams\\_teams;", "contents": "teams::HideToSameTeam()"},
	{ "trigger": "InitTurretVehicle\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::InitTurretVehicle()"},
	{ "trigger": "OnPlayerSpawned\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::OnPlayerSpawned()"},
	{ "trigger": "OnPlayerConnect\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::OnPlayerConnect()"},
	{ "trigger": "ActivateEMP\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::ActivateEMP()"},
	{ "trigger": "OnPlaceEMP\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::OnPlaceEMP(${1:emp})"},
	{ "trigger": "DeployEmpTurret\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::DeployEmpTurret(${1:emp})"},
	{ "trigger": "HackedCallbackPre\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::HackedCallbackPre(${1:hacker})"},
	{ "trigger": "HackedCallbackPost\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::HackedCallbackPost(${1:hacker})"},
	{ "trigger": "DoneEMPFx\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::DoneEMPFx(${1:fxTagOrigin})"},
	{ "trigger": "PlayEMPFx\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::PlayEMPFx()"},
	{ "trigger": "on_timeout\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::on_timeout()"},
	{ "trigger": "OnCancelPlacement\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::OnCancelPlacement(${1:emp})"},
	{ "trigger": "OnTurretDamage\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::OnTurretDamage(${1:eInflictor}, ${2:attacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:vDamageOrigin}, ${11:psOffsetTime}, ${12:damageFromUnderneath}, ${13:modelIndex}, ${14:partName}, ${15:vSurfaceNormal})"},
	{ "trigger": "OnTurretDeath\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::OnTurretDeath(${1:inflictor}, ${2:attacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime})"},
	{ "trigger": "OnDeathAfterFrameEnd\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::OnDeathAfterFrameEnd(${1:attacker}, ${2:weapon})"},
	{ "trigger": "OnDeath\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::OnDeath(${1:attacker}, ${2:weapon})"},
	{ "trigger": "OnShutdown\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::OnShutdown(${1:emp})"},
	{ "trigger": "ShutdownEMP\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::ShutdownEMP(${1:emp})"},
	{ "trigger": "StopEMP\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::StopEMP(${1:currentTeam}, ${2:currentOwnerEntNum}, ${3:originalTeam}, ${4:killstreakID})"},
	{ "trigger": "StopEMPEffect\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::StopEMPEffect(${1:team}, ${2:ownerEntNum})"},
	{ "trigger": "StopEMPRule\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::StopEMPRule(${1:killstreakOriginalTeam}, ${2:killstreakId})"},
	{ "trigger": "HasActiveEMP\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::HasActiveEMP()"},
	{ "trigger": "TeamHasActiveEMP\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::TeamHasActiveEMP(${1:team})"},
	{ "trigger": "EnemyEMPActive\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::EnemyEMPActive()"},
	{ "trigger": "EnemyEMPOwner\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::EnemyEMPOwner()"},
	{ "trigger": "EMP_JamEnemies\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::EMP_JamEnemies(${1:empEnt}, ${2:hacked})"},
	{ "trigger": "EMPTracker\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::EMPTracker()"},
	{ "trigger": "UpdateEMP\t#using scripts\\mp\\killstreaks\\_emp;", "contents": "emp::UpdateEMP()"},
	{ "trigger": "start_gametype\t#using scripts\\mp\\gametypes\\_weaponobjects;", "contents": "weaponobjects::start_gametype()"},
	{ "trigger": "on_player_spawned\t#using scripts\\mp\\gametypes\\_weaponobjects; self == player", "contents": "weaponobjects::on_player_spawned()"},
	{ "trigger": "setfogsliders\t#using scripts\\mp\\_art;", "contents": "art::setfogsliders()"},
	{ "trigger": "tweakart\t#using scripts\\mp\\_art;", "contents": "art::tweakart()"},
	{ "trigger": "fovslidercheck\t#using scripts\\mp\\_art;", "contents": "art::fovslidercheck()"},
	{ "trigger": "dumpsettings\t#using scripts\\mp\\_art;", "contents": "art::dumpsettings()"},
	{ "trigger": "bestweapon_kill\t#using scripts\\mp\\gametypes\\_weapons;", "contents": "weapons::bestweapon_kill(${1:weapon})"},
	{ "trigger": "bestweapon_spawn\t#using scripts\\mp\\gametypes\\_weapons;", "contents": "weapons::bestweapon_spawn(${1:weapon}, ${2:options}, ${3:acvi})"},
	{ "trigger": "bestweapon_find\t#using scripts\\mp\\gametypes\\_weapons;", "contents": "weapons::bestweapon_find(${1:weapon}, ${2:options}, ${3:acvi})"},
	{ "trigger": "bestweapon_get\t#using scripts\\mp\\gametypes\\_weapons;", "contents": "weapons::bestweapon_get()"},
	{ "trigger": "showcaseweapon_get\t#using scripts\\mp\\gametypes\\_weapons;", "contents": "weapons::showcaseweapon_get()"},
	{ "trigger": "getTweakableDVarValue\t#using scripts\\mp\\gametypes\\_tweakables;", "contents": "tweakables::getTweakableDVarValue(${1:category}, ${2:name})"},
	{ "trigger": "getTweakableDVar\t#using scripts\\mp\\gametypes\\_tweakables;", "contents": "tweakables::getTweakableDVar(${1:category}, ${2:name})"},
	{ "trigger": "getTweakableValue\t#using scripts\\mp\\gametypes\\_tweakables;", "contents": "tweakables::getTweakableValue(${1:category}, ${2:name})"},
	{ "trigger": "getTweakableLastValue\t#using scripts\\mp\\gametypes\\_tweakables;", "contents": "tweakables::getTweakableLastValue(${1:category}, ${2:name})"},
	{ "trigger": "setTweakableValue\t#using scripts\\mp\\gametypes\\_tweakables;", "contents": "tweakables::setTweakableValue(${1:category}, ${2:name}, ${3:value})"},
	{ "trigger": "setTweakableLastValue\t#using scripts\\mp\\gametypes\\_tweakables;", "contents": "tweakables::setTweakableLastValue(${1:category}, ${2:name}, ${3:value})"},
	{ "trigger": "registerTweakable\t#using scripts\\mp\\gametypes\\_tweakables;", "contents": "tweakables::registerTweakable(${1:category}, ${2:name}, ${3:dvar}, ${4:value})"},
	{ "trigger": "setClientTweakable\t#using scripts\\mp\\gametypes\\_tweakables;", "contents": "tweakables::setClientTweakable(${1:category}, ${2:name})"},
	{ "trigger": "updateUITweakables\t#using scripts\\mp\\gametypes\\_tweakables;", "contents": "tweakables::updateUITweakables()"},
	{ "trigger": "updateServerDvar\t#using scripts\\mp\\gametypes\\_tweakables;", "contents": "tweakables::updateServerDvar(${1:dvar}, ${2:value})"},
	{ "trigger": "player_last_stand_stats\t#using scripts\\mp\\_laststand;", "contents": "laststand::player_last_stand_stats(${1:eInflictor}, ${2:attacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime}, ${9:deathAnimDuration})"},
	{ "trigger": "PlayerLastStand\t#using scripts\\mp\\_laststand;", "contents": "laststand::PlayerLastStand(${1:eInflictor}, ${2:attacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime}, ${9:delayOverride})"},
	{ "trigger": "MakeSureSwitchToWeapon\t#using scripts\\mp\\_laststand;", "contents": "laststand::MakeSureSwitchToWeapon()"},
	{ "trigger": "laststand_disable_player_weapons\t#using scripts\\mp\\_laststand;", "contents": "laststand::laststand_disable_player_weapons()"},
	{ "trigger": "laststand_enable_player_weapons\t#using scripts\\mp\\_laststand; self == player", "contents": "laststand::laststand_enable_player_weapons(${1:b_allow_grenades = true})"},
	{ "trigger": "laststand_clean_up_on_interrupt\t#using scripts\\mp\\_laststand;", "contents": "laststand::laststand_clean_up_on_interrupt(${1:playerBeingRevived}, ${2:reviverGun})"},
	{ "trigger": "laststand_clean_up_reviving_any\t#using scripts\\mp\\_laststand;", "contents": "laststand::laststand_clean_up_reviving_any(${1:playerBeingRevived})"},
	{ "trigger": "bleed_out\t#using scripts\\mp\\_laststand;", "contents": "laststand::bleed_out()"},
	{ "trigger": "watch_player_input\t#using scripts\\mp\\_laststand; self == player", "contents": "laststand::watch_player_input()"},
	{ "trigger": "watch_player_input_revive\t#using scripts\\mp\\_laststand; self == player", "contents": "laststand::watch_player_input_revive()"},
	{ "trigger": "watch_player_input_suicide\t#using scripts\\mp\\_laststand; self == player", "contents": "laststand::watch_player_input_suicide()"},
	{ "trigger": "precache\t#using scripts\\mp\\teams\\_teamset_axis;", "contents": "_teamset_axis::precache()"},
	{ "trigger": "pick_boost_number\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::pick_boost_number()"},
	{ "trigger": "on_joined_team\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::on_joined_team()"},
	{ "trigger": "set_blops_dialog\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::set_blops_dialog()"},
	{ "trigger": "set_cdp_dialog\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::set_cdp_dialog()"},
	{ "trigger": "on_player_spawned\t#using scripts\\mp\\gametypes\\_battlechatter; self == player", "contents": "battlechatter::on_player_spawned()"},
	{ "trigger": "dialog_chance\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::dialog_chance(${1:chanceKey})"},
	{ "trigger": "mpdialog_value\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::mpdialog_value(${1:mpdialogKey}, ${2:defaultValue})"},
	{ "trigger": "water_vox\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::water_vox()"},
	{ "trigger": "pain_vox\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::pain_vox(${1:meansofDeath})"},
	{ "trigger": "on_player_suicide_or_team_kill\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::on_player_suicide_or_team_kill(${1:player}, ${2:type})"},
	{ "trigger": "on_player_near_explodable\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::on_player_near_explodable(${1:object}, ${2:type})"},
	{ "trigger": "enemy_threat\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::enemy_threat()"},
	{ "trigger": "killed_by_sniper\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::killed_by_sniper(${1:sniper})"},
	{ "trigger": "player_killed\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::player_killed(${1:attacker}, ${2:killstreakType})"},
	{ "trigger": "say_kill_battle_chatter\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::say_kill_battle_chatter(${1:attacker}, ${2:weapon}, ${3:victim}, ${4:inflictor})"},
	{ "trigger": "grenade_tracking\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::grenade_tracking()"},
	{ "trigger": "missile_tracking\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::missile_tracking()"},
	{ "trigger": "incoming_projectile_alert\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::incoming_projectile_alert(${1:thrower}, ${2:projectile}, ${3:dialogKey}, ${4:waittime})"},
	{ "trigger": "sticky_grenade_tracking\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::sticky_grenade_tracking()"},
	{ "trigger": "hero_weapon_success_reaction\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::hero_weapon_success_reaction()"},
	{ "trigger": "play_promotion_reaction\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::play_promotion_reaction()"},
	{ "trigger": "gametype_specific_battle_chatter\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::gametype_specific_battle_chatter(${1:event}, ${2:team})"},
	{ "trigger": "play_death_vox\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::play_death_vox(${1:body}, ${2:attacker}, ${3:weapon}, ${4:meansOfDeath})"},
	{ "trigger": "get_death_vox\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::get_death_vox(${1:weapon}, ${2:meansOfDeath})"},
	{ "trigger": "play_killstreak_threat\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::play_killstreak_threat(${1:killstreakType})"},
	{ "trigger": "wait_play_dialog\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::wait_play_dialog(${1:waitTime}, ${2:dialogKey}, ${3:dialogFlags}, ${4:dialogBuffer}, ${5:enemy}, ${6:endNotify})"},
	{ "trigger": "play_dialog\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::play_dialog(${1:dialogKey}, ${2:dialogFlags}, ${3:dialogBuffer}, ${4:enemy})"},
	{ "trigger": "wait_dialog_buffer\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::wait_dialog_buffer(${1:dialogBuffer})"},
	{ "trigger": "stop_dialog\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::stop_dialog()"},
	{ "trigger": "wait_playback_time\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::wait_playback_time(${1:soundAlias})"},
	{ "trigger": "get_player_dialog_alias\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::get_player_dialog_alias(${1:dialogKey})"},
	{ "trigger": "count_keys\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::count_keys(${1:bundle}, ${2:dialogKey})"},
	{ "trigger": "get_random_key\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::get_random_key(${1:dialogKey})"},
	{ "trigger": "play_gadget_ready\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::play_gadget_ready(${1:weapon}, ${2:userFlip = false})"},
	{ "trigger": "play_gadget_activate\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::play_gadget_activate(${1:weapon})"},
	{ "trigger": "play_gadget_success\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::play_gadget_success(${1:weapon}, ${2:waitKey}, ${3:victim})"},
	{ "trigger": "play_throw_hatchet\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::play_throw_hatchet()"},
	{ "trigger": "get_enemy_players\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::get_enemy_players()"},
	{ "trigger": "get_friendly_players\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::get_friendly_players()"},
	{ "trigger": "can_play_dialog\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::can_play_dialog(${1:teamOnly})"},
	{ "trigger": "get_closest_player_enemy\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::get_closest_player_enemy(${1:origin}, ${2:teamOnly})"},
	{ "trigger": "get_closest_player_ally\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::get_closest_player_ally(${1:teamOnly})"},
	{ "trigger": "check_boost_start_conversation\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::check_boost_start_conversation()"},
	{ "trigger": "pick_boost_players\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::pick_boost_players(${1:player1}, ${2:player2})"},
	{ "trigger": "game_end_vox\t#using scripts\\mp\\gametypes\\_battlechatter;", "contents": "battlechatter::game_end_vox(${1:winner})"},
	{ "trigger": "InitSentinel\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::InitSentinel()"},
	{ "trigger": "driving_enter\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::driving_enter(${1:params})"},
	{ "trigger": "drone_pain_for_time\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::drone_pain_for_time(${1:time}, ${2:stablizeParam}, ${3:restoreLookPoint}, ${4:weapon})"},
	{ "trigger": "drone_pain\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::drone_pain(${1:eAttacker}, ${2:damageType}, ${3:hitPoint}, ${4:hitDirection}, ${5:hitLocationInfo}, ${6:partName}, ${7:weapon})"},
	{ "trigger": "SentinelDamageOverride\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::SentinelDamageOverride(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:vDamageOrigin}, ${11:psOffsetTime}, ${12:damageFromUnderneath}, ${13:modelIndex}, ${14:partName}, ${15:vSurfaceNormal})"},
	{ "trigger": "destroyed_cb\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::destroyed_cb(${1:attacker}, ${2:weapon})"},
	{ "trigger": "low_health_cb\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::low_health_cb(${1:attacker}, ${2:weapon})"},
	{ "trigger": "CalcSpawnOrigin\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::CalcSpawnOrigin(${1:origin}, ${2:angles})"},
	{ "trigger": "ActivateSentinel\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::ActivateSentinel(${1:killstreakType})"},
	{ "trigger": "HackedCallbackPre\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::HackedCallbackPre(${1:hacker})"},
	{ "trigger": "HackedCallbackPost\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::HackedCallbackPost(${1:hacker})"},
	{ "trigger": "ConfigureTeamPost\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::ConfigureTeamPost(${1:owner}, ${2:isHacked})"},
	{ "trigger": "WatchGameEnded\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::WatchGameEnded()"},
	{ "trigger": "StartSentinelRemoteControl\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::StartSentinelRemoteControl(${1:sentinel})"},
	{ "trigger": "EndSentinelRemoteControl\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::EndSentinelRemoteControl(${1:sentinel}, ${2:exitRequestedByOwner})"},
	{ "trigger": "OnTimeout\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::OnTimeout()"},
	{ "trigger": "HealthMonitor\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::HealthMonitor()"},
	{ "trigger": "SentinelDistanceFailure\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::SentinelDistanceFailure()"},
	{ "trigger": "WatchDeath\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::WatchDeath()"},
	{ "trigger": "WatchTeamChange\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::WatchTeamChange()"},
	{ "trigger": "WatchWater\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::WatchWater()"},
	{ "trigger": "WatchShutdown\t#using scripts\\mp\\killstreaks\\_sentinel;", "contents": "sentinel::WatchShutdown()"},
	{ "trigger": "setAdvertisedStatus\t#using scripts\\mp\\_gameadvertisement;", "contents": "gameadvertisement::setAdvertisedStatus(${1:onOff})"},
	{ "trigger": "sessionAdvertisementCheck\t#using scripts\\mp\\_gameadvertisement;", "contents": "gameadvertisement::sessionAdvertisementCheck()"},
	{ "trigger": "getGameTypeRules\t#using scripts\\mp\\_gameadvertisement;", "contents": "gameadvertisement::getGameTypeRules()"},
	{ "trigger": "teamScoreLimitCheck\t#using scripts\\mp\\_gameadvertisement;", "contents": "gameadvertisement::teamScoreLimitCheck(${1:ruleScorePercent})"},
	{ "trigger": "timeLimitCheck\t#using scripts\\mp\\_gameadvertisement;", "contents": "gameadvertisement::timeLimitCheck(${1:ruleTimeLeft})"},
	{ "trigger": "default_rules\t#using scripts\\mp\\_gameadvertisement;", "contents": "gameadvertisement::default_rules()"},
	{ "trigger": "gun_rules\t#using scripts\\mp\\_gameadvertisement;", "contents": "gameadvertisement::gun_rules()"},
	{ "trigger": "enable_hacking\t#using scripts\\mp\\killstreaks\\_killstreak_hacking;", "contents": "killstreak_hacking::enable_hacking(${1:killstreakName}, ${2:preHackFunction}, ${3:postHackFunction})"},
	{ "trigger": "disable_hacking\t#using scripts\\mp\\killstreaks\\_killstreak_hacking;", "contents": "killstreak_hacking::disable_hacking()"},
	{ "trigger": "hackerFX\t#using scripts\\mp\\killstreaks\\_killstreak_hacking;", "contents": "killstreak_hacking::hackerFX()"},
	{ "trigger": "hackerLoopFX\t#using scripts\\mp\\killstreaks\\_killstreak_hacking;", "contents": "killstreak_hacking::hackerLoopFX()"},
	{ "trigger": "override_hacked_killstreak_reference\t#using scripts\\mp\\killstreaks\\_killstreak_hacking;", "contents": "killstreak_hacking::override_hacked_killstreak_reference(${1:KillstreakRef})"},
	{ "trigger": "get_hacked_timeout_duration_ms\t#using scripts\\mp\\killstreaks\\_killstreak_hacking;", "contents": "killstreak_hacking::get_hacked_timeout_duration_ms()"},
	{ "trigger": "set_vehicle_drivable_time_starting_now\t#using scripts\\mp\\killstreaks\\_killstreak_hacking; self == player", "contents": "killstreak_hacking::set_vehicle_drivable_time_starting_now(${1:killstreak}, ${2:duration_ms = (-1)})"},
	{ "trigger": "_update_health\t#using scripts\\mp\\killstreaks\\_killstreak_hacking;", "contents": "killstreak_hacking::_update_health(${1:hacker})"},
	{ "trigger": "bot_update\t#using scripts\\mp\\bots\\_bot_dom;", "contents": "bot_dom::bot_update()"},
	{ "trigger": "bot_pre_combat\t#using scripts\\mp\\bots\\_bot_dom;", "contents": "bot_dom::bot_pre_combat()"},
	{ "trigger": "bot_idle\t#using scripts\\mp\\bots\\_bot_dom;", "contents": "bot_dom::bot_idle()"},
	{ "trigger": "bot_update_threat_goal\t#using scripts\\mp\\bots\\_bot_dom;", "contents": "bot_dom::bot_update_threat_goal()"},
	{ "trigger": "get_capturing_flag\t#using scripts\\mp\\bots\\_bot_dom;", "contents": "bot_dom::get_capturing_flag()"},
	{ "trigger": "get_best_flag\t#using scripts\\mp\\bots\\_bot_dom;", "contents": "bot_dom::get_best_flag()"},
	{ "trigger": "get_unused_explosion\t#using scripts\\mp\\_destructible;", "contents": "destructible::get_unused_explosion()"},
	{ "trigger": "physics_explosion_and_rumble\t#using scripts\\mp\\_destructible;", "contents": "destructible::physics_explosion_and_rumble(${1:origin}, ${2:radius}, ${3:physics_explosion})"},
	{ "trigger": "event_callback\t#using scripts\\mp\\_destructible; self == the destructible object (like the car or barrel)", "contents": "destructible::event_callback(${1:destructible_event}, ${2:attacker}, ${3:weapon})"},
	{ "trigger": "simple_explosion\t#using scripts\\mp\\_destructible;", "contents": "destructible::simple_explosion(${1:attacker})"},
	{ "trigger": "simple_timed_explosion\t#using scripts\\mp\\_destructible;", "contents": "destructible::simple_timed_explosion(${1:destructible_event}, ${2:attacker})"},
	{ "trigger": "complex_explosion\t#using scripts\\mp\\_destructible;", "contents": "destructible::complex_explosion(${1:attacker}, ${2:max_radius})"},
	{ "trigger": "car_explosion\t#using scripts\\mp\\_destructible;", "contents": "destructible::car_explosion(${1:attacker}, ${2:physics_explosion})"},
	{ "trigger": "tank_grenade_stuck_think\t#using scripts\\mp\\_destructible;", "contents": "destructible::tank_grenade_stuck_think()"},
	{ "trigger": "tank_grenade_stuck_explode\t#using scripts\\mp\\_destructible;", "contents": "destructible::tank_grenade_stuck_explode(${1:missile})"},
	{ "trigger": "tank_hacked_c4\t#using scripts\\mp\\_destructible;", "contents": "destructible::tank_hacked_c4(${1:tank})"},
	{ "trigger": "car_death_think\t#using scripts\\mp\\_destructible;", "contents": "destructible::car_death_think()"},
	{ "trigger": "car_grenade_stuck_think\t#using scripts\\mp\\_destructible;", "contents": "destructible::car_grenade_stuck_think()"},
	{ "trigger": "car_grenade_stuck_explode\t#using scripts\\mp\\_destructible;", "contents": "destructible::car_grenade_stuck_explode(${1:missile})"},
	{ "trigger": "car_hacked_c4\t#using scripts\\mp\\_destructible;", "contents": "destructible::car_hacked_c4(${1:car})"},
	{ "trigger": "car_death_notify\t#using scripts\\mp\\_destructible;", "contents": "destructible::car_death_notify()"},
	{ "trigger": "car_fire_think\t#using scripts\\mp\\_destructible;", "contents": "destructible::car_fire_think(${1:attacker})"},
	{ "trigger": "CodeCallback_DestructibleEvent\t#using scripts\\mp\\_destructible;", "contents": "destructible::CodeCallback_DestructibleEvent(${1:event}, ${2:param1}, ${3:param2}, ${4:param3}, ${5:param4})"},
	{ "trigger": "breakAfter\t#using scripts\\mp\\_destructible;", "contents": "destructible::breakAfter(${1:time}, ${2:damage}, ${3:piece})"},
	{ "trigger": "explosive_incendiary_explosion\t#using scripts\\mp\\_destructible;", "contents": "destructible::explosive_incendiary_explosion(${1:attacker}, ${2:explosion_radius}, ${3:physics_explosion})"},
	{ "trigger": "explosive_electrical_explosion\t#using scripts\\mp\\_destructible;", "contents": "destructible::explosive_electrical_explosion(${1:attacker}, ${2:explosion_radius}, ${3:physics_explosion})"},
	{ "trigger": "explosive_concussive_explosion\t#using scripts\\mp\\_destructible;", "contents": "destructible::explosive_concussive_explosion(${1:attacker}, ${2:explosion_radius}, ${3:physics_explosion})"},
	{ "trigger": "precachehelicopter\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::precachehelicopter(${1:model}, ${2:type})"},
	{ "trigger": "useKillstreakHelicopter\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::useKillstreakHelicopter(${1:hardpointType})"},
	{ "trigger": "announceHelicopterInbound\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::announceHelicopterInbound(${1:hardpointType})"},
	{ "trigger": "heli_path_graph\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_path_graph()"},
	{ "trigger": "heli_get_dvar_int\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_get_dvar_int(${1:dvar}, ${2:def})"},
	{ "trigger": "heli_get_dvar\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_get_dvar(${1:dvar}, ${2:def})"},
	{ "trigger": "set_goal_pos\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::set_goal_pos(${1:goalPos}, ${2:stop})"},
	{ "trigger": "spawn_helicopter\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::spawn_helicopter(${1:owner}, ${2:origin}, ${3:angles}, ${4:model}, ${5:targetname}, ${6:target_offset}, ${7:hardpointType}, ${8:killstreak_id})"},
	{ "trigger": "OnFlakDroneDestroyed\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::OnFlakDroneDestroyed()"},
	{ "trigger": "explodeOnContact\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::explodeOnContact(${1:hardpointtype})"},
	{ "trigger": "getValidProtectLocationStart\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::getValidProtectLocationStart(${1:random_path}, ${2:protectLocation}, ${3:destination})"},
	{ "trigger": "getValidRandomLeaveNode\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::getValidRandomLeaveNode(${1:start})"},
	{ "trigger": "getValidRandomStartNode\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::getValidRandomStartNode(${1:dest})"},
	{ "trigger": "getValidRandomCrashNode\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::getValidRandomCrashNode(${1:start})"},
	{ "trigger": "ConfigureTeamPost\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::ConfigureTeamPost(${1:owner}, ${2:isHacked})"},
	{ "trigger": "HackedCallbackPost\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::HackedCallbackPost(${1:hacker})"},
	{ "trigger": "heli_think\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_think(${1:owner}, ${2:startnode}, ${3:heli_team}, ${4:missilesEnabled}, ${5:protectLocation}, ${6:hardpointType}, ${7:armored}, ${8:killstreak_id})"},
	{ "trigger": "AutoStopSound\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::AutoStopSound()"},
	{ "trigger": "heli_existance\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_existance()"},
	{ "trigger": "create_flare_ent\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::create_flare_ent(${1:offset})"},
	{ "trigger": "heli_missile_regen\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_missile_regen()"},
	{ "trigger": "heli_targeting\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_targeting(${1:missilesEnabled}, ${2:hardpointType})"},
	{ "trigger": "canTargetPlayer_turret\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::canTargetPlayer_turret(${1:player}, ${2:hardpointType})"},
	{ "trigger": "canTargetActor_turret\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::canTargetActor_turret(${1:actor}, ${2:hardpointType})"},
	{ "trigger": "getVerticalTan\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::getVerticalTan(${1:startOrigin}, ${2:endOrigin})"},
	{ "trigger": "canTargetPlayer_missile\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::canTargetPlayer_missile(${1:player}, ${2:hardpointType})"},
	{ "trigger": "canTargetDog_turret\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::canTargetDog_turret(${1:dog})"},
	{ "trigger": "canTargetDog_missile\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::canTargetDog_missile(${1:dog})"},
	{ "trigger": "canTargetTank_turret\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::canTargetTank_turret(${1:tank})"},
	{ "trigger": "assignPrimaryTargets\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::assignPrimaryTargets(${1:targets})"},
	{ "trigger": "assignSecondaryTargets\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::assignSecondaryTargets(${1:targets})"},
	{ "trigger": "heli_reset\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_reset()"},
	{ "trigger": "heli_wait\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_wait(${1:waittime})"},
	{ "trigger": "heli_hover\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_hover()"},
	{ "trigger": "wait_for_killed\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::wait_for_killed()"},
	{ "trigger": "wait_for_bda_timeout\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::wait_for_bda_timeout()"},
	{ "trigger": "play_bda_dialog\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::play_bda_dialog()"},
	{ "trigger": "heli_hacked_health_update\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_hacked_health_update(${1:hacker})"},
	{ "trigger": "heli_damage_monitor\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_damage_monitor(${1:hardpointtype})"},
	{ "trigger": "heli_set_active_camo_state\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_set_active_camo_state(${1:state})"},
	{ "trigger": "heli_active_camo_damage_update\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_active_camo_damage_update(${1:damage})"},
	{ "trigger": "heli_active_camo_damage_disable\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_active_camo_damage_disable()"},
	{ "trigger": "heli_health\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_health(${1:hardpointType}, ${2:playerNotify})"},
	{ "trigger": "heli_evasive\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_evasive(${1:hardpointType})"},
	{ "trigger": "notify_player\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::notify_player(${1:player}, ${2:playerNotify}, ${3:delay})"},
	{ "trigger": "play_going_down_vo\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::play_going_down_vo(${1:delay})"},
	{ "trigger": "heli_crash\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_crash(${1:hardpointType}, ${2:player}, ${3:playerNotify})"},
	{ "trigger": "damagedRotorFX\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::damagedRotorFX()"},
	{ "trigger": "waitThenExplode\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::waitThenExplode(${1:time})"},
	{ "trigger": "crashOnNearestCrashPath\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::crashOnNearestCrashPath(${1:hardpointType})"},
	{ "trigger": "CheckHelicopterTag\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::CheckHelicopterTag(${1:tagName})"},
	{ "trigger": "heli_secondary_explosions\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_secondary_explosions()"},
	{ "trigger": "heli_spin\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_spin(${1:speed})"},
	{ "trigger": "spinSoundShortly\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::spinSoundShortly()"},
	{ "trigger": "trail_fx\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::trail_fx(${1:trail_fx}, ${2:trail_tag}, ${3:stop_notify})"},
	{ "trigger": "destroyHelicopter\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::destroyHelicopter()"},
	{ "trigger": "heli_explode\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_explode()"},
	{ "trigger": "clear_client_flags\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::clear_client_flags()"},
	{ "trigger": "heli_leave\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_leave()"},
	{ "trigger": "heli_fly\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_fly(${1:currentnode}, ${2:startwait}, ${3:hardpointType})"},
	{ "trigger": "heli_random_point_in_radius\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_random_point_in_radius(${1:protectDest}, ${2:nodeHeight})"},
	{ "trigger": "heli_get_protect_spot\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_get_protect_spot(${1:protectDest}, ${2:nodeHeight})"},
	{ "trigger": "wait_or_waittill\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::wait_or_waittill(${1:time}, ${2:msg1}, ${3:msg2}, ${4:msg3})"},
	{ "trigger": "set_heli_speed_normal\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::set_heli_speed_normal()"},
	{ "trigger": "set_heli_speed_evasive\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::set_heli_speed_evasive()"},
	{ "trigger": "set_heli_speed_hover\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::set_heli_speed_hover()"},
	{ "trigger": "is_targeted\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::is_targeted()"},
	{ "trigger": "heli_mobilespawn\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_mobilespawn(${1:protectDest})"},
	{ "trigger": "heli_protect\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::heli_protect(${1:startNode}, ${2:protectDest}, ${3:hardpointType}, ${4:heli_team})"},
	{ "trigger": "updateSpeedOnLock\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::updateSpeedOnLock()"},
	{ "trigger": "updateSpeed\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::updateSpeed()"},
	{ "trigger": "updateTargetYaw\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::updateTargetYaw()"},
	{ "trigger": "fire_missile\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::fire_missile(${1:sMissileType}, ${2:iShots}, ${3:eTarget})"},
	{ "trigger": "check_owner\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::check_owner(${1:hardpointType})"},
	{ "trigger": "attack_targets\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::attack_targets(${1:missilesEnabled}, ${2:hardpointType})"},
	{ "trigger": "attack_secondary\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::attack_secondary(${1:hardpointType})"},
	{ "trigger": "turret_target_check\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::turret_target_check(${1:turretTarget}, ${2:attackAngle})"},
	{ "trigger": "target_cone_check\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::target_cone_check(${1:target}, ${2:coneCosine})"},
	{ "trigger": "missile_support\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::missile_support(${1:target_player}, ${2:rof}, ${3:instantfire}, ${4:endon_notify})"},
	{ "trigger": "attack_primary\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::attack_primary(${1:hardpointType})"},
	{ "trigger": "turret_target_flag\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::turret_target_flag(${1:turrettarget})"},
	{ "trigger": "waittill_confirm_location\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::waittill_confirm_location()"},
	{ "trigger": "selectHelicopterLocation\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::selectHelicopterLocation(${1:hardpointtype})"},
	{ "trigger": "processCopterAssist\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::processCopterAssist(${1:destroyedCopter}, ${2:damagedone})"},
	{ "trigger": "SAMTurretWatcher\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::SAMTurretWatcher()"},
	{ "trigger": "PlayPilotDialog\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::PlayPilotDialog(${1:dialog}, ${2:time}, ${3:voice}, ${4:shouldWait})"},
	{ "trigger": "playPilotTalking\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::playPilotTalking(${1:shouldWait}, ${2:soundAlias})"},
	{ "trigger": "watchForEarlyLeave\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::watchForEarlyLeave(${1:chopper})"},
	{ "trigger": "watchForEMP\t#using scripts\\mp\\killstreaks\\_helicopter;", "contents": "helicopter::watchForEMP()"},
	{ "trigger": "tryUseQRDrone\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::tryUseQRDrone(${1:lifeId})"},
	{ "trigger": "giveCarryQRDrone\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::giveCarryQRDrone(${1:lifeId}, ${2:streakName})"},
	{ "trigger": "createCarryQRDrone\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::createCarryQRDrone(${1:streakName}, ${2:owner})"},
	{ "trigger": "watchForAttack\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::watchForAttack()"},
	{ "trigger": "setCarryingQRDrone\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::setCarryingQRDrone(${1:carryQRDrone})"},
	{ "trigger": "carryQRDrone_setCarried\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::carryQRDrone_setCarried(${1:carrier})"},
	{ "trigger": "isInRemoteNoDeploy\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::isInRemoteNoDeploy()"},
	{ "trigger": "updateCarryQRDronePlacement\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::updateCarryQRDronePlacement(${1:carryQRDrone})"},
	{ "trigger": "carryQRDrone_handleExistence\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::carryQRDrone_handleExistence()"},
	{ "trigger": "removeRemoteWeapon\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::removeRemoteWeapon()"},
	{ "trigger": "startQRDrone\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::startQRDrone(${1:lifeId}, ${2:streakName}, ${3:origin}, ${4:angles})"},
	{ "trigger": "lockPlayerForQRDroneLaunch\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::lockPlayerForQRDroneLaunch()"},
	{ "trigger": "clearPlayerLockFromQRDroneLaunch\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::clearPlayerLockFromQRDroneLaunch(${1:lockSpot})"},
	{ "trigger": "createQRDrone\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::createQRDrone(${1:lifeId}, ${2:owner}, ${3:streakName}, ${4:origin}, ${5:angles}, ${6:killstreak_id})"},
	{ "trigger": "QRDrone_ride\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_ride(${1:lifeId}, ${2:QRDrone}, ${3:streakName})"},
	{ "trigger": "QRDrone_delayLaunchDialog\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_delayLaunchDialog(${1:QRDrone})"},
	{ "trigger": "QRDrone_Unlink\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_Unlink(${1:QRDrone})"},
	{ "trigger": "QRDrone_endride\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_endride(${1:QRDrone})"},
	{ "trigger": "play_lockon_sounds\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::play_lockon_sounds(${1:player})"},
	{ "trigger": "enemy_locking\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::enemy_locking()"},
	{ "trigger": "enemy_locked\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::enemy_locked()"},
	{ "trigger": "QRDrone_freezeBuffer\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_freezeBuffer()"},
	{ "trigger": "QRDrone_playerExit\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_playerExit(${1:QRDrone})"},
	{ "trigger": "touchedKillbrush\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::touchedKillbrush()"},
	{ "trigger": "deleteOnKillbrush\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::deleteOnKillbrush(${1:player})"},
	{ "trigger": "QRDrone_force_destroy\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_force_destroy()"},
	{ "trigger": "QRDrone_get_damage_effect\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_get_damage_effect(${1:health_pct})"},
	{ "trigger": "QRDrone_play_single_fx_on_tag\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_play_single_fx_on_tag(${1:effect}, ${2:tag})"},
	{ "trigger": "QRDrone_update_damage_fx\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_update_damage_fx(${1:health_percent})"},
	{ "trigger": "QRDrone_damageWatcher\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_damageWatcher()"},
	{ "trigger": "QRDrone_stun\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_stun(${1:duration})"},
	{ "trigger": "QRDrone_death\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_death(${1:attacker}, ${2:weapon}, ${3:dir}, ${4:damageType})"},
	{ "trigger": "death_fx\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::death_fx()"},
	{ "trigger": "QRDrone_crash_movement\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_crash_movement(${1:attacker}, ${2:hitdir})"},
	{ "trigger": "QRDrone_dmg_snd\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_dmg_snd()"},
	{ "trigger": "QRDrone_fire_for_time\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_fire_for_time(${1:totalFireTime})"},
	{ "trigger": "QRDrone_crash_accel\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_crash_accel()"},
	{ "trigger": "QRDrone_collision\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_collision()"},
	{ "trigger": "QRDrone_watch_distance\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_watch_distance(${1:zoffset}, ${2:minHeightOverride})"},
	{ "trigger": "QRDrone_in_range\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_in_range()"},
	{ "trigger": "QRDrone_staticFade\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_staticFade(${1:staticAlpha})"},
	{ "trigger": "QRDrone_rangeCountdown\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_rangeCountdown()"},
	{ "trigger": "QRDrone_explode_on_notify\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_explode_on_notify(${1:killstreak_id})"},
	{ "trigger": "QRDrone_explode_on_game_end\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_explode_on_game_end()"},
	{ "trigger": "QRDrone_leave_on_timeout\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_leave_on_timeout(${1:killstreakName})"},
	{ "trigger": "QRDrone_leave_on_timeout_callback\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_leave_on_timeout_callback()"},
	{ "trigger": "QRDrone_leave\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_leave()"},
	{ "trigger": "QRDrone_exit_button_pressed\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_exit_button_pressed()"},
	{ "trigger": "QRDrone_watch_for_exit\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_watch_for_exit()"},
	{ "trigger": "QRDrone_cleanup\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_cleanup()"},
	{ "trigger": "QRDrone_light_fx\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_light_fx()"},
	{ "trigger": "QRDrone_dialog\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_dialog(${1:dialogGroup})"},
	{ "trigger": "QRDrone_watchHeliProximity\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_watchHeliProximity()"},
	{ "trigger": "QRDrone_detonateWaiter\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_detonateWaiter()"},
	{ "trigger": "QRDrone_fireGuns\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_fireGuns(${1:QRDrone})"},
	{ "trigger": "QRDrone_blowup\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::QRDrone_blowup(${1:attacker}, ${2:weapon})"},
	{ "trigger": "setVisionsetWaiter\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::setVisionsetWaiter()"},
	{ "trigger": "destroyHud\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::destroyHud()"},
	{ "trigger": "set_static_alpha\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::set_static_alpha(${1:alpha}, ${2:drone})"},
	{ "trigger": "flash_signal_failure\t#using scripts\\mp\\killstreaks\\_qrdrone;", "contents": "qrdrone::flash_signal_failure(${1:drone})"},
	{ "trigger": "on_player_spawned\t#using scripts\\mp\\_pickup_items; self == player", "contents": "pickup_items::on_player_spawned()"},
	{ "trigger": "start_gametype\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::start_gametype()"},
	{ "trigger": "get_visual_for_trigger\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::get_visual_for_trigger(${1:trigger}, ${2:pickup_models})"},
	{ "trigger": "set_pickup_bobbing\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::set_pickup_bobbing()"},
	{ "trigger": "set_pickup_rotation\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::set_pickup_rotation()"},
	{ "trigger": "get_item_for_pickup\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::get_item_for_pickup()"},
	{ "trigger": "cycle_item\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::cycle_item()"},
	{ "trigger": "get_item_from_string_ammo\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::get_item_from_string_ammo(${1:perks_string})"},
	{ "trigger": "get_item_from_string_damage\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::get_item_from_string_damage(${1:perks_string})"},
	{ "trigger": "get_item_from_string_health\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::get_item_from_string_health(${1:perks_string})"},
	{ "trigger": "get_item_from_string_perk\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::get_item_from_string_perk(${1:perks_string})"},
	{ "trigger": "get_item_from_string_weapon\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::get_item_from_string_weapon(${1:weapon_and_attachments_string})"},
	{ "trigger": "get_item_from_string\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::get_item_from_string(${1:item_string})"},
	{ "trigger": "pickup_item_respawn_time\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::pickup_item_respawn_time()"},
	{ "trigger": "pickup_item_sound_pickup\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::pickup_item_sound_pickup()"},
	{ "trigger": "pickup_item_sound_respawn\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::pickup_item_sound_respawn()"},
	{ "trigger": "on_touch\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::on_touch(${1:player})"},
	{ "trigger": "respawn_pickup\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::respawn_pickup()"},
	{ "trigger": "respawn_all_pickups\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::respawn_all_pickups()"},
	{ "trigger": "on_touch_ammo\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::on_touch_ammo(${1:player})"},
	{ "trigger": "on_touch_damage\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::on_touch_damage(${1:player})"},
	{ "trigger": "on_touch_health\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::on_touch_health(${1:player})"},
	{ "trigger": "on_touch_perk\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::on_touch_perk(${1:player})"},
	{ "trigger": "has_active_gadget\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::has_active_gadget()"},
	{ "trigger": "take_player_gadgets\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::take_player_gadgets()"},
	{ "trigger": "take_offhand_weapon\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::take_offhand_weapon(${1:offhandSlot})"},
	{ "trigger": "should_switch_to_pickup_weapon\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::should_switch_to_pickup_weapon(${1:weapon})"},
	{ "trigger": "on_touch_weapon\t#using scripts\\mp\\_pickup_items;", "contents": "pickup_items::on_touch_weapon(${1:player})"},
	{ "trigger": "ConfigureTeamPost\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::ConfigureTeamPost(${1:player}, ${2:isHacked})"},
	{ "trigger": "_WatchModeSwap\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::_WatchModeSwap(${1:robot}, ${2:player})"},
	{ "trigger": "ActivateCombatRobot\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::ActivateCombatRobot(${1:killstreak})"},
	{ "trigger": "DropKillThread\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::DropKillThread()"},
	{ "trigger": "WatchHelicopterDeath\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::WatchHelicopterDeath(${1:context})"},
	{ "trigger": "Prolog\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::Prolog(${1:context})"},
	{ "trigger": "respectNotTargetedByRobotPerk\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::respectNotTargetedByRobotPerk(${1:player})"},
	{ "trigger": "Epilog\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::Epilog(${1:context})"},
	{ "trigger": "WaitThenSetDeleteAfterDestructionWaitTime\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::WaitThenSetDeleteAfterDestructionWaitTime(${1:set_wait_time}, ${2:delete_after_destruction_wait_time})"},
	{ "trigger": "HackedCallbackPost\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::HackedCallbackPost(${1:hacker})"},
	{ "trigger": "WatchCombatRobotHelicopterHacked\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::WatchCombatRobotHelicopterHacked(${1:helicopter})"},
	{ "trigger": "CleanupThread\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::CleanupThread(${1:context})"},
	{ "trigger": "WatchCombatRobotDeath\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::WatchCombatRobotDeath()"},
	{ "trigger": "WatchCombatRobotLanding\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::WatchCombatRobotLanding()"},
	{ "trigger": "SetupCombatRobotHintTrigger\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::SetupCombatRobotHintTrigger(${1:player})"},
	{ "trigger": "WatchCombatRobotOwnerDisconnect\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::WatchCombatRobotOwnerDisconnect(${1:player})"},
	{ "trigger": "OnCombatRobotTimeout\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::OnCombatRobotTimeout()"},
	{ "trigger": "WatchCombatRobotShutdown\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::WatchCombatRobotShutdown()"},
	{ "trigger": "sndWatchCombatRobotVoxNotifies\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::sndWatchCombatRobotVoxNotifies()"},
	{ "trigger": "sndWatchExit\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::sndWatchExit()"},
	{ "trigger": "sndWatchLanding\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::sndWatchLanding()"},
	{ "trigger": "sndWatchActivate\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::sndWatchActivate()"},
	{ "trigger": "combatRobotDamageOverride\t#using scripts\\mp\\killstreaks\\_combat_robot;", "contents": "combat_robot::combatRobotDamageOverride(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:psOffsetTime}, ${11:boneIndex}, ${12:modelIndex})"},
	{ "trigger": "updateObjectiveHintMessages\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::updateObjectiveHintMessages(${1:defenderTeam}, ${2:defendMessage}, ${3:attackMessage})"},
	{ "trigger": "updateObjectiveHintMessage\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::updateObjectiveHintMessage(${1:message})"},
	{ "trigger": "getRespawnDelay\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::getRespawnDelay()"},
	{ "trigger": "onStartGameType\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::onStartGameType()"},
	{ "trigger": "pause_time\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::pause_time()"},
	{ "trigger": "resume_time\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::resume_time()"},
	{ "trigger": "updateGametypeDvars\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::updateGametypeDvars()"},
	{ "trigger": "spawn_first_zone\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::spawn_first_zone(${1:delay})"},
	{ "trigger": "spawn_next_zone\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::spawn_next_zone()"},
	{ "trigger": "getNumTouching\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::getNumTouching()"},
	{ "trigger": "toggleZoneEffects\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::toggleZoneEffects(${1:enabled})"},
	{ "trigger": "KothCaptureLoop\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::KothCaptureLoop()"},
	{ "trigger": "KothMainLoop\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::KothMainLoop()"},
	{ "trigger": "hideTimerDisplayOnGameEnd\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::hideTimerDisplayOnGameEnd()"},
	{ "trigger": "forceSpawnTeam\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::forceSpawnTeam(${1:team})"},
	{ "trigger": "updateTeamClientField\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::updateTeamClientField()"},
	{ "trigger": "onBeginUse\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::onBeginUse(${1:player})"},
	{ "trigger": "onEndUse\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::onEndUse(${1:team}, ${2:player}, ${3:success})"},
	{ "trigger": "onZoneCapture\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::onZoneCapture(${1:player})"},
	{ "trigger": "track_capture_time\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::track_capture_time()"},
	{ "trigger": "give_capture_credit\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::give_capture_credit(${1:touchList}, ${2:string}, ${3:captureTime}, ${4:capture_team}, ${5:lastCaptureTeam})"},
	{ "trigger": "give_held_credit\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::give_held_credit(${1:touchList}, ${2:team})"},
	{ "trigger": "onZoneDestroy\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::onZoneDestroy(${1:player})"},
	{ "trigger": "onZoneUnoccupied\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::onZoneUnoccupied()"},
	{ "trigger": "onZoneContested\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::onZoneContested()"},
	{ "trigger": "onZoneUncontested\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::onZoneUncontested(${1:lastClaimTeam})"},
	{ "trigger": "MoveZoneAfterTime\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::MoveZoneAfterTime(${1:time})"},
	{ "trigger": "awardCapturePoints\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::awardCapturePoints(${1:team}, ${2:lastCaptureTeam})"},
	{ "trigger": "koth_playerSpawnedCB\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::koth_playerSpawnedCB()"},
	{ "trigger": "CompareZoneIndexes\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::CompareZoneIndexes(${1:zone_a}, ${2:zone_b})"},
	{ "trigger": "getZoneArray\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::getZoneArray()"},
	{ "trigger": "SetupZones\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::SetupZones()"},
	{ "trigger": "setupZoneExclusions\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::setupZoneExclusions()"},
	{ "trigger": "setUpNearbySpawns\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::setUpNearbySpawns()"},
	{ "trigger": "GetFirstZone\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::GetFirstZone()"},
	{ "trigger": "GetNextZone\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::GetNextZone()"},
	{ "trigger": "PickRandomZoneToSpawn\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::PickRandomZoneToSpawn()"},
	{ "trigger": "ShuffleZones\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::ShuffleZones()"},
	{ "trigger": "GetNextZoneFromQueue\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::GetNextZoneFromQueue()"},
	{ "trigger": "GetCountOfTeamsWithPlayers\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::GetCountOfTeamsWithPlayers(${1:num})"},
	{ "trigger": "GetPointCost\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::GetPointCost(${1:avgpos}, ${2:origin})"},
	{ "trigger": "PickZoneToSpawn\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::PickZoneToSpawn()"},
	{ "trigger": "onRoundSwitch\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::onRoundSwitch()"},
	{ "trigger": "onPlayerKilled\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::onPlayerKilled(${1:eInflictor}, ${2:attacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime}, ${9:deathAnimDuration})"},
	{ "trigger": "killWhileContesting\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::killWhileContesting()"},
	{ "trigger": "onEndGame\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::onEndGame(${1:winningTeam})"},
	{ "trigger": "createZoneSpawnInfluencer\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::createZoneSpawnInfluencer()"},
	{ "trigger": "updateCapsPerMinute\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::updateCapsPerMinute(${1:lastOwnerTeam})"},
	{ "trigger": "isScoreBoosting\t#using scripts\\mp\\gametypes\\koth;", "contents": "koth::isScoreBoosting(${1:player})"},
	{ "trigger": "update_settings\t#using scripts\\mp\\gametypes\\_spectating;", "contents": "spectating::update_settings()"},
	{ "trigger": "get_splitscreen_team\t#using scripts\\mp\\gametypes\\_spectating;", "contents": "spectating::get_splitscreen_team()"},
	{ "trigger": "other_local_player_still_alive\t#using scripts\\mp\\gametypes\\_spectating;", "contents": "spectating::other_local_player_still_alive()"},
	{ "trigger": "allow_all_teams\t#using scripts\\mp\\gametypes\\_spectating;", "contents": "spectating::allow_all_teams(${1:allow})"},
	{ "trigger": "allow_all_teams_except\t#using scripts\\mp\\gametypes\\_spectating;", "contents": "spectating::allow_all_teams_except(${1:skip_team}, ${2:allow})"},
	{ "trigger": "set_permissions\t#using scripts\\mp\\gametypes\\_spectating;", "contents": "spectating::set_permissions()"},
	{ "trigger": "set_permissions_for_machine\t#using scripts\\mp\\gametypes\\_spectating;", "contents": "spectating::set_permissions_for_machine()"},
	{ "trigger": "on_connect\t#using scripts\\mp\\gametypes\\_loadout; self = player", "contents": "loadout::on_connect()"},
	{ "trigger": "create_class_exclusion_list\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::create_class_exclusion_list()"},
	{ "trigger": "is_attachment_excluded\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::is_attachment_excluded(${1:attachment})"},
	{ "trigger": "set_statstable_id\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::set_statstable_id()"},
	{ "trigger": "get_item_count\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::get_item_count(${1:itemReference})"},
	{ "trigger": "getDefaultClassSlotWithExclusions\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::getDefaultClassSlotWithExclusions(${1:className}, ${2:slotName})"},
	{ "trigger": "load_default_loadout\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::load_default_loadout(${1:weaponclass}, ${2:classNum})"},
	{ "trigger": "weapon_class_register\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::weapon_class_register(${1:weaponName}, ${2:weapon_type})"},
	{ "trigger": "hero_register_dialog\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::hero_register_dialog(${1:weapon})"},
	{ "trigger": "getClassChoice\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::getClassChoice(${1:response})"},
	{ "trigger": "getAttachmentString\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::getAttachmentString(${1:weaponNum}, ${2:attachmentNum})"},
	{ "trigger": "getAttachmentsDisabled\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::getAttachmentsDisabled()"},
	{ "trigger": "getKillStreakIndex\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::getKillStreakIndex(${1:weaponclass}, ${2:killstreakNum})"},
	{ "trigger": "giveKillstreaks\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::giveKillstreaks()"},
	{ "trigger": "isPerkGroup\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::isPerkGroup(${1:perkName})"},
	{ "trigger": "reset_specialty_slots\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::reset_specialty_slots(${1:class_num})"},
	{ "trigger": "isEquipmentAllowed\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::isEquipmentAllowed(${1:equipment_name})"},
	{ "trigger": "isLeagueItemRestricted\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::isLeagueItemRestricted(${1:item})"},
	{ "trigger": "giveLoadoutLevelSpecific\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::giveLoadoutLevelSpecific(${1:team}, ${2:weaponclass})"},
	{ "trigger": "givePerks\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::givePerks()"},
	{ "trigger": "setClassNum\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::setClassNum(${1:weaponClass})"},
	{ "trigger": "giveBaseWeapon\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::giveBaseWeapon()"},
	{ "trigger": "giveWeapons\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::giveWeapons()"},
	{ "trigger": "givePrimaryOffhand\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::givePrimaryOffhand()"},
	{ "trigger": "giveSecondaryOffhand\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::giveSecondaryOffhand()"},
	{ "trigger": "giveSpecialOffhand\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::giveSpecialOffhand()"},
	{ "trigger": "giveHeroWeapon\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::giveHeroWeapon()"},
	{ "trigger": "giveLoadout\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::giveLoadout(${1:team}, ${2:weaponclass})"},
	{ "trigger": "giveLoadout_finalize\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::giveLoadout_finalize(${1:spawnWeapon}, ${2:primaryWeapon})"},
	{ "trigger": "setWeaponAmmoOverall\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::setWeaponAmmoOverall(${1:weapon}, ${2:amount})"},
	{ "trigger": "on_player_connecting\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::on_player_connecting()"},
	{ "trigger": "fadeAway\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::fadeAway(${1:waitDelay}, ${2:fadeDelay})"},
	{ "trigger": "setClass\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::setClass(${1:newClass})"},
	{ "trigger": "cac_selector\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::cac_selector()"},
	{ "trigger": "register_perks\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::register_perks()"},
	{ "trigger": "cac_modified_vehicle_damage\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::cac_modified_vehicle_damage(${1:victim}, ${2:attacker}, ${3:damage}, ${4:meansofdeath}, ${5:weapon}, ${6:inflictor})"},
	{ "trigger": "cac_modified_damage\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::cac_modified_damage(${1:victim}, ${2:attacker}, ${3:damage}, ${4:mod}, ${5:weapon}, ${6:inflictor}, ${7:hitloc})"},
	{ "trigger": "isExplosiveDamage\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::isExplosiveDamage(${1:meansofdeath})"},
	{ "trigger": "hasTacticalMask\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::hasTacticalMask(${1:player})"},
	{ "trigger": "isPrimaryDamage\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::isPrimaryDamage(${1:meansofdeath})"},
	{ "trigger": "isBulletDamage\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::isBulletDamage(${1:meansofdeath})"},
	{ "trigger": "isFMJDamage\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::isFMJDamage(${1:sWeapon}, ${2:sMeansOfDeath}, ${3:attacker})"},
	{ "trigger": "isFireDamage\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::isFireDamage(${1:weapon}, ${2:meansofdeath})"},
	{ "trigger": "isHeadDamage\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::isHeadDamage(${1:hitloc})"},
	{ "trigger": "grenadeStuck\t#using scripts\\mp\\gametypes\\_loadout;", "contents": "loadout::grenadeStuck(${1:inflictor})"},
	{ "trigger": "add_timed_event\t#using scripts\\mp\\_events;", "contents": "events::add_timed_event(${1:seconds}, ${2:notify_string}, ${3:client_notify_string})"},
	{ "trigger": "timed_event_monitor\t#using scripts\\mp\\_events;", "contents": "events::timed_event_monitor(${1:seconds}, ${2:notify_string}, ${3:client_notify_string})"},
	{ "trigger": "add_score_event\t#using scripts\\mp\\_events;", "contents": "events::add_score_event(${1:score}, ${2:notify_string}, ${3:client_notify_string})"},
	{ "trigger": "add_round_score_event\t#using scripts\\mp\\_events;", "contents": "events::add_round_score_event(${1:score}, ${2:notify_string}, ${3:client_notify_string})"},
	{ "trigger": "any_team_reach_score\t#using scripts\\mp\\_events;", "contents": "events::any_team_reach_score(${1:score})"},
	{ "trigger": "score_team_event_monitor\t#using scripts\\mp\\_events;", "contents": "events::score_team_event_monitor(${1:score}, ${2:notify_string}, ${3:client_notify_string})"},
	{ "trigger": "score_event_monitor\t#using scripts\\mp\\_events;", "contents": "events::score_event_monitor(${1:score}, ${2:notify_string}, ${3:client_notify_string})"},
	{ "trigger": "event_notify\t#using scripts\\mp\\_events;", "contents": "events::event_notify(${1:notify_string}, ${2:client_notify_string})"},
	{ "trigger": "OnPlayerConnect\t#using scripts\\mp\\killstreaks\\_satellite;", "contents": "satellite::OnPlayerConnect()"},
	{ "trigger": "OnPlayerSpawned\t#using scripts\\mp\\killstreaks\\_satellite;", "contents": "satellite::OnPlayerSpawned(${1:local_client_num})"},
	{ "trigger": "ActivateSatellite\t#using scripts\\mp\\killstreaks\\_satellite;", "contents": "satellite::ActivateSatellite()"},
	{ "trigger": "HackedPreFunction\t#using scripts\\mp\\killstreaks\\_satellite;", "contents": "satellite::HackedPreFunction(${1:hacker})"},
	{ "trigger": "ConfigureTeamPost\t#using scripts\\mp\\killstreaks\\_satellite;", "contents": "satellite::ConfigureTeamPost(${1:owner}, ${2:isHacked})"},
	{ "trigger": "Rotate\t#using scripts\\mp\\killstreaks\\_satellite;", "contents": "satellite::Rotate(${1:duration})"},
	{ "trigger": "OnLowHealth\t#using scripts\\mp\\killstreaks\\_satellite;", "contents": "satellite::OnLowHealth(${1:attacker}, ${2:weapon})"},
	{ "trigger": "OnTeamChange\t#using scripts\\mp\\killstreaks\\_satellite;", "contents": "satellite::OnTeamChange(${1:entNum}, ${2:event})"},
	{ "trigger": "OnTimeout\t#using scripts\\mp\\killstreaks\\_satellite;", "contents": "satellite::OnTimeout()"},
	{ "trigger": "DestroySatelliteByEMP\t#using scripts\\mp\\killstreaks\\_satellite;", "contents": "satellite::DestroySatelliteByEMP(${1:attacker}, ${2:arg})"},
	{ "trigger": "DestroySatellite\t#using scripts\\mp\\killstreaks\\_satellite;", "contents": "satellite::DestroySatellite(${1:attacker = undefined}, ${2:weapon = undefined})"},
	{ "trigger": "HasSatellite\t#using scripts\\mp\\killstreaks\\_satellite;", "contents": "satellite::HasSatellite(${1:team_or_entnum})"},
	{ "trigger": "AddActiveSatellite\t#using scripts\\mp\\killstreaks\\_satellite;", "contents": "satellite::AddActiveSatellite()"},
	{ "trigger": "RemoveActiveSatellite\t#using scripts\\mp\\killstreaks\\_satellite;", "contents": "satellite::RemoveActiveSatellite()"},
	{ "trigger": "ResetActiveSatellite\t#using scripts\\mp\\killstreaks\\_satellite;", "contents": "satellite::ResetActiveSatellite()"},
	{ "trigger": "SatelliteTracker\t#using scripts\\mp\\killstreaks\\_satellite;", "contents": "satellite::SatelliteTracker()"},
	{ "trigger": "UpdatePlayerSatelliteForDM\t#using scripts\\mp\\killstreaks\\_satellite;", "contents": "satellite::UpdatePlayerSatelliteForDM(${1:player})"},
	{ "trigger": "killstreakDamageModifier\t#using scripts\\mp\\killstreaks\\_satellite;", "contents": "satellite::killstreakDamageModifier(${1:damage}, ${2:attacker}, ${3:direction}, ${4:point}, ${5:sMeansOfDeath}, ${6:tagName}, ${7:modelName}, ${8:partname}, ${9:weapon}, ${10:flags}, ${11:inflictor}, ${12:chargeLevel})"},
	{ "trigger": "on_player_spawned\t#using scripts\\mp\\_armblade; self == player", "contents": "armblade::on_player_spawned()"},
	{ "trigger": "armblade_sound_thread\t#using scripts\\mp\\_armblade;", "contents": "armblade::armblade_sound_thread()"},
	{ "trigger": "TimeUntilSpawn\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::TimeUntilSpawn(${1:includeTeamkillDelay})"},
	{ "trigger": "allTeamsHaveExisted\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::allTeamsHaveExisted()"},
	{ "trigger": "maySpawn\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::maySpawn()"},
	{ "trigger": "TimeUntilWaveSpawn\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::TimeUntilWaveSpawn(${1:minimumWait})"},
	{ "trigger": "stopPoisoningAndFlareOnSpawn\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::stopPoisoningAndFlareOnSpawn()"},
	{ "trigger": "spawnPlayerPrediction\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::spawnPlayerPrediction()"},
	{ "trigger": "doInitialSpawnMessaging\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::doInitialSpawnMessaging()"},
	{ "trigger": "spawnPlayer\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::spawnPlayer()"},
	{ "trigger": "noteMomentumOnGameEnded\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::noteMomentumOnGameEnded()"},
	{ "trigger": "sndDelayedMusicStart\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::sndDelayedMusicStart(${1:music})"},
	{ "trigger": "spawnSpectator\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::spawnSpectator(${1:origin}, ${2:angles})"},
	{ "trigger": "respawn_asSpectator\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::respawn_asSpectator(${1:origin}, ${2:angles})"},
	{ "trigger": "in_spawnSpectator\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::in_spawnSpectator(${1:origin}, ${2:angles})"},
	{ "trigger": "spectatorThirdPersonness\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::spectatorThirdPersonness()"},
	{ "trigger": "forceSpawn\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::forceSpawn(${1:time})"},
	{ "trigger": "kickIfDontSpawn\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::kickIfDontSpawn()"},
	{ "trigger": "kickIfIDontSpawnInternal\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::kickIfIDontSpawnInternal()"},
	{ "trigger": "kickWait\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::kickWait(${1:waittime})"},
	{ "trigger": "spawnInterRoundIntermission\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::spawnInterRoundIntermission()"},
	{ "trigger": "spawnIntermission\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::spawnIntermission(${1:useDefaultCallback}, ${2:endGame})"},
	{ "trigger": "spawnQueuedClientOnTeam\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::spawnQueuedClientOnTeam(${1:team})"},
	{ "trigger": "spawnQueuedClient\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::spawnQueuedClient(${1:dead_player_team}, ${2:killer})"},
	{ "trigger": "allTeamsNearScoreLimit\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::allTeamsNearScoreLimit()"},
	{ "trigger": "shouldShowRespawnMessage\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::shouldShowRespawnMessage()"},
	{ "trigger": "default_spawnMessage\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::default_spawnMessage()"},
	{ "trigger": "showSpawnMessage\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::showSpawnMessage()"},
	{ "trigger": "spawnClient\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::spawnClient(${1:timeAlreadyPassed})"},
	{ "trigger": "waitAndSpawnClient\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::waitAndSpawnClient(${1:timeAlreadyPassed})"},
	{ "trigger": "waitRespawnOrSafeSpawnButton\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::waitRespawnOrSafeSpawnButton()"},
	{ "trigger": "waitInSpawnQueue\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::waitInSpawnQueue()"},
	{ "trigger": "setThirdPerson\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::setThirdPerson(${1:value})"},
	{ "trigger": "setSpawnVariables\t#using scripts\\mp\\gametypes\\_globallogic_spawn;", "contents": "globallogic_spawn::setSpawnVariables()"},
	{ "trigger": "useKillstreakPlaneMortar\t#using scripts\\mp\\killstreaks\\_planemortar;", "contents": "planemortar::useKillstreakPlaneMortar(${1:hardpointType})"},
	{ "trigger": "waittill_confirm_location\t#using scripts\\mp\\killstreaks\\_planemortar;", "contents": "planemortar::waittill_confirm_location()"},
	{ "trigger": "selectPlaneMortarLocation\t#using scripts\\mp\\killstreaks\\_planemortar;", "contents": "planemortar::selectPlaneMortarLocation(${1:hardpointType})"},
	{ "trigger": "waitPlayBackTime\t#using scripts\\mp\\killstreaks\\_planemortar;", "contents": "planemortar::waitPlayBackTime(${1:soundAlias})"},
	{ "trigger": "singleRadarSweep\t#using scripts\\mp\\killstreaks\\_planemortar;", "contents": "planemortar::singleRadarSweep()"},
	{ "trigger": "doRadarSweep\t#using scripts\\mp\\killstreaks\\_planemortar;", "contents": "planemortar::doRadarSweep()"},
	{ "trigger": "usePlaneMortar\t#using scripts\\mp\\killstreaks\\_planemortar;", "contents": "planemortar::usePlaneMortar(${1:positions})"},
	{ "trigger": "doPlaneMortar\t#using scripts\\mp\\killstreaks\\_planemortar;", "contents": "planemortar::doPlaneMortar(${1:positions}, ${2:team}, ${3:killstreak_id})"},
	{ "trigger": "plane_mortar_bda_dialog\t#using scripts\\mp\\killstreaks\\_planemortar;", "contents": "planemortar::plane_mortar_bda_dialog()"},
	{ "trigger": "planeMortar_watchForEndNotify\t#using scripts\\mp\\killstreaks\\_planemortar;", "contents": "planemortar::planeMortar_watchForEndNotify(${1:team}, ${2:killstreak_id})"},
	{ "trigger": "planeMortar_killstreakStop\t#using scripts\\mp\\killstreaks\\_planemortar;", "contents": "planemortar::planeMortar_killstreakStop(${1:team}, ${2:killstreak_id})"},
	{ "trigger": "doBombRun\t#using scripts\\mp\\killstreaks\\_planemortar;", "contents": "planemortar::doBombRun(${1:position}, ${2:yaw}, ${3:team})"},
	{ "trigger": "followBomb\t#using scripts\\mp\\killstreaks\\_planemortar;", "contents": "planemortar::followBomb(${1:plane}, ${2:position}, ${3:direction}, ${4:impact}, ${5:player})"},
	{ "trigger": "lookAtExplosion\t#using scripts\\mp\\killstreaks\\_planemortar;", "contents": "planemortar::lookAtExplosion(${1:bomb})"},
	{ "trigger": "planeWatchForEmp\t#using scripts\\mp\\killstreaks\\_planemortar;", "contents": "planemortar::planeWatchForEmp(${1:owner})"},
	{ "trigger": "planeAwardScoreEvent\t#using scripts\\mp\\killstreaks\\_planemortar;", "contents": "planemortar::planeAwardScoreEvent(${1:attacker}, ${2:plane})"},
	{ "trigger": "Plane_CleanUpOnDeath\t#using scripts\\mp\\killstreaks\\_planemortar;", "contents": "planemortar::Plane_CleanUpOnDeath()"},
	{ "trigger": "dropBomb\t#using scripts\\mp\\killstreaks\\_planemortar;", "contents": "planemortar::dropBomb(${1:plane}, ${2:bombPosition})"},
	{ "trigger": "OnPlayerConnect\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::OnPlayerConnect()"},
	{ "trigger": "RapsHelicopterDynamicAvoidance\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::RapsHelicopterDynamicAvoidance()"},
	{ "trigger": "RapsHelicopterDynamicAvoidanceUpdate\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::RapsHelicopterDynamicAvoidanceUpdate(${1:index_to_update})"},
	{ "trigger": "ActivateRapsKillstreak\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::ActivateRapsKillstreak(${1:hardpointType})"},
	{ "trigger": "WatchRapsKillstreakEnd\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::WatchRapsKillstreakEnd(${1:killstreakId}, ${2:ownerEntNum}, ${3:team})"},
	{ "trigger": "UpdateKillstreakOnHelicopterDeath\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::UpdateKillstreakOnHelicopterDeath(${1:helicopter}, ${2:ownerEntEnum})"},
	{ "trigger": "OnTeamChanged\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::OnTeamChanged(${1:entNum}, ${2:event})"},
	{ "trigger": "OnEMP\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::OnEMP(${1:attacker}, ${2:ownerEntNum})"},
	{ "trigger": "NoVehicleFaceThread\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::NoVehicleFaceThread(${1:mapCenter}, ${2:radius})"},
	{ "trigger": "InitHelicopterPositions\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::InitHelicopterPositions()"},
	{ "trigger": "TryAddPointForHelicopterPosition\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::TryAddPointForHelicopterPosition(${1:spaciousPoint}, ${2:minFlyHeight})"},
	{ "trigger": "IsTraceSafeForRapsDroneDropFromHelicopter\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::IsTraceSafeForRapsDroneDropFromHelicopter(${1:spaciousPoint}, ${2:traceHeight}, ${3:traceBoxHalfWidth})"},
	{ "trigger": "GetRandomHelicopterStartOrigin\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::GetRandomHelicopterStartOrigin(${1:fly_height}, ${2:firstDropLocation})"},
	{ "trigger": "GetRandomHelicopterLeaveOrigin\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::GetRandomHelicopterLeaveOrigin(${1:fly_height}, ${2:startLocationToLeaveFrom})"},
	{ "trigger": "GetInitialHelicopterFlyHeight\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::GetInitialHelicopterFlyHeight()"},
	{ "trigger": "ConfigureChopperTeamPost\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::ConfigureChopperTeamPost(${1:owner}, ${2:isHacked})"},
	{ "trigger": "SpawnRapsHelicopter\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::SpawnRapsHelicopter(${1:killstreakId})"},
	{ "trigger": "WaitForHelicopterShutdown\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::WaitForHelicopterShutdown()"},
	{ "trigger": "WatchOwnerDisconnect\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::WatchOwnerDisconnect(${1:owner})"},
	{ "trigger": "WatchGameEnded\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::WatchGameEnded()"},
	{ "trigger": "OnDeath\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::OnDeath(${1:attacker}, ${2:weapon})"},
	{ "trigger": "OnLowHealth\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::OnLowHealth(${1:attacker}, ${2:weapon})"},
	{ "trigger": "OnExtraLowHealth\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::OnExtraLowHealth(${1:attacker}, ${2:weapon})"},
	{ "trigger": "GetRandomHelicopterPosition\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::GetRandomHelicopterPosition(${1:avoidPoint = RAPS_HEDEPS_UNSPECIFIED_AVOID_POINT}, ${2:otherAvoidPoint = RAPS_HEDEPS_UNSPECIFIED_AVOID_POINT}, ${3:avoidRadiusSqr = RAPS_HEDEPS_AVOID_RADIUS_SQR})"},
	{ "trigger": "GetClosestRandomHelicopterPosition\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::GetClosestRandomHelicopterPosition(${1:refPoint}, ${2:pickCount}, ${3:avoidPoint = RAPS_HEDEPS_UNSPECIFIED_AVOID_POINT}, ${4:otherAvoidPoint = RAPS_HEDEPS_UNSPECIFIED_AVOID_POINT})"},
	{ "trigger": "WaitForStoppingMoveToExpire\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::WaitForStoppingMoveToExpire()"},
	{ "trigger": "GetOtherHelicopterPointToAvoid\t#using scripts\\mp\\killstreaks\\_raps; self == raps helicopter", "contents": "raps_mp::GetOtherHelicopterPointToAvoid()"},
	{ "trigger": "PickNextDropLocation\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::PickNextDropLocation(${1:heli}, ${2:drop_index}, ${3:firstDropReferencePoint}, ${4:assigned_fly_height}, ${5:lastDropLocation})"},
	{ "trigger": "HelicopterThink\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::HelicopterThink()"},
	{ "trigger": "DropRaps\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::DropRaps()"},
	{ "trigger": "Spin\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::Spin()"},
	{ "trigger": "FirstHeliExplo\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::FirstHeliExplo()"},
	{ "trigger": "HeliLowHealthFx\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::HeliLowHealthFx()"},
	{ "trigger": "HeliExtraLowHealthFx\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::HeliExtraLowHealthFx()"},
	{ "trigger": "HeliDeathTrails\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::HeliDeathTrails()"},
	{ "trigger": "FinalHeliDeathExplode\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::FinalHeliDeathExplode()"},
	{ "trigger": "HelicopterLeave\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::HelicopterLeave()"},
	{ "trigger": "UpdateHelicopterSpeed\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::UpdateHelicopterSpeed(${1:driveMode})"},
	{ "trigger": "StopHelicopter\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::StopHelicopter()"},
	{ "trigger": "SpawnRaps\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::SpawnRaps(${1:origin}, ${2:angles})"},
	{ "trigger": "ConfigureTeamPost\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::ConfigureTeamPost(${1:owner}, ${2:isHacked})"},
	{ "trigger": "AutoSetVisibleToAll\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::AutoSetVisibleToAll()"},
	{ "trigger": "OnRapsTimeout\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::OnRapsTimeout()"},
	{ "trigger": "SelfDestruct\t#using scripts\\mp\\killstreaks\\_raps; self == raps", "contents": "raps_mp::SelfDestruct(${1:attacker})"},
	{ "trigger": "WatchRapsKills\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::WatchRapsKills(${1:originalOwner})"},
	{ "trigger": "WatchRapsTippedOver\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::WatchRapsTippedOver(${1:owner})"},
	{ "trigger": "WatchRapsDeath\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::WatchRapsDeath(${1:originalOwner})"},
	{ "trigger": "InitEnemySelection\t#using scripts\\mp\\killstreaks\\_raps; self == raps", "contents": "raps_mp::InitEnemySelection(${1:owner})"},
	{ "trigger": "InitialWaitUntilSettled\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::InitialWaitUntilSettled()"},
	{ "trigger": "DestroyAllRaps\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::DestroyAllRaps(${1:entNum}, ${2:abandoned = false})"},
	{ "trigger": "ForceGetEnemies\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::ForceGetEnemies()"},
	{ "trigger": "CreateRapsHelicopterInfluencer\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::CreateRapsHelicopterInfluencer()"},
	{ "trigger": "CreateRapsInfluencer\t#using scripts\\mp\\killstreaks\\_raps;", "contents": "raps_mp::CreateRapsInfluencer()"},
	{ "trigger": "setFootstepEffect\t#using scripts\\mp\\_load;", "contents": "load::setFootstepEffect(${1:name}, ${2:fx})"},
	{ "trigger": "footsteps\t#using scripts\\mp\\_load;", "contents": "load::footsteps()"},
	{ "trigger": "setup_traversals\t#using scripts\\mp\\_load;", "contents": "load::setup_traversals()"},
	{ "trigger": "register_clientfields\t#using scripts\\mp\\_load;", "contents": "load::register_clientfields()"},
	{ "trigger": "wait_dart_timed_out\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::wait_dart_timed_out(${1:time})"},
	{ "trigger": "wait_for_throw_status\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::wait_for_throw_status()"},
	{ "trigger": "ActivateDart\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::ActivateDart(${1:killstreakType})"},
	{ "trigger": "cleanup_grenade\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::cleanup_grenade()"},
	{ "trigger": "WatchThrow\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::WatchThrow(${1:missileWeapon})"},
	{ "trigger": "HackedPreFunction\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::HackedPreFunction(${1:hacker})"},
	{ "trigger": "HackedPostFunction\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::HackedPostFunction(${1:hacker})"},
	{ "trigger": "dart_hacked_health_update\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::dart_hacked_health_update(${1:hacker})"},
	{ "trigger": "check_launch_space\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::check_launch_space(${1:origin})"},
	{ "trigger": "SpawnDart\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::SpawnDart(${1:grenade}, ${2:killstreak_id}, ${3:spawn_origin})"},
	{ "trigger": "waitRemoteControl\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::waitRemoteControl()"},
	{ "trigger": "StartDartRemoteControl\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::StartDartRemoteControl(${1:dart})"},
	{ "trigger": "EndDartRemoteControl\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::EndDartRemoteControl(${1:dart}, ${2:exitRequestedByOwner})"},
	{ "trigger": "DartDistanceFailure\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::DartDistanceFailure()"},
	{ "trigger": "stop_remote_weapon\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::stop_remote_weapon(${1:attacker}, ${2:weapon})"},
	{ "trigger": "dartDamageOverride\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::dartDamageOverride(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:vDamageOrigin}, ${11:psOffsetTime}, ${12:damageFromUnderneath}, ${13:modelIndex}, ${14:partName}, ${15:vSurfaceNormal})"},
	{ "trigger": "emp_damage_cb\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::emp_damage_cb(${1:attacker}, ${2:weapon})"},
	{ "trigger": "DarPredictedCollision\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::DarPredictedCollision()"},
	{ "trigger": "WatchCollision\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::WatchCollision()"},
	{ "trigger": "WatchDeath\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::WatchDeath()"},
	{ "trigger": "WatchOwnerNonDeathEvents\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::WatchOwnerNonDeathEvents(${1:endCondition1}, ${2:endCondition2})"},
	{ "trigger": "WatchForGameEnd\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::WatchForGameEnd()"},
	{ "trigger": "WatchAmmo\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::WatchAmmo()"},
	{ "trigger": "leave_dart\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::leave_dart()"},
	{ "trigger": "DeleteOnConditions\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::DeleteOnConditions(${1:condition})"},
	{ "trigger": "waitThenDelete\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::waitThenDelete(${1:waitTime})"},
	{ "trigger": "play_bda_dialog\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::play_bda_dialog(${1:pilotIndex})"},
	{ "trigger": "EnableDartMissileLocking\t#using scripts\\mp\\killstreaks\\_dart; self == dart", "contents": "dart::EnableDartMissileLocking()"},
	{ "trigger": "DisableDartMissileLocking\t#using scripts\\mp\\killstreaks\\_dart; self == dart", "contents": "dart::DisableDartMissileLocking()"},
	{ "trigger": "GetDartMissileTargets\t#using scripts\\mp\\killstreaks\\_dart;", "contents": "dart::GetDartMissileTargets()"},
	{ "trigger": "IsValidDartMissileTarget\t#using scripts\\mp\\killstreaks\\_dart; self == player", "contents": "dart::IsValidDartMissileTarget(${1:ent})"},
	{ "trigger": "IsStillValidDartMissileTarget\t#using scripts\\mp\\killstreaks\\_dart; self == player", "contents": "dart::IsStillValidDartMissileTarget(${1:ent}, ${2:weapon})"},
	{ "trigger": "on_player_connect\t#using scripts\\mp\\gametypes\\_clientids;", "contents": "clientids::on_player_connect()"},
	{ "trigger": "create_incendiary_watcher\t#using scripts\\mp\\_incendiary; self == player", "contents": "incendiary::create_incendiary_watcher()"},
	{ "trigger": "incendiary_system_spawn\t#using scripts\\mp\\_incendiary; self == incendiary grenade", "contents": "incendiary::incendiary_system_spawn(${1:watcher}, ${2:player})"},
	{ "trigger": "watchForExplode\t#using scripts\\mp\\_incendiary;", "contents": "incendiary::watchForExplode(${1:owner})"},
	{ "trigger": "getstepoutdistance\t#using scripts\\mp\\_incendiary;", "contents": "incendiary::getstepoutdistance(${1:normal})"},
	{ "trigger": "generateLocations\t#using scripts\\mp\\_incendiary;", "contents": "incendiary::generateLocations(${1:position}, ${2:owner}, ${3:normal}, ${4:killCamEnt})"},
	{ "trigger": "getLocationForFX\t#using scripts\\mp\\_incendiary;", "contents": "incendiary::getLocationForFX(${1:startPos}, ${2:fxIndex}, ${3:fxCount}, ${4:defaultDistance}, ${5:rotation})"},
	{ "trigger": "spawnAllLocs\t#using scripts\\mp\\_incendiary;", "contents": "incendiary::spawnAllLocs(${1:owner}, ${2:startPos}, ${3:normal}, ${4:multiplier}, ${5:rotation}, ${6:killcament}, ${7:fxCount})"},
	{ "trigger": "damageEffectArea\t#using scripts\\mp\\_incendiary;", "contents": "incendiary::damageEffectArea(${1:owner}, ${2:position}, ${3:radius}, ${4:height}, ${5:killCamEnt})"},
	{ "trigger": "getPotentialTargets\t#using scripts\\mp\\_incendiary; self == incendiary grenade", "contents": "incendiary::getPotentialTargets(${1:owner})"},
	{ "trigger": "tryToApplyFireDamage\t#using scripts\\mp\\_incendiary; self == incendiary grenade", "contents": "incendiary::tryToApplyFireDamage(${1:target}, ${2:owner}, ${3:position}, ${4:fireEffectArea}, ${5:resetFireTime}, ${6:killcament})"},
	{ "trigger": "damageInFireArea\t#using scripts\\mp\\_incendiary; self == player in fire area", "contents": "incendiary::damageInFireArea(${1:fireEffectArea}, ${2:killcament}, ${3:trace}, ${4:position}, ${5:resetFireTime})"},
	{ "trigger": "sndFireDamage\t#using scripts\\mp\\_incendiary;", "contents": "incendiary::sndFireDamage()"},
	{ "trigger": "sndFireDamage_DeleteEnt\t#using scripts\\mp\\_incendiary;", "contents": "incendiary::sndFireDamage_DeleteEnt(${1:ent})"},
	{ "trigger": "hitPos\t#using scripts\\mp\\_incendiary;", "contents": "incendiary::hitPos(${1:start}, ${2:end}, ${3:color})"},
	{ "trigger": "canDoFireDamage\t#using scripts\\mp\\_incendiary;", "contents": "incendiary::canDoFireDamage(${1:killCamEnt}, ${2:victim}, ${3:resetFireTime})"},
	{ "trigger": "resetFireDamage\t#using scripts\\mp\\_incendiary;", "contents": "incendiary::resetFireDamage(${1:entnum}, ${2:time})"},
	{ "trigger": "swarm_killstreak\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::swarm_killstreak(${1:hardpointType})"},
	{ "trigger": "swarm_killstreak_start\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::swarm_killstreak_start(${1:owner}, ${2:killstreak_id})"},
	{ "trigger": "swarm_killstreak_end\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::swarm_killstreak_end(${1:owner}, ${2:detonate}, ${3:killstreak_id})"},
	{ "trigger": "swarm_killstreak_abort\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::swarm_killstreak_abort(${1:owner}, ${2:killstreak_id})"},
	{ "trigger": "swarm_killstreak_watch_for_emp\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::swarm_killstreak_watch_for_emp(${1:owner}, ${2:killstreak_id})"},
	{ "trigger": "swarm_killstreak_fx\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::swarm_killstreak_fx()"},
	{ "trigger": "swarm_think\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::swarm_think(${1:owner}, ${2:killstreak_id})"},
	{ "trigger": "projectile_goal_move\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::projectile_goal_move()"},
	{ "trigger": "projectile_target_search\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::projectile_target_search(${1:acceptSkyExposure}, ${2:acquireTime}, ${3:allowPlayerOffset})"},
	{ "trigger": "target_sounds\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::target_sounds(${1:targetent})"},
	{ "trigger": "target_stop_sounds\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::target_stop_sounds(${1:targetent})"},
	{ "trigger": "reset_sound_blocker\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::reset_sound_blocker(${1:target})"},
	{ "trigger": "projectile_spawn\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::projectile_spawn(${1:owner})"},
	{ "trigger": "projectile_spawn_utility\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::projectile_spawn_utility(${1:owner}, ${2:target}, ${3:origin}, ${4:weapon}, ${5:targetname}, ${6:moveGoal})"},
	{ "trigger": "projectile_death_think\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::projectile_death_think()"},
	{ "trigger": "projectile_abort_think\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::projectile_abort_think()"},
	{ "trigger": "projectile_find_target\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::projectile_find_target(${1:acceptSkyExposure})"},
	{ "trigger": "projectile_find_target_killstreak\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::projectile_find_target_killstreak(${1:acceptSkyExposure})"},
	{ "trigger": "projectile_find_target_player\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::projectile_find_target_player(${1:acceptExposedToSky})"},
	{ "trigger": "create_player_targeting_array\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::create_player_targeting_array(${1:owner}, ${2:team})"},
	{ "trigger": "projectile_find_random_player\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::projectile_find_random_player(${1:owner}, ${2:team})"},
	{ "trigger": "player_valid_target\t#using scripts\\mp\\killstreaks\\_missile_swarm;", "contents": "missile_swarm::player_valid_target(${1:player}, ${2:team}, ${3:owner})"},
	{ "trigger": "OnPlayerConnect\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::OnPlayerConnect()"},
	{ "trigger": "UpdatePlayerState\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::UpdatePlayerState()"},
	{ "trigger": "UpdateAllKillstreakInventory\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::UpdateAllKillstreakInventory()"},
	{ "trigger": "UpdateKillstreakInventory\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::UpdateKillstreakInventory(${1:player})"},
	{ "trigger": "ActivateMainGunner\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::ActivateMainGunner(${1:killstreakType})"},
	{ "trigger": "ActivateSupportGunner\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::ActivateSupportGunner(${1:killstreakType})"},
	{ "trigger": "GetFirstAvailableSeat\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::GetFirstAvailableSeat(${1:player})"},
	{ "trigger": "InitHelicopterSeat\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::InitHelicopterSeat(${1:index}, ${2:destroyTag})"},
	{ "trigger": "HackedPreFunction\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::HackedPreFunction(${1:hacker})"},
	{ "trigger": "HackedPostFunction\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::HackedPostFunction(${1:hacker})"},
	{ "trigger": "SpawnHeliGunner\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::SpawnHeliGunner()"},
	{ "trigger": "HelicopterGunner_hacked_health_callback\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::HelicopterGunner_hacked_health_callback()"},
	{ "trigger": "WaitForGameEndThread\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::WaitForGameEndThread()"},
	{ "trigger": "WaitForVTOLShutdownThread\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::WaitForVTOLShutdownThread()"},
	{ "trigger": "DeleteHelicopterCallback\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::DeleteHelicopterCallback()"},
	{ "trigger": "OnTimeoutCallback\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::OnTimeoutCallback()"},
	{ "trigger": "WatchPlayerTeamChangeThread\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::WatchPlayerTeamChangeThread(${1:helicopter})"},
	{ "trigger": "WatchPlayerExitRequestThread\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::WatchPlayerExitRequestThread(${1:player})"},
	{ "trigger": "EnterHelicopter\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::EnterHelicopter(${1:isOwner})"},
	{ "trigger": "HideCompassAfterWait\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::HideCompassAfterWait(${1:waittime})"},
	{ "trigger": "MainTurretDestroyed\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::MainTurretDestroyed(${1:helicopter}, ${2:eAttacker}, ${3:weapon})"},
	{ "trigger": "wait_for_bda_dialog\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::wait_for_bda_dialog(${1:killstreakId})"},
	{ "trigger": "SupportTurretDestroyed\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::SupportTurretDestroyed(${1:helicopter}, ${2:seatIndex})"},
	{ "trigger": "update_client_for_driver_and_occupants\t#using scripts\\mp\\killstreaks\\_helicopter_gunner; self == vtol", "contents": "helicopter_gunner::update_client_for_driver_and_occupants()"},
	{ "trigger": "update_client_for_player\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::update_client_for_player(${1:player})"},
	{ "trigger": "VTOLDestructibleCallback\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::VTOLDestructibleCallback(${1:brokenNotify}, ${2:eAttacker}, ${3:weapon})"},
	{ "trigger": "AllowMainTurretLockon\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::AllowMainTurretLockon()"},
	{ "trigger": "LeaveHelicopter\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::LeaveHelicopter(${1:player}, ${2:ownerLeft})"},
	{ "trigger": "vtol_shake\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::vtol_shake()"},
	{ "trigger": "HelicopterGunnerDamageOverride\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::HelicopterGunnerDamageOverride(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:vDamageOrigin}, ${11:psOffsetTime}, ${12:damageFromUnderneath}, ${13:modelIndex}, ${14:partName}, ${15:vSurfaceNormal})"},
	{ "trigger": "PerformLeaveHelicopterFromDamage\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::PerformLeaveHelicopterFromDamage()"},
	{ "trigger": "helicopteDetonateViaEMP\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::helicopteDetonateViaEMP(${1:attacker}, ${2:weapon})"},
	{ "trigger": "MissileCleanupThread\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::MissileCleanupThread(${1:missile})"},
	{ "trigger": "WatchMissilesThread\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::WatchMissilesThread()"},
	{ "trigger": "WatchVisionSwitchThread\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::WatchVisionSwitchThread()"},
	{ "trigger": "PlayLockOnSoundsThread\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::PlayLockOnSoundsThread(${1:player}, ${2:heli})"},
	{ "trigger": "EnemyIsLocking\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::EnemyIsLocking(${1:heli})"},
	{ "trigger": "EnemyLockedOn\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::EnemyLockedOn(${1:heli})"},
	{ "trigger": "HelicopterThinkThread\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::HelicopterThinkThread(${1:startNode}, ${2:destNodes})"},
	{ "trigger": "UpdateDrivableTimeForAllOccupants\t#using scripts\\mp\\killstreaks\\_helicopter_gunner; self == vtol", "contents": "helicopter_gunner::UpdateDrivableTimeForAllOccupants(${1:duration_ms}, ${2:end_time_ms})"},
	{ "trigger": "WatchLocationChangeThread\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::WatchLocationChangeThread(${1:destNodes})"},
	{ "trigger": "SetPlayerMovedRecentlyThread\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::SetPlayerMovedRecentlyThread()"},
	{ "trigger": "UpdateAreaNodes\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::UpdateAreaNodes(${1:areaNodes}, ${2:forceMove})"},
	{ "trigger": "TravelToNode\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::TravelToNode(${1:goalNode})"},
	{ "trigger": "GetOriginOffsets\t#using scripts\\mp\\killstreaks\\_helicopter_gunner;", "contents": "helicopter_gunner::GetOriginOffsets(${1:goalNode})"},
	{ "trigger": "bot_idle\t#using scripts\\mp\\bots\\_bot_sd;", "contents": "bot_sd::bot_idle()"},
	{ "trigger": "get_zone_trigger\t#using scripts\\mp\\bots\\_bot_sd;", "contents": "bot_sd::get_zone_trigger(${1:zone})"},
	{ "trigger": "can_plant\t#using scripts\\mp\\bots\\_bot_sd;", "contents": "bot_sd::can_plant(${1:zone})"},
	{ "trigger": "can_defuse\t#using scripts\\mp\\bots\\_bot_sd;", "contents": "bot_sd::can_defuse(${1:zone})"},
	{ "trigger": "bot_post_combat\t#using scripts\\mp\\bots\\_bot_clean;", "contents": "bot_clean::bot_post_combat()"},
	{ "trigger": "bot_idle\t#using scripts\\mp\\bots\\_bot_clean;", "contents": "bot_clean::bot_idle()"},
	{ "trigger": "look_for_taco\t#using scripts\\mp\\bots\\_bot_clean;", "contents": "bot_clean::look_for_taco(${1:radius})"},
	{ "trigger": "get_best_taco\t#using scripts\\mp\\bots\\_bot_clean;", "contents": "bot_clean::get_best_taco(${1:radius})"},
	{ "trigger": "update_threat_goal\t#using scripts\\mp\\bots\\_bot_clean;", "contents": "bot_clean::update_threat_goal()"},
	{ "trigger": "siegebot_update_difficulty\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::siegebot_update_difficulty()"},
	{ "trigger": "defaultRole\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::defaultRole()"},
	{ "trigger": "state_death_update\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::state_death_update(${1:params})"},
	{ "trigger": "siegebot_driving\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::siegebot_driving(${1:params})"},
	{ "trigger": "siegebot_kill_on_tilting\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::siegebot_kill_on_tilting()"},
	{ "trigger": "siegebot_player_fireupdate\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::siegebot_player_fireupdate()"},
	{ "trigger": "siegebot_player_aimUpdate\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::siegebot_player_aimUpdate()"},
	{ "trigger": "emped_enter\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::emped_enter(${1:params})"},
	{ "trigger": "emped_update\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::emped_update(${1:params})"},
	{ "trigger": "emped_exit\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::emped_exit(${1:params})"},
	{ "trigger": "emped_reenter\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::emped_reenter(${1:params})"},
	{ "trigger": "pain_toggle\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::pain_toggle(${1:enabled})"},
	{ "trigger": "pain_update\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::pain_update(${1:params})"},
	{ "trigger": "state_unaware_update\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::state_unaware_update(${1:params})"},
	{ "trigger": "Movement_Thread_Unaware\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::Movement_Thread_Unaware()"},
	{ "trigger": "GetNextMovePosition_unaware\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::GetNextMovePosition_unaware()"},
	{ "trigger": "clean_up_spawned\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::clean_up_spawned()"},
	{ "trigger": "clean_up_spawnedOnDeath\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::clean_up_spawnedOnDeath(${1:entToWatch})"},
	{ "trigger": "state_jump_can_enter\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::state_jump_can_enter(${1:from_state}, ${2:to_state}, ${3:connection})"},
	{ "trigger": "state_jump_enter\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::state_jump_enter(${1:params})"},
	{ "trigger": "state_jump_update\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::state_jump_update(${1:params})"},
	{ "trigger": "state_jump_exit\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::state_jump_exit(${1:params})"},
	{ "trigger": "state_combat_update\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::state_combat_update(${1:params})"},
	{ "trigger": "state_combat_exit\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::state_combat_exit(${1:params})"},
	{ "trigger": "locomotion_start\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::locomotion_start()"},
	{ "trigger": "GetNextMovePosition_tactical\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::GetNextMovePosition_tactical()"},
	{ "trigger": "path_update_interrupt\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::path_update_interrupt()"},
	{ "trigger": "weapon_doors_state\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::weapon_doors_state(${1:isOpen}, ${2:waittime = 0})"},
	{ "trigger": "Movement_Thread\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::Movement_Thread()"},
	{ "trigger": "stopMovementAndSetBrake\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::stopMovementAndSetBrake()"},
	{ "trigger": "face_target\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::face_target(${1:position}, ${2:targetAngleDiff})"},
	{ "trigger": "Scan\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::Scan()"},
	{ "trigger": "Attack_Thread_machinegun\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::Attack_Thread_machinegun()"},
	{ "trigger": "Attack_Rocket\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::Attack_Rocket(${1:target})"},
	{ "trigger": "Attack_Thread_Rocket\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::Attack_Thread_Rocket()"},
	{ "trigger": "monitor_enter_vehicle\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::monitor_enter_vehicle()"},
	{ "trigger": "siegebot_callback_damage\t#using scripts\\mp\\vehicles\\_siegebot;", "contents": "siegebot::siegebot_callback_damage(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:vDamageOrigin}, ${11:psOffsetTime}, ${12:damageFromUnderneath}, ${13:modelIndex}, ${14:partName}, ${15:vSurfaceNormal})"},
	{ "trigger": "InitTurretVehicle\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::InitTurretVehicle()"},
	{ "trigger": "on_player_spawned\t#using scripts\\mp\\killstreaks\\_microwave_turret; self == player", "contents": "microwave_turret::on_player_spawned()"},
	{ "trigger": "on_vehicle_spawned\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::on_vehicle_spawned()"},
	{ "trigger": "reset_being_microwaved\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::reset_being_microwaved()"},
	{ "trigger": "ActivateMicrowaveTurret\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::ActivateMicrowaveTurret()"},
	{ "trigger": "OnPlaceTurret\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::OnPlaceTurret(${1:turret})"},
	{ "trigger": "HackedPreFunction\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::HackedPreFunction(${1:hacker})"},
	{ "trigger": "HackedPostFunction\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::HackedPostFunction(${1:hacker})"},
	{ "trigger": "OnCancelPlacement\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::OnCancelPlacement(${1:turret})"},
	{ "trigger": "OnPickupTurret\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::OnPickupTurret(${1:turret})"},
	{ "trigger": "GhostAfterWait\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::GhostAfterWait(${1:wait_time})"},
	{ "trigger": "OnEMP\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::OnEMP(${1:attacker})"},
	{ "trigger": "OnTurretDamage\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::OnTurretDamage(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:vDamageOrigin}, ${11:psOffsetTime}, ${12:damageFromUnderneath}, ${13:modelIndex}, ${14:partName}, ${15:vSurfaceNormal})"},
	{ "trigger": "OnTurretDeath\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::OnTurretDeath(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime})"},
	{ "trigger": "OnTurretDeathPostGame\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::OnTurretDeathPostGame(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime})"},
	{ "trigger": "OnShutdown\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::OnShutdown(${1:turret})"},
	{ "trigger": "WatchKillstreakEnd\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::WatchKillstreakEnd(${1:killstreak_id}, ${2:team})"},
	{ "trigger": "StartMicrowave\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::StartMicrowave()"},
	{ "trigger": "StopMicrowave\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::StopMicrowave()"},
	{ "trigger": "TurretThink\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::TurretThink()"},
	{ "trigger": "MicrowaveEntityPostShutdownCleanup\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::MicrowaveEntityPostShutdownCleanup(${1:entity})"},
	{ "trigger": "MicrowaveEntity\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::MicrowaveEntity(${1:entity})"},
	{ "trigger": "MicrowaveTurretAffectsEntity\t#using scripts\\mp\\killstreaks\\_microwave_turret;", "contents": "microwave_turret::MicrowaveTurretAffectsEntity(${1:entity})"},
	{ "trigger": "precache\t#using scripts\\mp\\teams\\_teamset_allies;", "contents": "_teamset_allies::precache()"},
	{ "trigger": "isGameRepInitialized\t#using scripts\\mp\\_gamerep;", "contents": "gamerep::isGameRepInitialized()"},
	{ "trigger": "isGameRepEnabled\t#using scripts\\mp\\_gamerep;", "contents": "gamerep::isGameRepEnabled()"},
	{ "trigger": "gameRepInitializeParams\t#using scripts\\mp\\_gamerep;", "contents": "gamerep::gameRepInitializeParams()"},
	{ "trigger": "gameRepPlayerConnected\t#using scripts\\mp\\_gamerep;", "contents": "gamerep::gameRepPlayerConnected()"},
	{ "trigger": "gameRepPlayerDisconnected\t#using scripts\\mp\\_gamerep;", "contents": "gamerep::gameRepPlayerDisconnected()"},
	{ "trigger": "gameRepUpdateNonPersistentPlayerInformation\t#using scripts\\mp\\_gamerep;", "contents": "gamerep::gameRepUpdateNonPersistentPlayerInformation()"},
	{ "trigger": "gameRepUpdatePersistentPlayerInformation\t#using scripts\\mp\\_gamerep;", "contents": "gamerep::gameRepUpdatePersistentPlayerInformation()"},
	{ "trigger": "getParamValueForPlayer\t#using scripts\\mp\\_gamerep;", "contents": "gamerep::getParamValueForPlayer(${1:playerName}, ${2:paramName})"},
	{ "trigger": "isGameRepParamValid\t#using scripts\\mp\\_gamerep;", "contents": "gamerep::isGameRepParamValid(${1:paramName})"},
	{ "trigger": "isGameRepParamIgnoredForReporting\t#using scripts\\mp\\_gamerep;", "contents": "gamerep::isGameRepParamIgnoredForReporting(${1:paramName})"},
	{ "trigger": "getGameRepParamLimit\t#using scripts\\mp\\_gamerep;", "contents": "gamerep::getGameRepParamLimit(${1:paramName})"},
	{ "trigger": "setMaximumParamValueForCurrentGame\t#using scripts\\mp\\_gamerep;", "contents": "gamerep::setMaximumParamValueForCurrentGame(${1:paramName}, ${2:value})"},
	{ "trigger": "gameRepUpdateInformationForRound\t#using scripts\\mp\\_gamerep;", "contents": "gamerep::gameRepUpdateInformationForRound()"},
	{ "trigger": "gameRepAnalyzeAndReport\t#using scripts\\mp\\_gamerep;", "contents": "gamerep::gameRepAnalyzeAndReport()"},
	{ "trigger": "gameRepPrepareAndReport\t#using scripts\\mp\\_gamerep;", "contents": "gamerep::gameRepPrepareAndReport(${1:paramName})"},
	{ "trigger": "on_bot_spawned\t#using scripts\\mp\\bots\\_bot_koth;", "contents": "bot_koth::on_bot_spawned()"},
	{ "trigger": "wait_zone_moved\t#using scripts\\mp\\bots\\_bot_koth;", "contents": "bot_koth::wait_zone_moved()"},
	{ "trigger": "bot_update_threat_goal\t#using scripts\\mp\\bots\\_bot_koth;", "contents": "bot_koth::bot_update_threat_goal()"},
	{ "trigger": "bot_idle\t#using scripts\\mp\\bots\\_bot_koth;", "contents": "bot_koth::bot_idle()"},
	{ "trigger": "deceased.timeOfDeathMillis - GetTime\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::deceased.timeOfDeathMillis - GetTime(${1:value (in milliseconds) at TOD})"},
	{ "trigger": "onPlayerConnect\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::onPlayerConnect()"},
	{ "trigger": "onPlayerSpawned\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::onPlayerSpawned()"},
	{ "trigger": "onDeath\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::onDeath()"},
	{ "trigger": "onTeamChange\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::onTeamChange()"},
	{ "trigger": "onGrenadeThrow\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::onGrenadeThrow()"},
	{ "trigger": "get_friendly_team_mask\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::get_friendly_team_mask(${1:team})"},
	{ "trigger": "get_enemy_team_mask\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::get_enemy_team_mask(${1:team})"},
	{ "trigger": "create_influencer\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::create_influencer(${1:name}, ${2:origin}, ${3:team_mask})"},
	{ "trigger": "create_friendly_influencer\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::create_friendly_influencer(${1:name}, ${2:origin}, ${3:team})"},
	{ "trigger": "create_enemy_influencer\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::create_enemy_influencer(${1:name}, ${2:origin}, ${3:team})"},
	{ "trigger": "create_entity_influencer\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::create_entity_influencer(${1:name}, ${2:team_mask})"},
	{ "trigger": "create_entity_friendly_influencer\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::create_entity_friendly_influencer(${1:name}, ${2:team})"},
	{ "trigger": "create_entity_enemy_influencer\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::create_entity_enemy_influencer(${1:name}, ${2:team})"},
	{ "trigger": "create_entity_masked_friendly_influencer\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::create_entity_masked_friendly_influencer(${1:name}, ${2:team_mask})"},
	{ "trigger": "create_entity_masked_enemy_influencer\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::create_entity_masked_enemy_influencer(${1:name}, ${2:team_mask})"},
	{ "trigger": "create_player_influencers\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::create_player_influencers()"},
	{ "trigger": "create_player_spawn_influencers\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::create_player_spawn_influencers(${1:spawn_origin})"},
	{ "trigger": "remove_influencer\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::remove_influencer(${1:to_be_removed})"},
	{ "trigger": "remove_influencers\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::remove_influencers()"},
	{ "trigger": "watch_remove_influencer\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::watch_remove_influencer()"},
	{ "trigger": "enable_influencers\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::enable_influencers(${1:enabled})"},
	{ "trigger": "enable_player_influencers\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::enable_player_influencers(${1:enabled})"},
	{ "trigger": "player_influencers_set_team\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::player_influencers_set_team()"},
	{ "trigger": "create_grenade_influencers\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::create_grenade_influencers(${1:parent_team}, ${2:weapon}, ${3:grenade})"},
	{ "trigger": "create_map_placed_influencers\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::create_map_placed_influencers()"},
	{ "trigger": "create_map_placed_influencer\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::create_map_placed_influencer(${1:influencer_entity})"},
	{ "trigger": "updateAllSpawnPoints\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::updateAllSpawnPoints()"},
	{ "trigger": "update_fallback_spawnpoints\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::update_fallback_spawnpoints()"},
	{ "trigger": "add_fallback_spawnpoints\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::add_fallback_spawnpoints(${1:team}, ${2:point_class})"},
	{ "trigger": "is_spawn_trapped\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::is_spawn_trapped(${1:team})"},
	{ "trigger": "use_start_spawns\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::use_start_spawns(${1:predictedSpawn})"},
	{ "trigger": "onSpawnPlayer\t#using scripts\\mp\\gametypes\\_spawning; self == player", "contents": "spawning::onSpawnPlayer(${1:predictedSpawn})"},
	{ "trigger": "getSpawnPoint\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::getSpawnPoint()"},
	{ "trigger": "get_best_spawnpoint\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::get_best_spawnpoint(${1:point_team}, ${2:influencer_team}, ${3:player}, ${4:predictedSpawn})"},
	{ "trigger": "gatherSpawnPoints\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::gatherSpawnPoints(${1:player_team})"},
	{ "trigger": "is_hardcore\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::is_hardcore()"},
	{ "trigger": "teams_have_enmity\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::teams_have_enmity()"},
	{ "trigger": "remove_unused_spawn_entities\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::remove_unused_spawn_entities()"},
	{ "trigger": "delete_all_spawns\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::delete_all_spawns(${1:spawnpoints})"},
	{ "trigger": "spawn_point_class_name_being_used\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::spawn_point_class_name_being_used(${1:name})"},
	{ "trigger": "CodeCallback_UpdateSpawnPoints\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::CodeCallback_UpdateSpawnPoints()"},
	{ "trigger": "getTeamStartSpawnName\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::getTeamStartSpawnName(${1:team}, ${2:spawnpointNameBase})"},
	{ "trigger": "getTDMStartSpawnName\t#using scripts\\mp\\gametypes\\_spawning;", "contents": "spawning::getTDMStartSpawnName(${1:team})"},
	{ "trigger": "on_player_connect\t#using scripts\\mp\\_perks;", "contents": "spawning::on_player_connect(${1:local_client_num})"},
	{ "trigger": "on_player_spawned\t#using scripts\\mp\\_perks;", "contents": "spawning::on_player_spawned(${1:local_client_num})"},
	{ "trigger": "monitorFlight\t#using scripts\\mp\\_perks;", "contents": "spawning::monitorFlight()"},
	{ "trigger": "monitorGPSJammer\t#using scripts\\mp\\_perks;", "contents": "spawning::monitorGPSJammer()"},
	{ "trigger": "monitorSenGrenJammer\t#using scripts\\mp\\_perks;", "contents": "spawning::monitorSenGrenJammer()"},
	{ "trigger": "add_spawn_points_internal\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::add_spawn_points_internal(${1:team}, ${2:spawnpoints}, ${3:list})"},
	{ "trigger": "clear_spawn_points\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::clear_spawn_points()"},
	{ "trigger": "add_spawn_points\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::add_spawn_points(${1:team}, ${2:spawnPointName})"},
	{ "trigger": "rebuild_spawn_points\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::rebuild_spawn_points(${1:team})"},
	{ "trigger": "place_spawn_points\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::place_spawn_points(${1:spawnPointName})"},
	{ "trigger": "drop_spawn_points\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::drop_spawn_points(${1:spawnPointName})"},
	{ "trigger": "add_spawn_point_classname\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::add_spawn_point_classname(${1:spawnPointClassName})"},
	{ "trigger": "add_spawn_point_team_classname\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::add_spawn_point_team_classname(${1:team}, ${2:spawnPointClassName})"},
	{ "trigger": "_get_spawnpoint_array\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::_get_spawnpoint_array(${1:spawnpoint_name})"},
	{ "trigger": "get_spawnpoint_array\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::get_spawnpoint_array(${1:classname})"},
	{ "trigger": "get_team_spawnpoints\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::get_team_spawnpoints(${1:team})"},
	{ "trigger": "get_spawnpoint_final\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::get_spawnpoint_final(${1:spawnpoints}, ${2:useweights}, ${3:predictedSpawn}, ${4:isIntermmissionSpawn = false})"},
	{ "trigger": "finalize_spawnpoint_choice\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::finalize_spawnpoint_choice(${1:spawnpoint}, ${2:predictedSpawn})"},
	{ "trigger": "get_best_weighted_spawnpoint\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::get_best_weighted_spawnpoint(${1:spawnpoints})"},
	{ "trigger": "get_spawnpoint_random\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::get_spawnpoint_random(${1:spawnpoints}, ${2:predictedSpawn}, ${3:isIntermissionSpawn = false})"},
	{ "trigger": "get_all_other_players\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::get_all_other_players()"},
	{ "trigger": "get_all_allied_and_enemy_players\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::get_all_allied_and_enemy_players(${1:obj})"},
	{ "trigger": "get_spawnpoint_near_team\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::get_spawnpoint_near_team(${1:spawnpoints}, ${2:favoredspawnpoints})"},
	{ "trigger": "get_spawnpoint_dm\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::get_spawnpoint_dm(${1:spawnpoints})"},
	{ "trigger": "begin\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::begin()"},
	{ "trigger": "death_occured\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::death_occured(${1:dier}, ${2:killer})"},
	{ "trigger": "check_for_similar_deaths\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::check_for_similar_deaths(${1:deathInfo})"},
	{ "trigger": "update_death_info\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::update_death_info()"},
	{ "trigger": "is_point_vulnerable\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::is_point_vulnerable(${1:playerorigin})"},
	{ "trigger": "avoid_weapon_damage\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::avoid_weapon_damage(${1:spawnpoints})"},
	{ "trigger": "spawn_per_frame_update\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::spawn_per_frame_update()"},
	{ "trigger": "get_non_team_sum\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::get_non_team_sum(${1:skip_team}, ${2:sums})"},
	{ "trigger": "get_non_team_min_dist\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::get_non_team_min_dist(${1:skip_team}, ${2:minDists})"},
	{ "trigger": "spawnpoint_update\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::spawnpoint_update(${1:spawnpoint})"},
	{ "trigger": "get_los_penalty\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::get_los_penalty()"},
	{ "trigger": "last_minute_sight_traces\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::last_minute_sight_traces(${1:spawnpoint})"},
	{ "trigger": "avoid_visible_enemies\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::avoid_visible_enemies(${1:spawnpoints}, ${2:teambased})"},
	{ "trigger": "avoid_spawn_reuse\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::avoid_spawn_reuse(${1:spawnpoints}, ${2:teambased})"},
	{ "trigger": "avoid_same_spawn\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::avoid_same_spawn(${1:spawnpoints})"},
	{ "trigger": "get_random_intermission_point\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::get_random_intermission_point()"},
	{ "trigger": "move_spawn_point\t#using scripts\\mp\\gametypes\\_spawnlogic;", "contents": "spawnlogic::move_spawn_point(${1:targetname}, ${2:start_point}, ${3:new_point}, ${4:new_angles})"},
	{ "trigger": "createThreatDetectorWatcher\t#using scripts\\mp\\_threat_detector;", "contents": "threat_detector::createThreatDetectorWatcher()"},
	{ "trigger": "onSpawnThreatDetector\t#using scripts\\mp\\_threat_detector;", "contents": "threat_detector::onSpawnThreatDetector(${1:watcher}, ${2:player})"},
	{ "trigger": "watchForStationary\t#using scripts\\mp\\_threat_detector;", "contents": "threat_detector::watchForStationary(${1:owner})"},
	{ "trigger": "trackSensorGrenadeVictim\t#using scripts\\mp\\_threat_detector;", "contents": "threat_detector::trackSensorGrenadeVictim(${1:victim})"},
	{ "trigger": "threatDetectorDestroyed\t#using scripts\\mp\\_threat_detector;", "contents": "threat_detector::threatDetectorDestroyed(${1:attacker}, ${2:weapon}, ${3:target})"},
	{ "trigger": "watchThreatDetectorDamage\t#using scripts\\mp\\_threat_detector; self == sensor grenade", "contents": "threat_detector::watchThreatDetectorDamage(${1:watcher})"},
	{ "trigger": "missile_drone_killstreak\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::missile_drone_killstreak(${1:killstreakType})"},
	{ "trigger": "useMissileDrone\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::useMissileDrone(${1:hardpointType})"},
	{ "trigger": "missileDroneWatcher\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::missileDroneWatcher(${1:hardpointType})"},
	{ "trigger": "doMissileDrone\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::doMissileDrone(${1:origin}, ${2:weapon}, ${3:killstreak_id}, ${4:hardpointType}, ${5:team})"},
	{ "trigger": "waitThenDelete\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::waitThenDelete(${1:waitTime})"},
	{ "trigger": "projectile_death_think\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::projectile_death_think()"},
	{ "trigger": "drone_target_acquired\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::drone_target_acquired(${1:hardpointType}, ${2:target})"},
	{ "trigger": "drone_target_search\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::drone_target_search(${1:hardpointType})"},
	{ "trigger": "vecscale\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::vecscale(${1:vec}, ${2:scalar})"},
	{ "trigger": "set_drone_target\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::set_drone_target(${1:hardpointType}, ${2:target})"},
	{ "trigger": "check_target_lost\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::check_target_lost(${1:target})"},
	{ "trigger": "projectile_find_target\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::projectile_find_target(${1:owner}, ${2:minCos})"},
	{ "trigger": "projectile_find_target_killstreak\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::projectile_find_target_killstreak(${1:owner}, ${2:minCos})"},
	{ "trigger": "projectile_find_target_player\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::projectile_find_target_player(${1:owner}, ${2:minCos})"},
	{ "trigger": "killstreak_stop_think\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::killstreak_stop_think(${1:killstreak_id}, ${2:hardpointType}, ${3:team})"},
	{ "trigger": "checkWeaponChange\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::checkWeaponChange(${1:hardpointType}, ${2:team}, ${3:killstreak_id})"},
	{ "trigger": "watchOwnerDeath\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::watchOwnerDeath(${1:hardpointType}, ${2:team}, ${3:killstreak_id})"},
	{ "trigger": "checkForEmp\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::checkForEmp()"},
	{ "trigger": "watchDamage\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::watchDamage()"},
	{ "trigger": "get_array_sorted_dot_prod\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::get_array_sorted_dot_prod(${1:array}, ${2:minCos})"},
	{ "trigger": "updateTargetting\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::updateTargetting()"},
	{ "trigger": "clearInvalidDroneTarget\t#using scripts\\mp\\killstreaks\\_missile_drone;", "contents": "missile_drone::clearInvalidDroneTarget()"},
	{ "trigger": "register_killstreak_bundle\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::register_killstreak_bundle(${1:killstreakType})"},
	{ "trigger": "get_bundle\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::get_bundle(${1:killstreak})"},
	{ "trigger": "get_hack_timeout\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::get_hack_timeout()"},
	{ "trigger": "get_hack_protection\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::get_hack_protection()"},
	{ "trigger": "get_hack_tool_inner_time\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::get_hack_tool_inner_time()"},
	{ "trigger": "get_hack_tool_outer_time\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::get_hack_tool_outer_time()"},
	{ "trigger": "get_hack_tool_inner_radius\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::get_hack_tool_inner_radius()"},
	{ "trigger": "get_hack_tool_outer_radius\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::get_hack_tool_outer_radius()"},
	{ "trigger": "get_lost_line_of_sight_limit_msec\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::get_lost_line_of_sight_limit_msec()"},
	{ "trigger": "get_hack_tool_no_line_of_sight_time\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::get_hack_tool_no_line_of_sight_time()"},
	{ "trigger": "get_hack_scoreevent\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::get_hack_scoreevent()"},
	{ "trigger": "get_hack_fx\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::get_hack_fx()"},
	{ "trigger": "get_hack_loop_fx\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::get_hack_loop_fx()"},
	{ "trigger": "get_max_health\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::get_max_health(${1:killstreakType})"},
	{ "trigger": "get_low_health\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::get_low_health(${1:killstreakType})"},
	{ "trigger": "get_hacked_health\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::get_hacked_health(${1:killstreakType})"},
	{ "trigger": "get_shots_to_kill\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::get_shots_to_kill(${1:weapon}, ${2:meansOfDeath}, ${3:bundle})"},
	{ "trigger": "get_emp_grenade_damage\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::get_emp_grenade_damage(${1:killstreakType}, ${2:maxhealth})"},
	{ "trigger": "get_weapon_damage\t#using scripts\\mp\\killstreaks\\_killstreak_bundles;", "contents": "killstreak_bundles::get_weapon_damage(${1:killstreakType}, ${2:maxhealth}, ${3:attacker}, ${4:weapon}, ${5:type}, ${6:damage}, ${7:flags}, ${8:chargeShotLevel})"},
	{ "trigger": "release_control_on_landing\t#using scripts\\mp\\bots\\_bot_ball;", "contents": "bot_ball::release_control_on_landing()"},
	{ "trigger": "bot_pre_combat\t#using scripts\\mp\\bots\\_bot_ball;", "contents": "bot_ball::bot_pre_combat()"},
	{ "trigger": "bot_combat\t#using scripts\\mp\\bots\\_bot_ball;", "contents": "bot_ball::bot_combat()"},
	{ "trigger": "bot_idle\t#using scripts\\mp\\bots\\_bot_ball;", "contents": "bot_ball::bot_idle()"},
	{ "trigger": "SpawnPlaceable\t#using scripts\\mp\\killstreaks\\_placeables;", "contents": "placeables::SpawnPlaceable(${1:killstreakRef}, ${2:killstreakId}, ${3:})"},
	{ "trigger": "UpdatePlacementModels\t#using scripts\\mp\\killstreaks\\_placeables;", "contents": "placeables::UpdatePlacementModels(${1:model}, ${2:validModel}, ${3:invalidModel})"},
	{ "trigger": "CarryPlaceable\t#using scripts\\mp\\killstreaks\\_placeables;", "contents": "placeables::CarryPlaceable(${1:placeable})"},
	{ "trigger": "InNoPlacementTrigger\t#using scripts\\mp\\killstreaks\\_placeables;", "contents": "placeables::InNoPlacementTrigger()"},
	{ "trigger": "WatchPlacement\t#using scripts\\mp\\killstreaks\\_placeables;", "contents": "placeables::WatchPlacement(${1:placeable})"},
	{ "trigger": "WatchCarryCancelEvents\t#using scripts\\mp\\killstreaks\\_placeables;", "contents": "placeables::WatchCarryCancelEvents(${1:placeable})"},
	{ "trigger": "OnTimeout\t#using scripts\\mp\\killstreaks\\_placeables;", "contents": "placeables::OnTimeout()"},
	{ "trigger": "OnDeath\t#using scripts\\mp\\killstreaks\\_placeables;", "contents": "placeables::OnDeath(${1:attacker}, ${2:weapon})"},
	{ "trigger": "OnEMP\t#using scripts\\mp\\killstreaks\\_placeables;", "contents": "placeables::OnEMP(${1:attacker})"},
	{ "trigger": "CancelOnPlayerDisconnect\t#using scripts\\mp\\killstreaks\\_placeables;", "contents": "placeables::CancelOnPlayerDisconnect(${1:placeable})"},
	{ "trigger": "CancelOnGameEnd\t#using scripts\\mp\\killstreaks\\_placeables;", "contents": "placeables::CancelOnGameEnd(${1:placeable})"},
	{ "trigger": "SpawnMoveTrigger\t#using scripts\\mp\\killstreaks\\_placeables;", "contents": "placeables::SpawnMoveTrigger(${1:placeable}, ${2:player})"},
	{ "trigger": "WatchMoveTriggerShutdown\t#using scripts\\mp\\killstreaks\\_placeables;", "contents": "placeables::WatchMoveTriggerShutdown(${1:placeable})"},
	{ "trigger": "WatchPickup\t#using scripts\\mp\\killstreaks\\_placeables;", "contents": "placeables::WatchPickup(${1:player})"},
	{ "trigger": "ForceShutdown\t#using scripts\\mp\\killstreaks\\_placeables;", "contents": "placeables::ForceShutdown()"},
	{ "trigger": "WatchOwnerGameEvents\t#using scripts\\mp\\killstreaks\\_placeables;", "contents": "placeables::WatchOwnerGameEvents()"},
	{ "trigger": "ShutdownOnCancelEvent\t#using scripts\\mp\\killstreaks\\_placeables;", "contents": "placeables::ShutdownOnCancelEvent(${1:placeable})"},
	{ "trigger": "SetupTraits\t#using scripts\\mp\\_behavior_tracker;", "contents": "behaviorTracker::SetupTraits()"},
	{ "trigger": "Initialize\t#using scripts\\mp\\_behavior_tracker;", "contents": "behaviorTracker::Initialize()"},
	{ "trigger": "Finalize\t#using scripts\\mp\\_behavior_tracker;", "contents": "behaviorTracker::Finalize()"},
	{ "trigger": "IsAllowed\t#using scripts\\mp\\_behavior_tracker;", "contents": "behaviorTracker::IsAllowed()"},
	{ "trigger": "PrintTrackerToBlackBox\t#using scripts\\mp\\_behavior_tracker;", "contents": "behaviorTracker::PrintTrackerToBlackBox()"},
	{ "trigger": "GetTraitValue\t#using scripts\\mp\\_behavior_tracker;", "contents": "behaviorTracker::GetTraitValue(${1:trait})"},
	{ "trigger": "SetTraitValue\t#using scripts\\mp\\_behavior_tracker;", "contents": "behaviorTracker::SetTraitValue(${1:trait}, ${2:value})"},
	{ "trigger": "UpdateTrait\t#using scripts\\mp\\_behavior_tracker;", "contents": "behaviorTracker::UpdateTrait(${1:trait}, ${2:percent})"},
	{ "trigger": "UpdatePlayerDamage\t#using scripts\\mp\\_behavior_tracker;", "contents": "behaviorTracker::UpdatePlayerDamage(${1:attacker}, ${2:victim}, ${3:damage})"},
	{ "trigger": "UpdatePlayerKilled\t#using scripts\\mp\\_behavior_tracker;", "contents": "behaviorTracker::UpdatePlayerKilled(${1:attacker}, ${2:victim})"},
	{ "trigger": "SetTraitStats\t#using scripts\\mp\\_behavior_tracker;", "contents": "behaviorTracker::SetTraitStats()"},
	{ "trigger": "GetTraitStatValue\t#using scripts\\mp\\_behavior_tracker;", "contents": "behaviorTracker::GetTraitStatValue(${1:trait})"},
	{ "trigger": "SetTraitStatValue\t#using scripts\\mp\\_behavior_tracker;", "contents": "behaviorTracker::SetTraitStatValue(${1:trait}, ${2:value})"},
	{ "trigger": "SpawnMannequin\t#using scripts\\mp\\_nuketown_mannequin;", "contents": "NuketownMannequin::SpawnMannequin(${1:origin}, ${2:angles}, ${3:gender = \"male\"}, ${4:speed = undefined}, ${5:weepingAngel})"},
	{ "trigger": "mannequinDamage\t#using scripts\\mp\\_nuketown_mannequin;", "contents": "NuketownMannequin::mannequinDamage(${1:inflictor}, ${2:attacker}, ${3:damage}, ${4:dFlags}, ${5:mod}, ${6:weapon}, ${7:point}, ${8:dir}, ${9:hitLoc}, ${10:offsetTime}, ${11:boneIndex}, ${12:modelIndex})"},
	{ "trigger": "watch_player_looking\t#using scripts\\mp\\_nuketown_mannequin;", "contents": "NuketownMannequin::watch_player_looking()"},
	{ "trigger": "on_joined_team\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::on_joined_team()"},
	{ "trigger": "freezePlayerForRoundEnd\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::freezePlayerForRoundEnd()"},
	{ "trigger": "ArrayToString\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::ArrayToString(${1:inputArray})"},
	{ "trigger": "recordEndGameComScoreEventForPlayer\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::recordEndGameComScoreEventForPlayer(${1:player}, ${2:result})"},
	{ "trigger": "player_monitor_travel_dist\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::player_monitor_travel_dist()"},
	{ "trigger": "record_special_move_data_for_life\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::record_special_move_data_for_life(${1:killer})"},
	{ "trigger": "player_monitor_wall_run\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::player_monitor_wall_run()"},
	{ "trigger": "player_monitor_swimming\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::player_monitor_swimming()"},
	{ "trigger": "player_monitor_slide\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::player_monitor_slide()"},
	{ "trigger": "player_monitor_doublejump\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::player_monitor_doublejump()"},
	{ "trigger": "player_monitor_inactivity\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::player_monitor_inactivity()"},
	{ "trigger": "Callback_PlayerConnect\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::Callback_PlayerConnect()"},
	{ "trigger": "record_global_mp_stats_for_player_at_match_start\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::record_global_mp_stats_for_player_at_match_start()"},
	{ "trigger": "record_global_mp_stats_for_player_at_match_end\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::record_global_mp_stats_for_player_at_match_end()"},
	{ "trigger": "record_misc_player_stats\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::record_misc_player_stats()"},
	{ "trigger": "spectate_player_watcher\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::spectate_player_watcher()"},
	{ "trigger": "Callback_PlayerMigrated\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::Callback_PlayerMigrated()"},
	{ "trigger": "Callback_PlayerDisconnect\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::Callback_PlayerDisconnect()"},
	{ "trigger": "Callback_PlayerMelee\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::Callback_PlayerMelee(${1:eAttacker}, ${2:iDamage}, ${3:weapon}, ${4:vOrigin}, ${5:vDir}, ${6:boneIndex}, ${7:shieldHit}, ${8:fromBehind})"},
	{ "trigger": "chooseNextBestNemesis\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::chooseNextBestNemesis()"},
	{ "trigger": "custom_gamemodes_modified_damage\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::custom_gamemodes_modified_damage(${1:victim}, ${2:eAttacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:eInflictor}, ${7:sHitLoc})"},
	{ "trigger": "figure_out_attacker\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::figure_out_attacker(${1:eAttacker})"},
	{ "trigger": "player_damage_figure_out_weapon\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::player_damage_figure_out_weapon(${1:weapon}, ${2:eInflictor})"},
	{ "trigger": "figure_out_friendly_fire\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::figure_out_friendly_fire(${1:victim})"},
	{ "trigger": "isPlayerImmuneToKillstreak\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::isPlayerImmuneToKillstreak(${1:eAttacker}, ${2:weapon})"},
	{ "trigger": "should_do_player_damage\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::should_do_player_damage(${1:eAttacker}, ${2:weapon}, ${3:sMeansOfDeath}, ${4:iDFlags})"},
	{ "trigger": "apply_damage_to_armor\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::apply_damage_to_armor(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:sHitLoc}, ${7:friendlyFire}, ${8:ignore_round_start_friendly_fire})"},
	{ "trigger": "make_sure_damage_is_not_zero\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::make_sure_damage_is_not_zero(${1:iDamage})"},
	{ "trigger": "modify_player_damage_friendlyfire\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::modify_player_damage_friendlyfire(${1:iDamage})"},
	{ "trigger": "modify_player_damage\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::modify_player_damage(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:psOffsetTime}, ${11:boneIndex})"},
	{ "trigger": "modify_player_damage_meansofdeath\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::modify_player_damage_meansofdeath(${1:eInflictor}, ${2:eAttacker}, ${3:sMeansOfDeath}, ${4:weapon}, ${5:sHitLoc})"},
	{ "trigger": "player_damage_update_attacker\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::player_damage_update_attacker(${1:eInflictor}, ${2:eAttacker}, ${3:sMeansOfDeath})"},
	{ "trigger": "player_is_spawn_protected_from_explosive\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::player_is_spawn_protected_from_explosive(${1:eInflictor}, ${2:weapon}, ${3:sMeansOfDeath})"},
	{ "trigger": "player_damage_update_explosive_info\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::player_damage_update_explosive_info(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:psOffsetTime}, ${11:boneIndex})"},
	{ "trigger": "player_damage_is_friendly_fire_at_round_start\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::player_damage_is_friendly_fire_at_round_start()"},
	{ "trigger": "player_damage_does_friendly_fire_damage_attacker\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::player_damage_does_friendly_fire_damage_attacker(${1:eAttacker}, ${2:ignore_round_start_friendly_fire})"},
	{ "trigger": "player_damage_does_friendly_fire_damage_victim\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::player_damage_does_friendly_fire_damage_victim(${1:ignore_round_start_friendly_fire})"},
	{ "trigger": "player_damage_riotshield_hit\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::player_damage_riotshield_hit(${1:eAttacker}, ${2:iDamage}, ${3:sMeansOfDeath}, ${4:weapon}, ${5:attackerIsHittingTeammate})"},
	{ "trigger": "does_player_completely_avoid_damage\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::does_player_completely_avoid_damage(${1:iDFlags}, ${2:sHitLoc}, ${3:weapon}, ${4:friendlyFire}, ${5:attackerIsHittingSelf}, ${6:sMeansOfDeath})"},
	{ "trigger": "player_damage_log\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::player_damage_log(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:psOffsetTime}, ${11:boneIndex})"},
	{ "trigger": "should_allow_postgame_damage\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::should_allow_postgame_damage(${1:sMeansOfDeath})"},
	{ "trigger": "do_post_game_damage\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::do_post_game_damage(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:vDamageOrigin}, ${11:psOffsetTime}, ${12:boneIndex}, ${13:vSurfaceNormal})"},
	{ "trigger": "Callback_PlayerDamage\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::Callback_PlayerDamage(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:vDamageOrigin}, ${11:psOffsetTime}, ${12:boneIndex}, ${13:vSurfaceNormal})"},
	{ "trigger": "resetAttackerList\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::resetAttackerList()"},
	{ "trigger": "resetAttackersThisSpawnList\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::resetAttackersThisSpawnList()"},
	{ "trigger": "doPerkFeedBack\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::doPerkFeedBack(${1:player}, ${2:weapon}, ${3:sMeansOfDeath}, ${4:eInflictor}, ${5:armor_damaged})"},
	{ "trigger": "isAIKillstreakDamage\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::isAIKillstreakDamage(${1:weapon}, ${2:eInflictor})"},
	{ "trigger": "finishPlayerDamageWrapper\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::finishPlayerDamageWrapper(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:iDFlags}, ${5:sMeansOfDeath}, ${6:weapon}, ${7:vPoint}, ${8:vDir}, ${9:sHitLoc}, ${10:vDamageOrigin}, ${11:psOffsetTime}, ${12:boneIndex}, ${13:vSurfaceNormal})"},
	{ "trigger": "allowedAssistWeapon\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::allowedAssistWeapon(${1:weapon})"},
	{ "trigger": "PlayerKilled_Killstreaks\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::PlayerKilled_Killstreaks(${1:attacker}, ${2:weapon})"},
	{ "trigger": "PlayerKilled_WeaponStats\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::PlayerKilled_WeaponStats(${1:attacker}, ${2:weapon}, ${3:sMeansOfDeath}, ${4:wasInLastStand}, ${5:lastWeaponBeforeDroppingIntoLastStand}, ${6:inflictor})"},
	{ "trigger": "PlayerKilled_Obituary\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::PlayerKilled_Obituary(${1:attacker}, ${2:eInflictor}, ${3:weapon}, ${4:sMeansOfDeath})"},
	{ "trigger": "PlayerKilled_Suicide\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::PlayerKilled_Suicide(${1:eInflictor}, ${2:attacker}, ${3:sMeansOfDeath}, ${4:weapon}, ${5:sHitLoc})"},
	{ "trigger": "PlayerKilled_TeamKill\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::PlayerKilled_TeamKill(${1:eInflictor}, ${2:attacker}, ${3:sMeansOfDeath}, ${4:weapon}, ${5:sHitLoc})"},
	{ "trigger": "wait_and_suicide\t#using scripts\\mp\\gametypes\\_globallogic_player; self == player", "contents": "globallogic_player::wait_and_suicide()"},
	{ "trigger": "PlayerKilled_AwardAssists\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::PlayerKilled_AwardAssists(${1:eInflictor}, ${2:attacker}, ${3:weapon}, ${4:lpattackteam})"},
	{ "trigger": "PlayerKilled_Kill\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::PlayerKilled_Kill(${1:eInflictor}, ${2:attacker}, ${3:sMeansOfDeath}, ${4:weapon}, ${5:sHitLoc})"},
	{ "trigger": "should_allow_postgame_death\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::should_allow_postgame_death(${1:sMeansOfDeath})"},
	{ "trigger": "do_post_game_death\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::do_post_game_death(${1:eInflictor}, ${2:attacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime}, ${9:deathAnimDuration})"},
	{ "trigger": "Callback_PlayerKilled\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::Callback_PlayerKilled(${1:eInflictor}, ${2:attacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime}, ${9:deathAnimDuration}, ${10:enteredResurrect = false})"},
	{ "trigger": "update_ffa_top_scorers\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::update_ffa_top_scorers()"},
	{ "trigger": "playerkilled_watch_death\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::playerkilled_watch_death(${1:weapon}, ${2:sMeansOfDeath}, ${3:deathAnimDuration})"},
	{ "trigger": "should_drop_weapon_on_death\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::should_drop_weapon_on_death(${1:wasTeamKill}, ${2:wasSuicide}, ${3:current_weapon}, ${4:sMeansOfDeath})"},
	{ "trigger": "updateGlobalBotKilledCounter\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::updateGlobalBotKilledCounter()"},
	{ "trigger": "WaitTillKillStreakDone\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::WaitTillKillStreakDone()"},
	{ "trigger": "SuicideKick\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::SuicideKick()"},
	{ "trigger": "TeamKillKick\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::TeamKillKick()"},
	{ "trigger": "TeamKillDelay\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::TeamKillDelay()"},
	{ "trigger": "ShouldTeamKillKick\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::ShouldTeamKillKick(${1:teamKillDelay})"},
	{ "trigger": "reduceTeamKillsOverTime\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::reduceTeamKillsOverTime()"},
	{ "trigger": "IgnoreTeamKills\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::IgnoreTeamKills(${1:weapon}, ${2:sMeansOfDeath}, ${3:eInflictor})"},
	{ "trigger": "Callback_PlayerLastStand\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::Callback_PlayerLastStand(${1:eInflictor}, ${2:eAttacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime}, ${9:deathAnimDuration})"},
	{ "trigger": "damageShellshockAndRumble\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::damageShellshockAndRumble(${1:eAttacker}, ${2:eInflictor}, ${3:weapon}, ${4:sMeansOfDeath}, ${5:iDamage})"},
	{ "trigger": "createDeadBody\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::createDeadBody(${1:attacker}, ${2:iDamage}, ${3:sMeansOfDeath}, ${4:weapon}, ${5:sHitLoc}, ${6:vDir}, ${7:vAttackerOrigin}, ${8:deathAnimDuration}, ${9:eInflictor}, ${10:body})"},
	{ "trigger": "is_explosive_ragdoll\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::is_explosive_ragdoll(${1:weapon}, ${2:inflictor})"},
	{ "trigger": "start_explosive_ragdoll\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::start_explosive_ragdoll(${1:dir}, ${2:weapon})"},
	{ "trigger": "start_death_from_above_ragdoll\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::start_death_from_above_ragdoll(${1:dir})"},
	{ "trigger": "notifyConnecting\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::notifyConnecting()"},
	{ "trigger": "delayStartRagdoll\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::delayStartRagdoll(${1:ent}, ${2:sHitLoc}, ${3:vDir}, ${4:weapon}, ${5:eInflictor}, ${6:sMeansOfDeath})"},
	{ "trigger": "trackAttackerDamage\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::trackAttackerDamage(${1:eAttacker}, ${2:iDamage}, ${3:sMeansOfDeath}, ${4:weapon})"},
	{ "trigger": "giveAttackerAndInflictorOwnerAssist\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::giveAttackerAndInflictorOwnerAssist(${1:eAttacker}, ${2:eInflictor}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:weapon})"},
	{ "trigger": "PlayerKilled_UpdateMeansOfDeath\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::PlayerKilled_UpdateMeansOfDeath(${1:attacker}, ${2:eInflictor}, ${3:weapon}, ${4:sMeansOfDeath}, ${5:sHitLoc})"},
	{ "trigger": "updateAttacker\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::updateAttacker(${1:attacker}, ${2:weapon})"},
	{ "trigger": "updateInflictor\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::updateInflictor(${1:eInflictor})"},
	{ "trigger": "updateWeapon\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::updateWeapon(${1:eInflictor}, ${2:weapon})"},
	{ "trigger": "playKillBattleChatter\t#using scripts\\mp\\gametypes\\_globallogic_player;", "contents": "globallogic_player::playKillBattleChatter(${1:attacker}, ${2:weapon}, ${3:victim}, ${4:eInflictor})"},
	{ "trigger": "spawn_dog_tag\t#using scripts\\mp\\gametypes\\_dogtags;", "contents": "dogtags::spawn_dog_tag(${1:victim}, ${2:attacker}, ${3:on_use_function}, ${4:objectives_for_attacker_and_victim_only})"},
	{ "trigger": "show_to_team\t#using scripts\\mp\\gametypes\\_dogtags;", "contents": "dogtags::show_to_team(${1:gameObject}, ${2:show_team})"},
	{ "trigger": "show_to_enemy_teams\t#using scripts\\mp\\gametypes\\_dogtags;", "contents": "dogtags::show_to_enemy_teams(${1:gameObject}, ${2:friend_team})"},
	{ "trigger": "onUse\t#using scripts\\mp\\gametypes\\_dogtags;", "contents": "dogtags::onUse(${1:player})"},
	{ "trigger": "reset_tags\t#using scripts\\mp\\gametypes\\_dogtags;", "contents": "dogtags::reset_tags()"},
	{ "trigger": "onPickup\t#using scripts\\mp\\gametypes\\_dogtags;", "contents": "dogtags::onPickup(${1:event})"},
	{ "trigger": "clear_on_victim_disconnect\t#using scripts\\mp\\gametypes\\_dogtags;", "contents": "dogtags::clear_on_victim_disconnect(${1:victim})"},
	{ "trigger": "on_spawn_player\t#using scripts\\mp\\gametypes\\_dogtags;", "contents": "dogtags::on_spawn_player()"},
	{ "trigger": "team_updater\t#using scripts\\mp\\gametypes\\_dogtags;", "contents": "dogtags::team_updater(${1:tags})"},
	{ "trigger": "time_out\t#using scripts\\mp\\gametypes\\_dogtags;", "contents": "dogtags::time_out(${1:victim})"},
	{ "trigger": "bounce\t#using scripts\\mp\\gametypes\\_dogtags;", "contents": "dogtags::bounce()"},
	{ "trigger": "checkAllowSpectating\t#using scripts\\mp\\gametypes\\_dogtags;", "contents": "dogtags::checkAllowSpectating()"},
	{ "trigger": "should_spawn_tags\t#using scripts\\mp\\gametypes\\_dogtags;", "contents": "dogtags::should_spawn_tags(${1:eInflictor}, ${2:attacker}, ${3:iDamage}, ${4:sMeansOfDeath}, ${5:sWeapon}, ${6:vDir}, ${7:sHitLoc}, ${8:psOffsetTime}, ${9:deathAnimDuration})"},
	{ "trigger": "onUseDogTag\t#using scripts\\mp\\gametypes\\_dogtags;", "contents": "dogtags::onUseDogTag(${1:player})"},
	{ "trigger": "dt_respawn\t#using scripts\\mp\\gametypes\\_dogtags;", "contents": "dogtags::dt_respawn()"},
	{ "trigger": "waitTillCanSpawnClient\t#using scripts\\mp\\gametypes\\_dogtags;", "contents": "dogtags::waitTillCanSpawnClient()"},
	{ "trigger": "clear_final_killcam_team\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::clear_final_killcam_team(${1:team})"},
	{ "trigger": "record_settings\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::record_settings(${1:spectatorclient}, ${2:targetentityindex}, ${3:weapon}, ${4:meansOfDeath}, ${5:deathTime}, ${6:deathTimeOffset}, ${7:offsettime}, ${8:killcam_entity_info}, ${9:perks}, ${10:killstreaks}, ${11:attacker})"},
	{ "trigger": "erase_final_killcam\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::erase_final_killcam()"},
	{ "trigger": "final_killcam_waiter\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::final_killcam_waiter()"},
	{ "trigger": "post_round_final_killcam\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::post_round_final_killcam()"},
	{ "trigger": "do_final_killcam\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::do_final_killcam()"},
	{ "trigger": "startLastKillcam\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::startLastKillcam()"},
	{ "trigger": "are_any_players_watching\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::are_any_players_watching()"},
	{ "trigger": "watch_for_skip_killcam\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::watch_for_skip_killcam()"},
	{ "trigger": "killcam\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::killcam()"},
	{ "trigger": "set_entity\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::set_entity(${1:killcamentityindex}, ${2:delayms})"},
	{ "trigger": "set_killcam_entities\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::set_killcam_entities(${1:entity_info}, ${2:killcamstarttime})"},
	{ "trigger": "wait_killcam_time\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::wait_killcam_time()"},
	{ "trigger": "wait_final_killcam_slowdown\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::wait_final_killcam_slowdown(${1:deathTime}, ${2:startTime})"},
	{ "trigger": "wait_skip_killcam_button\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::wait_skip_killcam_button()"},
	{ "trigger": "wait_team_change_end_killcam\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::wait_team_change_end_killcam()"},
	{ "trigger": "wait_skip_killcam_safe_spawn_button\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::wait_skip_killcam_safe_spawn_button()"},
	{ "trigger": "end\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::end(${1:final})"},
	{ "trigger": "check_for_abrupt_end\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::check_for_abrupt_end()"},
	{ "trigger": "spawned_killcam_cleanup\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::spawned_killcam_cleanup()"},
	{ "trigger": "spectator_killcam_cleanup\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::spectator_killcam_cleanup(${1:attacker})"},
	{ "trigger": "ended_killcam_cleanup\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::ended_killcam_cleanup()"},
	{ "trigger": "ended_final_killcam_cleanup\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::ended_final_killcam_cleanup()"},
	{ "trigger": "cancel_use_button\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::cancel_use_button()"},
	{ "trigger": "cancel_safe_spawn_button\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::cancel_safe_spawn_button()"},
	{ "trigger": "cancel_callback\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::cancel_callback()"},
	{ "trigger": "cancel_safe_spawn_callback\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::cancel_safe_spawn_callback()"},
	{ "trigger": "cancel_on_use\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::cancel_on_use()"},
	{ "trigger": "cancel_on_use_specific_button\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::cancel_on_use_specific_button(${1:pressingButtonFunc}, ${2:finishedFunc})"},
	{ "trigger": "final_killcam_internal\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::final_killcam_internal(${1:winner})"},
	{ "trigger": "final_killcam\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::final_killcam(${1:winner})"},
	{ "trigger": "spawn_end_of_final_killcam\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::spawn_end_of_final_killcam()"},
	{ "trigger": "is_entity_weapon\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::is_entity_weapon(${1:weapon})"},
	{ "trigger": "calc_time\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::calc_time(${1:weapon}, ${2:entitystarttime}, ${3:predelay}, ${4:respawn}, ${5:maxtime})"},
	{ "trigger": "calc_post_delay\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::calc_post_delay()"},
	{ "trigger": "add_skip_text\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::add_skip_text(${1:respawn})"},
	{ "trigger": "add_timer\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::add_timer(${1:camtime})"},
	{ "trigger": "get_closest_killcam_entity\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::get_closest_killcam_entity(${1:attacker}, ${2:killCamEntities}, ${3:depth})"},
	{ "trigger": "get_killcam_entity\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::get_killcam_entity(${1:attacker}, ${2:eInflictor}, ${3:weapon})"},
	{ "trigger": "get_secondary_killcam_entity\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::get_secondary_killcam_entity(${1:entity}, ${2:entity_info})"},
	{ "trigger": "get_primary_killcam_entity\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::get_primary_killcam_entity(${1:attacker}, ${2:eInflictor}, ${3:weapon}, ${4:entity_info})"},
	{ "trigger": "get_killcam_entity_info\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::get_killcam_entity_info(${1:attacker}, ${2:eInflictor}, ${3:weapon})"},
	{ "trigger": "get_killcam_entity_info_starttime\t#using scripts\\mp\\gametypes\\_killcam;", "contents": "killcam::get_killcam_entity_info_starttime(${1:entity_info})"}
]
}